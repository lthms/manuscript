%!TEX root = ../main.tex
\chapter{Modular Verification of Component-based Systems}
\label{chapter:freespec}

\endquote{``\emph{Give someone a program, you frustrate them for a day; teach
    them how to program, you frustrate them for a lifetime.}''

  \hfill\footnotesize --- David Leinweber}

\vspace{1cm}%
\noindent
%
In the previous Part of this manuscript, we have introduced a theory of \ac{hse}
mechanisms and have leveraged it to specify and verify the \ac{hse} mechanism
implemented by the \ac{bios} at runtime in order to remain isolated from the
rest of the software stack.
%
In this context, we have defined a dedicated x86 hardware model called {\scshape
  Minx86} (Definition~\ref{def:speccert2:minx86}).
%
This experiment has been very insightful.
%
In particular, it has highlighted the key importance of a modular approach to
tackle the challenge posed by the scale of the x86 hardware architecture.
%

This Chapter focuses on our second contribution: an approach to model and verify
each component of a component-based system in isolation, while providing the
necessary abstractions to compose these components\,\cite{letan2018freespec},
along with a companion framework for Coq we called FreeSpec to support this
approach\,\cite{letan2018freespeccode}.

The rest of the Chapter proceeds as follows.
%
We justify our contribution with the experience implementing the proofs of
Chapter~\ref{chapter:speccert2} (Section~\ref{sec:freespec:why}).
%
Then, we describe how we model components in terms of programs with effects and
effect handlers (Section~\ref{sec:freespec:specifying}).
%
Finally, we introduce so-called abstract specifications to verify their
respective properties, and discuss two verification strategies which leverage
them (Section~\ref{sec:freespec:verifying}).

\section{Lessons Learned from {\scshape Minx86}}
\label{sec:freespec:why}
% ==============================================================================

In this Section, we emphasize three limitations of {\scshape Minx86} which makes
its use at a larger scale unlikely (\ref{subsec:freespec:minx86lim}).
%
Then, we explain how we manage to mitigate these limitations to a large extent
when experimenting on {\scshape Minx86}, and discuss how we propose to take the
resulting approach a step further (\ref{subsec:freespec:approachoverview}).
%
Finally, we give an overview of the key concepts of our compositional reasoning
framework (\ref{freespec:subsec:freespecoverview}).

\subsection{{\scshape Minx86} Limitations}
\label{subsec:freespec:minx86lim}

Having reasoned about the correctness of \( \Delta_{\mathtt{bios}} \), we have
identified three limitations which reduce the applicability of {\scshape Minx86}
as we would increase its scope:
\begin{enumerate}
\item its monolithic design;
\item  its weakness against the temporary violation problem\,\cite{muller2006tempviolation};
\item the presence, within our supposedly general-purpose model, of abstract values that are specific to a particular case study.
\end{enumerate}

\paragraph{Monolithic Model.}
%
The set of states \( H(S) \) of {\scshape Minx86} is the Cartesian product of
the sets of states of its hardware components, namely a core, a cache, a memory
controller and two arrays of memory cells.
%
That is, {\scshape Minx86} is a monolithic model, and this is not without
consequences.

During the development of our proof of concept, changes to the definition of
\( H(S) \) had an important impact on proofs already written at the moment.
%
We have no doubt that such situations will arise again if we try to increase the
scope of {\scshape Minx86}.

\begin{figure}
  \inputminted{coq}{Listings/StateHell.v}

  \caption{Raw postcondition of a \texttt{Write} transition with a writeback
    strategy}
  \label{fig:freespec:entrypoint}
\end{figure}

Besides, some transitions of {\scshape Minx86} imply several intermediary state
updates.
%
This is particularly true for \( \func{Read} \) and \( \func{Write} \)
transitions, as both the cache and memories are updated in case of cache misses
or cache evictions.
%
The complexity of a transition postcondition has a direct impact on the proofs
we have to construct in order to verify the correctness of a given system, as
the number of case scenarios to consider increases quickly.
%
We have already given an insight of this in
Subsection~\ref{subsec:speccert2:bioshsedef} when we explained the structure of
the proof that \( \Delta_{\mathtt{bios}} \) complies with the second \ac{hse}
law.
%
The proof goal depicted in Figure~\ref{fig:freespec:entrypoint} ---as presented
by Coq when we are constructing our proof--- is a good illustration of that,
considering it is already a subcase of the complete proof.
%
In this small snippet, we can identify four intermediary states (as shown in
Figure~\ref{fig:freespec:remember}).

\begin{figure}
  \inputminted{coq}{Listings/RememberPattern.v}

  \caption{Postcondition of a \texttt{Write} transition with a writeback
    strategy, after the use of the \texttt{remember} tactic}
  \label{fig:freespec:remember}
\end{figure}

\begin{figure}
  \bigcentering
  \begin{sequencediagram}
    \newinst[1.5]{C}{Core}%
    \newinst[1.5]{Ca}{Cache}{}%
    \newinst[1.5]{MC}{Memory Controller}{}%

    \begin{call}{C}{\texttt{write}(\( \var{pa} \), v, \texttt{priv})}{Ca}{}%
      \begin{call}{Ca}{\texttt{\texttt{cache\_hit}(\( p
            \))}}{Ca}{\texttt{false}}
      \end{call}
      \begin{call}{Ca}{\texttt{\texttt{write}(\( \var{pa}' \), v',
            \texttt{priv})}}{MC}{}
      \end{call}
      \begin{call}{Ca}{\texttt{\texttt{write\_cache\_line}(\(
            \func{index}(\var{pa}), v \))}}{Ca}{}
      \end{call}
    \end{call}
  \end{sequencediagram}

  \caption{Sequence diagram of the execution of \texttt{movq~\$0, (\%rax)}}
  \label{fig:freespec:seqdiagr}
\end{figure}

\paragraph{Temporary Violation Problem.}
%
The complexity of {\scshape Minx86} transitions emphasizes another important
limitation: it is potentially subject to the so-called \emph{temporary violation
  problem}\,\cite{muller2006tempviolation}, where a predicate is satisfied
\emph{before} and \emph{after} a given transition, yet is temporary violated
\emph{during} the transition.
%
A well known illustration of this threat is ---once again--- the airlock system.

\begin{example}[Temporary Violation Problem in an Airlock System]
  In Example~\ref{example:sota:airlocklts}, we have carefully defined the
  labeled transition system of the airlock system so that it is unambiguously
  not subject to the temporary violation problem.
  %
  As a reminder, the targeted security policy for an airlock system is that at
  least one door shall be closed at all time.
  %
  We did that by avoiding transitions between states
  %
  \( (\mathtt{open}, \mathtt{closed}) \) and
  \( (\mathtt{closed}, \mathtt{open}) \).
  %
  We can define a transition system which is correct with respect to the
  targeted safety property \emph{and} includes these transitions.

  \begin{center}
    \begin{tikzpicture}
      \node [draw, circle split, text width=30pt, text badly centered] (cc)
      {\( \mathtt{closed} \) \nodepart{lower} \( \mathtt{closed} \)};%
      \node [right=60pt of cc] (x) {};%
      \node [draw, circle split, above=of x, text width=30pt, text badly
      centered] (oc) {\( \mathtt{open} \) \nodepart{lower}
        \( \mathtt{closed} \)};%
      \node [draw, circle split, below=of x, text width=30pt, text badly
      centered] (co) {\( \mathtt{closed} \) \nodepart{lower}
        \( \mathtt{open} \)};%
      \node [draw, circle split, right=60pt of x, text width=30pt, text badly
      centered] (oo) {\( \mathtt{open} \) \nodepart{lower} \( \mathtt{open}
        \)};%

      \draw [-latex] (cc) edge [bend left] node [xshift=-5pt, left]
      {\( \mathtt{Req}_1 \)} (oc);%

      \draw [-latex] (cc) edge [bend right] node [xshift=-5pt, left]
      {\( \mathtt{Req}_2 \)} (co);%

      \draw [-latex] (oc) edge [bend left] node [right] {\( \mathtt{Req}_2 \)}
      (co);%
      \draw [-latex] (co) edge [bend left] node [left] {\( \mathtt{Req}_1 \)}
      (oc);%
    \end{tikzpicture}
  \end{center}

  We can imagine several scenarios:
  %
  \begin{inparaenum}[(1)]
  \item Doors states updates are simultaneous and instantaneous, in other words
    the transitions \emph{are} atomic.
    %
  \item The airlock system first closes one door before opening the
    other. \label{enum:freespec:goodairlock}
    %
  \item The airlock system first opens one door before closing the
    other. \label{enum:freespec:badairlock}
    %
  \end{inparaenum}[(1)]
  %
  The systems modeled in Examples~\ref{example:sota:airlocklts},
  \ref{example:sota:airlockinterface}, and \ref{example:sota:airlockprocess}
  correspond to the scenario (\ref{enum:freespec:goodairlock}).
  %
  On the contrary, the transition system pictured in this example is not precise
  enough to discard the eventuality that both doors are, at a given point in
  time, both open.
\end{example}

The temporary violation problem undermines the second \ac{hse} law, which
stipulates that the requirement over states of a \ac{hse} mechanism is an
invariant of the model with respect to the requirement over software transitions
(see Definition~\ref{def:speccert:laws}).
%
In practice, transitions in {\scshape Minx86} are not atomic (they are made of
several intermediary state updates, as depicted in
Figure~\ref{fig:freespec:seqdiagr}).
%
Attackers may be able to leverage a temporary violation of invariant, similarly
to the Speed Racer attack\,\cite{kallenberg2015racecondition} detailed in
Subsection~\ref{subsec:usecase:hse:speed}.
%
Modeling that threat without changing the modeling structure of {\scshape
  Minx86} requires to increase the granularity of the transitions, with the
direct consequence to complicate the model.

\paragraph{Abstract Model.}
%
Our decision to embed the memory location ownership directly inside {\scshape
  Minx86}, along side with the concrete content of each memory location,
contradicts our objective to rely on general-purpose models to specify and
verify \ac{hse} mechanisms.
%
Continuing with a similar logic would mean modifying the model each time we want
to reason about a security policy which requires to maintain additional
information.
%
For instance, if we want to determine how many times memory locations have been
updated since the beginning of the trace, we would have to modify the
definitions of \( H(S) \) and of the transition relation to add a counter along
with the owner of a memory location.
%
Modifying the transition relation is likely to break all proofs previously
written, and therefore this greatly reduces the opportunity to reuse {\scshape
  Minx86} for other security policies.
%
% This is important to acknowledge, because it contradicts our initial goal to
% verify \ac{hse} mechanisms of the same architecture against the same
% general-purpose model.

% \begin{table}
%   \center
%   \begin{tabular}{ccccc}
%    $I_{\mathrm{C}}$
%    & $\xrightarrow{\mathrm{Core}}$
%    & $I_{\mathrm{MCH}}$ \\
%    \hline
%    \hline
%    $\mathbb{P}$
%    & $\Longrightarrow$
%    & \ $\mathbb{P}'$ \\
%    $\Downarrow$
%    &
%    &
%      $\Downarrow$ \\
%    $\mathbb{Q}$
%    & $\Longleftarrow$
%    & \ $\mathbb{Q}'$ \\
%    \hline
%  \end{tabular}
%  \caption{Scheme of the verification proof for a component}
%\end{table}

\subsection{Assessments and Perspectives}
\label{subsec:freespec:approachoverview}

In the verification work presented in Chapter~\ref{chapter:speccert2}, we have
successfully managed the limitations of {\scshape Minx86} partly because we have
taken great care in organizing our development as modurarly as we could.
%
We now detail the approach we have used. \GH{autant j'hésite sur la section 6.1.1 autant celle là, telle que tu la présente ici, n'a rien à faire dans le chapitre 6.}

\paragraph{Lessons Learned.}
%
%
Each hardware component has been defined in isolation from the rest of the
hardware architecture, with a set of functions, a set of properties and a set of
general-purpose lemmas.
%
For instance, the directory \texttt{src/Cache/} contains four files:
\texttt{Cache\_def.v}, \texttt{Cache\_func.v}, \texttt{Cache\_proofs.v}, and
\texttt{Cache\_prop.v}.
%
We then have defined \( H(S) \), that is the Cartesian product of
individual components, in a similar manner.
%
Inside the \texttt{src/x86/Architecture/} directory, we defined general-purpose
functions (\texttt{Architecture\_func.v}) and lemmas
(\texttt{Architecture\_proofs.v}) to reason about the hardware architecture as a
whole as often as possible.

This approach has proven to be valuable to deal with the many cases to cover,
when used in conjunction with a recurring pattern we call
``\texttt{remember};~\texttt{destruct};~\texttt{assert};~\texttt{apply}'', after
the Coq tactics.
%
We illustrate the use of this pattern with the proof goal pictured in
Figure~\ref{fig:freespec:entrypoint}.
%
\begin{enumerate}
\item Using \texttt{remember}, we can make the sequence of intermediary state
  updates more visible (see Figure~\ref{fig:freespec:remember}, compared to
  Figure~\ref{fig:freespec:entrypoint}).
  %
  Each \( \mathtt{a\_}i \) is an intermediary state resulting of a call to a
  general-purpose function from the \texttt{Architecture\_func.v} file.
\item Using \texttt{destruct}, we can explore the alternative paths resulting
  from the use of {\scshape Gallina} constructions such as pattern matching, or
  \texttt{if-then-else}.
  %
  For instance, regarding the initial state of the system, the content of the
  address \( \var{pa} \) may or may not be present in the cache
  (Figure~\ref{fig:freespec:remember}, line 14).
  %
  We explore both alternatives thanks to the \texttt{destruct} tactic (see the
  two simplified goals in Figure~\ref{fig:freespec:destruct}, more particularly
  on the value of \texttt{a\_3}).
  %
\item Using \texttt{assert}, we can introduce now goals to prove intermediary
  results (like the one in Figure~\ref{fig:freespec:assert}, for instance).
  %
  In our case, we will prove that the predicate \texttt{hardware\_req} remains
  satisfied after each state update.
  %
\item Using \texttt{apply}, we can leverage lemmas about \texttt{hardware\_req}
  preservation for a given state update, \emph{e.g.} exported by the
  \texttt{Architecture\_proofs.v} or \texttt{Cache\_proofs.v} files.
  %
  For instance, the function \texttt{update\_cache\_content}
  (Figure~\ref{fig:freespec:remember}, line 11) has a companion lemma called
  \texttt{update\_cache\_content\-\_with\_context\_preserves\_inv} that we can
  use to conclude about the goal introduced in Figure~\ref{fig:freespec:assert}.
\end{enumerate}

\begin{figure}
  \inputminted{coq}{Listings/DestructGoal.v}

  \inputminted{coq}{Listings/DestructGoal2.v}

  \caption{Exploring alternative paths thanks to the \texttt{destruct} tactics}
  \label{fig:freespec:destruct}
\end{figure}

\begin{figure}
  \inputminted{coq}{Listings/InvGoals.v}

  \caption{Intermediary statements, generated thanks to \texttt{assert} tactics}
  \label{fig:freespec:assert}
\end{figure}

\begin{figure}
{\bigcentering%
  \AxiomC{}%
  \LeftLabel{\footnotesize {\scshape Id}} \UnaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      \hline
      \vdash \iota(h)
    \end{array}
    \)}%
  \AxiomC{}%
  \RightLabel{\footnotesize {\scshape Inv}\( _r \)} \UnaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      h_1 = r(h) \\
      \hline
      \vdash \iota(h) \Rightarrow \iota(h_1)
    \end{array}
    \)}%
  \LeftLabel{\footnotesize {\scshape M-P}}%
  \BinaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      h_1 = r(h) \\
      \hline
      \vdash \iota(h_1)
    \end{array}
    \)}%
  \AxiomC{}%
  \RightLabel{\footnotesize {\scshape Inv}\( _s \)} \UnaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      h_1 = r(h) \\
      h_2 = s(h_1) \\
      \hline
      \vdash \iota(h_1) \Rightarrow \iota(h_2)
    \end{array}
    \)}%
  \LeftLabel{\footnotesize {\scshape M-P}}%
  \BinaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      h_1 = r(h) \\
      h_2 = s(h_1) \\
      \hline
      \vdash \iota(h_2)
    \end{array}
    \)}%
  \AxiomC{}%
  \RightLabel{\footnotesize {\scshape Inv}\( _t \)} \UnaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      h_1 = r(h) \\
      h_2 = s(h_1) \\
      h' = t(h_2) \\
      \hline \vdash \iota(h_2) \Rightarrow \iota (h')
    \end{array}
    \)}%
  \RightLabel{\footnotesize {\scshape M-P}}%
  \BinaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      h_1 = r(h) \\
      h_2 = s(h_1) \\
      h' = t(h_2) \\
      \hline \vdash \iota (h')
    \end{array}
    \)}%
  \DisplayProof%

  \vspace{0.5cm} where {\scshape M-P} is the \emph{Modus ponens}, and {\scshape
    Inv}\( _r \), {\scshape Inv}\( _s \), and {\scshape Inv}\( _t \) are
  intermediary lemmas previously proved true.%
}

\caption{Dividing a transition into a sequences of intermediary state updates}
\label{freespec:figure:seqproof}
\end{figure}

Figure \ref{freespec:figure:seqproof} depicts the typical shape of resulting
proofs trees.
%
The proofs are structured around smaller, more atomic proof goals of the form
\( \iota(h_i) \Rightarrow \iota(h_{i+1}) \), where \( \iota \) is supposedly an
invariant, \( h_i \) is an intermediary state, and \( h_{i+1} \) its successor.
%
Beside, it can help uncover temporary violation problems thanks to the
intermediary goals introduced with \texttt{assert}.

\paragraph{Perspectives.}
%
Decoupling the hardware components as much as possible, and relying on the
``\texttt{remember};~\texttt{destruct};~\texttt{assert};~\texttt{apply}''
pattern to reason about their successive state updates has proven to be an
effective way to mitigate the monolithic design of {\scshape Minx86}, and has
the potential to address the temporary violation problem.
%
However, it remains cumbersome to use manually.
%
With FreeSpec, our objective is twofold.

Firstly, we want to propose a general-purpose formalism that allows for never
considering the hardware architecture as a whole, but rather focus on
interactions between neighboring components.
%
To that end, we take the principle of our theory of \ac{hse} mechanism a step
further.
%
Our approach is based onto a clear separation between hardware components from the
one side, and software components from the other side.
%
Software components can interact with hardware components through the execution
of instructions, modeled by the software transitions of the hardware model, and
we specify requirements over how trusted software requirements interact with the
hardware architecture.
%
With FreeSpec, we apply the same reasoning for hardware components alike: we
specify how they interact together, and specify requirements over these
interactions.

Secondly, we want to automate as much as possible the
\texttt{remember};~\texttt{destruct};~\texttt{assert};~\texttt{apply} pattern,
in a way that enables formally reasoning about the temporary violation problem.
%
This objective is reminiscent of the programming language problematic to model
and verify large programs with side effects.
%
Reasoning about side effects in purely functional languages such as {\textsc
  Gallina}, the Coq specification language, is difficult, firstly because they
imply to somehow take into account an outer \emph{stateful} environment and
secondly, because the composition of stateful computations is not well-handled
by traditional (monadic) approaches.
%
Algebraic effects and handlers\,\cite{bauer2015effects} overcome this double
challenge.
%
They allow to model large classes of effects (e.g., exception, state,
non-determinism) and to compose effects within purely functional programs, while
deferring the realizations of these effects to dedicated handlers.
%
In this Chapter, we aim to show how a variant of algebraic effects based on free
monads can be used to support reasoning about component-based systems, including
with respect to the temporary violation problem.

\subsection{FreeSpec Overview}
\label{freespec:subsec:freespecoverview}

\begin{figure}
  \centering
  \begin{tikzpicture}
    % Memory Controller
    \node [inner sep=15pt, draw] (MC) {Memory Controller};%
    \draw ([yshift=5pt, xshift=3pt]MC.north west) -- ([yshift=5pt,
    xshift=-3pt]MC.north east);%
    \node [right=4pt of MC.north east, yshift=3pt, text width=0.5cm] (Im)
    {$I_{\mathrm{MC}}$};%
    \node [left=4pt of MC.north west, yshift=3pt, text width=0.5cm] (Im_shadow)
    {};%

    % Cache & IOMMU
    \node [above=30pt of MC] (CIO) {};%
    % -- Cache
    \node [inner sep=8pt, draw, right=13pt of CIO.center] (Cache) {Cache};%
    \draw ([yshift=5pt, xshift=3pt]Cache.north west) -- ([yshift=5pt,
    xshift=-3pt]Cache.north east);%
    \node [right=4pt of Cache.north east, yshift=3pt, text width=0.5cm] (Ic)
    {$I_{\mathrm{Cache}}$};%
    \node [left=4pt of Cache.north west, yshift=3pt, text width=0.5cm]
    (Ic_shadow) {};%
    % -- IOMMU
    \node [inner sep=8pt, draw, dashed, left=5pt of CIO.center] (IOMMU) {I/O
      MMU};%

    % CPU
    \node [inner sep=8pt, draw, above=20pt of Cache] (CPU) {Core};%
    \draw ([yshift=5pt, xshift=3pt]CPU.north west) -- ([yshift=5pt,
    xshift=-3pt]CPU.north east);%
    \node [right=4pt of CPU.north east, yshift=3pt] (Ic) {$I_{\mathrm{C}}$};%

    % Software
    \node [inner sep=8pt, draw, dashed, above=30pt of CPU.center] (S)
    {Software};%

    % Mems
    \node [below=50pt of MC.center] (M) {};%
    % -- DRAM
    \node [inner sep=8pt, draw, left=3pt of M.center, text width=1.3cm, text
    badly centered] (DRAM) {DRAM};%
    \draw ([yshift=5pt, xshift=3pt]DRAM.north west) -- ([yshift=5pt,
    xshift=-3pt]DRAM.north east);%
    \node [left=4pt of DRAM.north west, yshift=3pt, text width=1cm] (Id)
    {$I_{\mathrm{DRAM}}$};%
    % -- VGA
    \node [inner sep=8pt, draw, right=3pt of M.center, text width=1.3cm, text
    badly centered] (VGA) {VGA};%
    \draw ([yshift=5pt, xshift=3pt]VGA.north west) -- ([yshift=5pt,
    xshift=-3pt]VGA.north east);%
    \node [right=4pt of VGA.north east, yshift=3pt, text width=1cm] (Iv)
    {$I_{\mathrm{VGA}}$};%

    % arrows
    \draw [-latex] (CPU.south) -- ([yshift=5pt]Cache.north);%
    \draw [-latex] (S.south) -- ([yshift=5pt]CPU.north);%
    \draw [latex-] ([yshift=5pt]DRAM.north) |- (MC.south);%
    \draw [latex-] ([yshift=5pt]VGA.north) |- (MC.south);%
    \draw [-latex] (IOMMU.south) -- ([yshift=-41pt]IOMMU.north);%
    \draw [-latex] (Cache.south) -- ([yshift=-41pt]Cache.north);
  \end{tikzpicture}

  \caption{Interface-driven modeling of the x86 architecture}
  \label{fig:freespec:interfacedriven}
\end{figure}

We now give an overview of the formalism that we propose to
overcome {\scshape Minx86} limitations, both to model and verify a hardware
architecture.
%
Its key concept is to focus of components \emph{interfaces}, where an interface
is a set of interdependent operations which are expected to produce a value.

\paragraph{Interface and Component}
%
A component is characterized primarily by the interface it exposes to the rest
of the system, and secondarily by its current state and the interfaces it uses
in order to operate.
%
A component receives requests to compute results of operations through its
interface, and sends operations requests to other components it is connected to
\emph{via} their interfaces and waits for their results.

\begin{example}[{\scshape Minx86} as a component-based system]
  Figure~\ref{fig:freespec:interfacedriven} pictures an alternative model to
  {\scshape Minx86}.
  %
  The software components interact with the core \emph{via} its instructions
  set.
  %
  When the core needs to read from or write to memory, it leverages its cache.
  %
  In case of cache miss or cache eviction, the cache interacts with the system
  memory through the memory controller, whose goal is to dispatch memory
  accesses between \emph{e.g.} \ac{dram} and the VGA controller.
  %
  In addition, the memory controller dispatches memory requests coming from
  other sources, for instance an I/O~MMU ---something that we have not taken
  into account in the proofs in Chapter~\ref{chapter:freespec}.
\end{example}

\paragraph{Abstract Specifications}
%
To enable compositional reasoning about component-based systems, we introduce
so-called abstract specifications which are characterized by requirements over
how the interface should be used and requirements over the interface operations
results.

\begin{figure}
  \begin{center}
    \begin{tikzpicture}
      % Mems
      % -- DRAM
      \node (M) {};%
      \node [inner sep=8pt, dashed, draw, left=3pt of M.center, text
      width=1.3cm, text badly centered] (DRAM) {DRAM};%
      \draw ([yshift=5pt, xshift=3pt]DRAM.north west) -- ([yshift=5pt,
      xshift=-3pt]DRAM.north east);%
      \node [left=4pt of DRAM.north west, yshift=3pt, text width=1cm] (Id)
      {$I_{\mathrm{DRAM}}$};%
      % -- VGA
      \node [inner sep=8pt, dashed, draw, right=3pt of M.center, text
      width=1.3cm, text badly centered] (VGA) {VGA};%
      \draw ([yshift=5pt, xshift=3pt]VGA.north west) -- ([yshift=5pt,
      xshift=-3pt]VGA.north east);%
      \node [right=4pt of VGA.north east, yshift=3pt, text width=1cm] (Iv)
      {$I_{\mathrm{VGA}}$};%

      % Memory Controller
      \node [inner sep=8pt, draw, above=30pt of M.center] (MC) {Memory
        Controller};%
      \draw ([yshift=5pt, xshift=3pt]MC.north west) -- ([yshift=5pt,
      xshift=-3pt]MC.north east);%
      \node [right=4pt of MC.north east, yshift=3pt] (Im) {$I_{\mathrm{MC}}$};%

      % CPU
      \node [inner sep=16pt, draw, dashed, above=30pt of MC.center] (CPU)
      {Processor};%

      % arrows
      \draw [-latex] (CPU.south) -- ([yshift=5pt]MC.north);%
      \draw [latex-] ([yshift=5pt]DRAM.north) |- (MC.south);%
      \draw [latex-] ([yshift=5pt]VGA.north) |- (MC.south);%
    \end{tikzpicture}
  \end{center}

  \caption{The memory controller in isolation}
  \label{fig:freespec:memc}
\end{figure}

\begin{example}[BIOS Isolation]
  We consider one more time the isolation of the \ac{bios} at runtime, thanks to
  the \ac{smm} and the SMRAM.

  The \texttt{SMRAMC} register, exposed by the memory controller, allows the
  \ac{bios} to configure the main access control mechanism which protects the
  content of the SMRAM from the rest of the software stack.
  %
  Using FreeSpec, we can model and verify this access control mechanism in
  isolation, by focusing on the memory controller alone.
  %
  This is achieved by abstracting away the rest of the hardware model, thanks to
  the interfaces exposed and used by the hardware component of interest, as
  pictured in Figure~\ref{fig:freespec:memc}.
  %
  We model the security policy enforced by the mechanism behind the
  \texttt{SMRAMC} register thanks to an abstract specification.
  %
  An abstract specification is a couple of requirements ---over the interface
  users, and over the interface results--- which translates as follows here:
  %
  \begin{itemize}
  \item We forbid unprivileged \IO targeting the SMRAM when the \texttt{SMRAMC}
    register is not correctly configured.
  \item We guarantee that a processor which read the content of the SMRAM while
    in \ac{smm} will get what is has previously written to \ac{smm} while in
    \ac{smm}.
  \end{itemize}
  %
  We can prove the memory controller is correct with respect to this abstract
  specification, meaning if the processor satisfy the requirements over users,
  then the results computed by the memory controller satisfy the requirements
  over results.

  In such a case, the memory controller works as expected, but this does not
  mean that the result alone is sufficient to conclude about the system as a
  whole.
  %
  We still have to prove the premise, \emph{i.e.} that the processor makes a
  correct use of the memory controller interface.
  %
  However, we do not need to use the model of the memory controller to that end,
  we only need to know that it will behave as specified by the abstract
  specification if the processor does too.

  We focus on modeling the processor, made in our example of two components: a
  core and a cache.
  %
  Similarly to what we achieved with the memory controller, we reason about the
  cache in isolation (as pictured with Figure~\ref{fig:freespec:cachec}).
  %
  We want to prove that
  %
  \begin{inparaenum}
  \item the cache makes a correct use of the memory controller interface, that
    is that each uses of the memory controller interface satisfy the appropriate
    requirements, and
  %
  \item it provides similar guarantee to the core.
  \end{inparaenum}

  We proceed by defining a second abstract specification, this time against the
  interface of the cache.
  %
  This additional abstract specification serves two purposes: it restricts how
  the core is allowed to use the cache, and by construction how the cache uses
  the memory controller, but it also formalizes the expectation of the core.

  In this second case, the requirements over the interface results are the same
  as what we already introduced for the memory controller.
  %
  Trying to prove a cache without SMRR can enforce them would uncover the SMRAM
  cache poisoning attack.
\end{example}

\begin{figure}
  \centering
  \begin{tikzpicture}
    % Memory Controller
    \node [inner sep=15pt, draw, dashed] (MC) {Memory Controller};%
    \draw ([yshift=5pt, xshift=3pt]MC.north west) -- ([yshift=5pt,
    xshift=-3pt]MC.north east);%
    \node [right=4pt of MC.north east, yshift=3pt, text width=0.5cm] (Im)
    {$I_{\mathrm{MC}}$};%
    \node [left=4pt of MC.north west, yshift=3pt, text width=0.5cm] (Im_shadow)
    {};%

    % Cache
    \node [inner sep=8pt, draw, above=20pt of MC] (Cache) {Cache};%
    \draw ([yshift=5pt, xshift=3pt]Cache.north west) -- ([yshift=5pt,
    xshift=-3pt]Cache.north east);%
    \node [right=4pt of Cache.north east, yshift=3pt, text width=0.5cm] (Ic)
    {$I_{\mathrm{Cache}}$};%
    \node [left=4pt of Cache.north west, yshift=3pt, text width=0.5cm]
    (Ic_shadow) {};%

    % CPU
    \node [inner sep=8pt, draw, above=20pt of Cache, dashed] (CPU) {Core};%

    % arrows
    \draw [-latex] (Cache.south) -- ([yshift=5pt]MC.north); \draw [-latex]
    (CPU.south) -- ([yshift=5pt]Cache.north);
  \end{tikzpicture}

  \caption{The cache in isolation}
  \label{fig:freespec:cachec}
\end{figure}

\subsection*{}

In this Section, we have discussed the limitations of {\scshape Minx86}, and the
strategies that we implemented to mitigate them.
%
This necessary assessment allowed us to propose an alternative formalism to both
model verify the x86 hardware architecture.
%
In the rest of this Chapter, we describe in depth this formalism.

\section{Modeling Programs with Effects}
% ==============================================================================
\label{sec:freespec:specifying}

The first objective of FreeSpec is to incrementally model a complex system, one
component at a time.
%
To do so, we use the key concepts of algebraic effects and effect handlers,
implemented with a variant of the Free monad called the Program monad as defined
in the \texttt{operational} package of Haskell\,\cite{operational}.

This section and the one afterwards proceed through a running example: a
minimalist memory controller, as depicted in Figure~\ref{fig:freespec:memc}.

% pictured in the Figure~\ref{fig:mch-running-example}.
% \begin{figure}
%   \centering \includestandalone[width=.5\textwidth]{running-example}
%
%   \caption{Idealised Memory Controller Hub}
%   \label{fig:mch-running-example}
% \end{figure}

\subsection{Interface of Effects}
% ------------------------------------------------------------------------------

Within a computing system, interconnected components communicate through
interfaces.
%
A component which exhibits an interface receives computational requests from
other components; it handles these requests by computing their results and
sending the latter back to the client component.
%
In FreeSpec, a computational request is modelled with an effect, that is a
symbolic value which describes the request and its potential result.

For $\I$ an interface, we denote by $\Interface{\I}{\mathcal{A}} \subseteq \I$
the subset of effects whose results belong to a set~$\mathcal{A}$.

\begin{example}[Memory Controller Interfaces]
  The VGA and the DRAM controllers exhibit a similar interface which allows for
  reading and writing into a memory region.
  %
  Their interfaces are denoted by $\I_{\mathrm{VGA}}$ and $\I_{\mathrm{DRAM}}$
  respectively.
  %
  Let $\mathpzc{Loc}$ be the set of memory locations and $\mathpzc{Val}$ the set
  of values stored inside the memory region.
  %
  We use the unit value \ac{unit} to model effects without results (similarly to
  the \texttt{void} keyword in an imperative language).
  %
  We define $\I_{\mathrm{DRAM}}$ (respectively $\I_{\mathrm{VGA}}$) with two
  constructors:
  %
  \[
    \begin{array}{rcl}
      \I_{\mathrm{DRAM}}
      & \triangleq
      & \func{Read}_{\mathrm{DRAM}} : \mathpzc{Loc} \rightarrow
        \Interface{\I_{\mathrm{DRAM}}}{\mathpzc{Val}} \\

      & |
      & \func{Write}_{\mathrm{DRAM}} : \mathpzc{Loc} \rightarrow \mathpzc{Val}
        \rightarrow \Interface{\I_{\mathrm{DRAM}}}{\{\ac{unit}\}}
    \end{array}
  \]

  Then,
  $\I_{\mathrm{DRAM}} =
  \Interface{\I_{\mathrm{DRAM}}}{\{\ac{unit}\}}\,\cup\,\Interface{\I_{\mathrm{DRAM}}}{\mathpzc{Val}}$,
  and
  $\func{Read}_{\mathrm{DRAM}}(l) \in
  \Interface{\I_{\mathrm{DRAM}}}{\mathpzc{Val}}$ is an effect that describes a
  memory access to read the value~$v \in \mathpzc{Val}$ stored at the
  location~$l \in \mathpzc{Loc}$.

  The memory controller interface is similar, but it distinguishes between
  privileged and unprivileged accesses.
  %
  It also provides one effect to lock the SMRAM protection mechanism, i.e. it
  enables the SMRAM isolation until the next hardware reset.
  %
  We define the set
  $\mathpzc{Priv}~\triangleq~\{\,\val{privileged}, \val{unprivileged}\,\}$ to
  distinguish between privileged memory accesses made by a processor in \ac{smm}
  and unprivileged accesses made the rest of the time.
  %
  The memory controller interface, denoted by $\I_{\mathrm{MCH}}$, is defined
  with three constructors:
  %
  \[
    \begin{array}{rcl}
      \I_{\mathrm{MCH}}
      & \triangleq
      & \func{Read}_{\mathrm{MCH}} : \mathpzc{Loc} \rightarrow \mathpzc{Priv}
        \rightarrow \Interface{\I_{\mathrm{MCH}}}{\mathpzc{Val}} \\

      & |
      & \func{Write}_{\mathrm{MCH}} : \mathpzc{Loc} \rightarrow \mathpzc{Val}
        \rightarrow \mathpzc{Priv} \rightarrow
        \Interface{\I_{\mathrm{MCH}}}{\{\ac{unit}\}} \\

      & |
      & \func{Lock} : \Interface{\I_{\mathrm{MCH}}}{\{\ac{unit}\}}
    \end{array}
  \]
\end{example}

\subsection{Operational Semantics for Effects}
% -----------------------------------------------------------------------------

An effect corresponds to a computational request made to an implementation of a
given interface.
%
To compute the result of the computational request, we define its
\emph{operational semantics}.
%
Ultimately, we will model a component as an operational semantics for all the
effects of its interface.
%
Since operational semantics are defined using a purely functional language, they
always compute the same result for a given effect, which is inconsistent with
the stateful aspect of hardware components.
%
Thus, an operational semantics produces not only a result, but also a new
operational semantics, which encapsulates the new state of the component.

\begin{definition}[Operational Semantics]
  We write $\Sigma_{\I}$ for the set of operational semantics for a given
  interface $\I$, defined co-inductively as
  %
  \[
    \Sigma_{\I} \triangleq \{\,\sigma\,|\,\sigma : \forall \mathcal{A},
    \Interface{\I}{\mathcal{A}} \rightarrow \mathcal{A} \times \Sigma_{\I} \,\}.
  \]
  %
  An operational semantics~$\sigma \in \Sigma_{\I}$ is a function which, given
  any effect of $\I$, produces both a result which belongs to the expected set
  and a new operational semantics to use afterwards.
\end{definition}

A component may use more than one interface.
%
For instance, the memory controller of our running example can access the system
memory and the memory shared by the VGA controller.
%
But an operational semantics is defined for only one interface.
%
In FreeSpec, we solve this issue by composing interfaces together to create new
ones.

\begin{definition}[Interfaces Composition]
  Let $\I$ and $\J$ be two interfaces. $\oplus$~is the interface composition
  operator, defined with two constructors:
  %
  \[
    \begin{array}{rcl}
      \I \oplus \J
      & \triangleq
      & \func{InL} : \forall \mathcal{A},
        \Interface{\I}{\mathcal{A}} \rightarrow
        \Interface{(\I \oplus \J)}{\mathcal{A}} \\

      & |
      & \func{InR} : \forall \mathcal{A}, \Interface{\J}{\mathcal{A}}
        \rightarrow \Interface{(\I \oplus \J)}{\mathcal{A}}
    \end{array}
  \]
\end{definition}

The resulting interface $\I \oplus \J$ contains the effects of both $\I$ and
$\J$, wrapped into either $\func{InL}$ or $\func{InR}$ constructors, defined to
preserve the effects results sets. \GH{A ce stage on ne comprend pas pourquoi on
  a 2 constructueurs, ni la partie "defined to preserve the effects results
  sets".Trop d'implicite, il faut détailler un peux}
%
% Notice that this usage of a tagged union allows for composing the same
% interface twice, so a component can use two components which exhibit the same
% interface.

\begin{example}[VGA and DRAM Composition]
  We consider $\I_{\mathrm{DRAM}} \oplus \I_{\mathrm{VGA}}$. Then,
  $\func{InL}(\func{Read}_{\mathrm{DRAM}}(l)) \in \Interface{(\I_{\mathrm{DRAM}}
    \oplus \I_{\mathrm{VGA}})}{\mathpzc{Val}}$ is an effect that describes a
  read access targeting the DRAM controller, whereas
  $\func{InR}(\func{Read}_{\mathrm{VGA}}(l)) \in \Interface{(\I_{\mathrm{DRAM}}
    \oplus \I_{\mathrm{VGA}})}{\{\ac{unit}\}}$ is an effect that describes a
  read access targeting the VGA controller. \GH{L'exemple devrait permettre
    d'insister}
\end{example}

Using $\oplus$, we can compose several interfaces together.
%
We then need another composition operator, this time for operational semantics.
%
We compose operational semantics together to construct a new operational
semantics for the composed interface.

\begin{definition}[Operational Semantics
  Composition] \label{def:freespec:semantics-composition} Let $\I$ and $\J$ be
  two interfaces, $\sigma_i \in \Sigma_{\I}$ and $\sigma_j \in \Sigma_{\J}$ be
  two operational semantics dedicated to these interfaces.
  %
  In this article, we use the $\lambda$-calculus abstraction notation for
  functions. \GH{est-ce vraiement indispensable? Il y a déjà beaucoup de notions
    assez diverse à maitriser pour comprendre ton document. Si on peut s'éviter
    celle là...}
  %
  $\otimes$~is the composition operator for operational semantics, defined as
  \[ \sigma_i \otimes \sigma_j \triangleq \lambda e. \left \{
      \begin{array}{lcl}
        (x, \sigma_i' \otimes \sigma_j) & \text{when} & e =
                                                        \func{InL}(e_i)
                                                        \text{ and }
                                                        \sigma_i(e_i)
                                                        = (x,
                                                        \sigma_i') \\
        (x, \sigma_i \otimes \sigma_j') & \text{when} & e =
                                                        \func{InR}(e_j)
                                                        \text{ and }
                                                        \sigma_j(e_j)
                                                        = (x, \sigma_j')
      \end{array}
    \right.
  \]
\end{definition}

The definition of $\otimes$ has an important impact over what can be specified
in FreeSpec.
%
% When $\sigma_i \otimes \sigma_j$ handles an effect of $\I$, only $\sigma_i$
% ``changes.''
%
Handling an effect of $\I$ (respectively $\J$) does not interfere \GH{plutôt que
  interfere, je préfererais "update" qui est plus proche de ce qui se passe.}
with $\sigma_j$ (respectively $\sigma_i$).
%
As a consequence, \emph{we cannot specify as-is a graph of components which
  contains a cycle or a diamond}. \GH{il faudrait s'attarder un peu plus là
  dessus et expliquer pourquoi a partir d'un exemple (le diamand, par
  exemple). Cela permettrait d'ailleurs d'expliquer un peu mieux la composition
  d'interface à travers un exemple}
%
This is the main limitation of FreeSpec, but its incidence is abated because
computing platforms are often designed as a hierarchical succession of layers.

\subsection{The Program Monad}
% -----------------------------------------------------------------------------

Modeling programs with side effects in purely functional languages such as
{\textsc Gallina} (the Coq specification language) or Haskell is usually
achieved thanks to monads\,\cite{hoareetal2001monad}.
%
FreeSpec leverages a variant of the Free monad called the Program
monad\,\cite{operational} to model programs with effects. Operational semantics
play the role of \texttt{operational}\,\cite{operational} interpreters.
%
We write $P_{\I}(\mathcal{A})$ for the set of programs with effects which
belongs to $\I$, modelled thanks to the Program monad, and whose result belongs
to a set $\mathcal{A}$.

\begin{definition}[Program Monad]
  The Program monad is defined with three constructors:
  %
  \[
    \begin{array}{rcl}
      P_{\I}(\mathcal{A})
      & \triangleq
      & \func{Pure} : \mathcal{A} \rightarrow P_{\I}(\mathcal{A}) \\

      & |
      & \func{Bind} : \forall \mathcal{B}, P_{\I}(\mathcal{B}) \rightarrow
        (\mathcal{B} \rightarrow P_{\I}(\mathcal{A})) \rightarrow
        P_{\I}(\mathcal{A}) \\

      & |
      & \func{Request} : \Interface{\I}{\mathcal{A}} \rightarrow
        P_{\I}(\mathcal{A})
    \end{array}
  \]
\end{definition}
%
These constructors allow for the construction of values which act similarly to
abstract syntax trees to model programs with effects.
%
On the one hand, $\func{Pure}$ and $\func{Request}$ are comparable to the leaves
of a syntax tree and model atomic computations; $\func{Pure}$ models local
computations, whereas $\func{Request}$ models deferring a computational request
to a handler and waiting for its result.
%
On the other hand, $\func{Bind}$ (usually written thanks to the infix operator
$\bind$) models the control flow of a program with effects, like the abstract
syntax tree nodes would.
%
It defines how the result of one computation determines the following ones.

\begin{example}[Copy]
  We define
  $\func{copy} : \mathpzc{Loc} \rightarrow \mathpzc{Loc} \rightarrow
  P_{\I_{\mathrm{DRAM}}}(\{\ac{unit}\})$ such that $\func{copy}(l, l')$ models a
  program with effects that returns no result, but copies the value $v$ stored
  at the memory location $l$ inside the memory location $l'$.
  %
  \[ \func{copy}(l, l') \triangleq
    \func{Request}(\func{Read}_{\mathrm{DRAM}}(l)) \bind \lambda
    v. \func{Request}(\func{Write}_{\mathrm{DRAM}}(l', v))
  \]
\end{example}

Given $l \in \mathpzc{Loc}$ and $l' \in \mathpzc{Loc}$, $\func{copy}(l, l')$
symbolically models a program with effects.
%
To assign an interpretation of this program, it must be completed with an
operational semantics which realizes the interface
$\mathcal{I}_{\mathrm{DRAM}}$.

\begin{definition}[Program With Effects
  Realization] \label{def:freespec:realisation} Let $\I$ be an interface,
  $\sigma \in \Sigma_{\I}$ an operational semantics for this interface and
  $\rho \in P_{\I}(\mathcal{A})$ a program with effects which belong to this
  interface.
  %
  $\sigma[\rho] \in \mathcal{A} \times \Sigma_{\I}$ denotes the realization of
  this program by $\sigma$, defined as:
  \[ \sigma[\rho] \triangleq \left\{
      \begin{array}{lcl} (x, \sigma) & \text{if} & \rho =
                                                   \func{Pure}(x) \\
        \sigma(e) & \text{if} & \rho =
                                \func{Request}(e) \\
        \sigma'[f(y)] & \text{if} & \rho =
                                    q \bind f\text{ and }(y, \sigma') = \sigma[q] \\
      \end{array}
    \right.
  \]
\end{definition}

\subsection{Components as Programs with Effects}
% -----------------------------------------------------------------------------

With the interfaces, their operational semantics, the $\oplus$ and $\otimes$
operators to compose them and the Program monad to model programs with effects
which belong to these interfaces, we now have all we need to model a given
component which exposes an interface $\I$ and uses another interface $\J$.
%
We proceed with the following steps: modeling the component in terms of programs
with effects, then deriving one operational semantics for $\I$ from these
programs, assuming provided an operational semantics for $\J$.

The behaviour of a component is often determined by a local, mutable state.
%
When it computes the result of a computational request, not only a component may
read its current state; but it can also modify it, for instance to handle the
next computational request differently.
%
This means we have to model the state of a component with a set $\mathcal{S}$ of
symbolic state representations.
%
We map the current state of the component and effects of $\I$ to a program with
effects of $\J$.
%
These programs must compute the effect result and the new state of the
component.

\begin{definition}[Component] \label{def:freespec:component-model} Let $\I$ be
  the interface exhibited by a component and $\J$ the interface it uses.
  %
  Let $\mathcal{S}$ be the set of its states.
  %
  The component $C$, defined in terms of programs with effects of $\J$, is of
  the form
  \[ \forall \mathcal{A}, \Interface{\I}{\mathcal{A}} \rightarrow \mathcal{S}
    \rightarrow P_{\J}(\mathcal{A} \times \mathcal{S}) \]
\end{definition}

Hence, $C$ specifies how the component handles computational requests, both in
terms of computation results and state updates.

\begin{example}[Minimal Memory Controller Model]
  \label{ex:mch-specs}

  Let $C_{\mathrm{MCH}}$ be the memory controller defined in terms of programs
  with effects of $\I_{\mathrm{DRAM}} \oplus \I_{\mathrm{VGA}}$, then
  $C_{\mathrm{MCH}}$ is of the form
  \[
    \forall \mathcal{A}, \Interface{\I_{\mathrm{MCH}}}{\mathcal{A}} \rightarrow
    \mathcal{S}_{\mathrm{MCH}} \rightarrow P_{\I_{\mathrm{DRAM}} \oplus
      \I_{\mathrm{VGA}}}(\mathcal{A} \times \mathcal{S}_{\mathrm{MCH}})
  \] where $\mathcal{S}_{\mathrm{MCH}} \triangleq \{ \val{on}, \val{off} \}$
  means the SMRAM protection is either activated ($\val{on}$) or deactivated
  ($\val{off}$).

  One the one hand, the \func{Lock} effect will activate the isolation mechanism
  of the memory controller, setting its state to $\val{on}$.
  %
  On the other hand, the effects constructed with $\func{Read}_{\mathrm{MCH}}$
  and $\func{Write}_{\mathrm{MCH}}$ will use the current state of the memory
  controller, the privileged parameter of the effect and the memory location to
  lookup to determine if it uses the DRAM or the VGA controller.
  %
  By default, it fetches the memory of the DRAM controller, except if the
  isolation mechanism is activated, the access is unprivileged and the targeted
  memory location belongs to the SMRAM.
  %
  In such a case, it reroutes access to the VGA controller.
\end{example}

A component $C$ defined in terms of programs with effects cannot be used as-is
to compute the result of a given effect.
%
To do that, we need to derive an operational semantics for~$\I$ from $C$.

\begin{definition}[Deriving Operational
  Semantics] \label{def:freespec:derivation} Let $C$ be a component which
  exhibits an interface $\I$, uses an interface~$\J$ and whose states belong to
  $\mathcal{S}$.
  %
  Let $s \in \mathcal{S}$ be the current state of the component and
  $\sigma_j \in \Sigma_{\J}$ be an operational semantics for~$\J$.
  %
  We can derive an operational semantics for $\mathcal{I}$, denoted by
  $\langle C, s, \sigma_j \rangle$, defined as
  \[ \langle C, s, \sigma_j \rangle \triangleq \lambda i. (x, \langle C, s',
    \sigma_j' \rangle) \text{ where } ((x, s'), \sigma_j') = \sigma_j[C (i, s)]
  \]
\end{definition}

% On the one hand, components are defined in terms of programs with effects,
% meaning each component can be modelled independently from the rest of the
% system.
%%
% On the other hand, FreeSpec introduces the mechanism of derivation to
% aggregate these models together.
%
The resulting operational semantics models a system made of interconnected
components, and can then be used to derive another component model into an
operational semantics which models a larger system.
%
For instance, we can proceed with the following steps to comprehensively model
our running example: (i) defining the operational semantics for the DRAM and VGA
controllers; (ii) using these operational semantics to derive an operational
semantics from $C_{\mathrm{MCH}}$.
%
The resulting operational semantics can take part in the derivation of a cache
defined in terms of programs with effects of $\I_{\mathrm{MCH}}$, to model a
larger part of the system pictured in the
Figure~\ref{fig:freespec:interfacedriven}.

\section{Modular Verification of Programs with Effects}
% =============================================================================
\label{sec:freespec:verifying}

The first objective of FreeSpec is to provide the required tools to model each
component of a system independently, and to compose these components to model
the whole system.
%
Its second objective is to verify that the composition of several components
satisfies a set of properties.
%
To achieve that, we introduce the so-called abstract specifications, which
allows for specifying, for each interface, expected properties for the effect
results, independently of any underlying handler.
%
Abstract specifications can be used to emphasize the responsibility of each
component of a system regarding the enforcement of a given security policy.
%
Verifying a component is done against abstract specifications of the interfaces
it directly uses, even if it relies on a security property enforced by a deeper
component in the components graph.
%
In this case, we have to verify that every single component which separate them
preserve this property.
%
This procedure can help to prevent or uncover architectural attacks.

In this section, we proceed with our running example by verifying that the
memory controller correctly isolates the SMRAM.
%
In order to do that, we define an abstract specification which states that
privileged reads targeting the SMRAM returns the value which has previously been
stored by a privileged write. It models the SMRAM isolation: unprivileged writes
cannot tamper with the content of the SMRAM, as read by a privileged CPU.

\subsection{Abstract Specification}
% -----------------------------------------------------------------------------

In FreeSpec, an abstract specification dedicated to an interface $\I$ is
twofold.
%
It defines a precondition over the effects that a caller must satisfy; and, in
return, it specifies a postcondition over the effects results that an
operational semantics must enforce.
%
Since both the precondition and the postcondition may vary in time, we
parameterize an abstraction specification with an abstract state and a step
function to update this state after each effect realization.

\begin{definition}[Abstract Specification] \label{def:freespec:abstract-specs}
  We write $A$ for an abstract specification dedicated to an interface $\I$,
  defined as a tuple
  $\langle \Omega, \func{step}, \func{pre}, \func{post} \rangle$ where
  \begin{itemize}
  \item $\Omega$ is a set of abstract states
  \item
    $\func{step} : \forall \mathcal{A}, \Interface{\I}{\mathcal{A}} \rightarrow
    \mathcal{A} \rightarrow \Omega \rightarrow \Omega$ is a transition function
    for the abstract state.
  \item $\func{pre} \subseteq \I \times \Omega$ is the precondition over
    effects, such that $(e, \omega) \in \func{pre}$ if and only if the effect
    $e$ satisfies the precondition parameterized with the abstract state
    $\omega$ (denoted by $\func{pre}(e, \omega)$).
  \item
    $\func{post} \subseteq \bigcup_{\mathcal{A}} (\Interface{\I}{\mathcal{A}}
    \times \mathcal{A} \times \Omega)$ is the postcondition over effects
    results, such that $(e, x, \omega) \in \func{post}$ if and only if the
    results $x$ computed for the effects $e$ satisfies the postcondition
    parameterized with the abstract state $\omega$ (denoted by
    $\func{post}(e, x, \omega)$).
  \end{itemize}
\end{definition}

By defining an abstract specification of an interface $\I$, it becomes possible
to abstract away the effect handler, i.e. the underlying component.
%
As a consequence, reasoning about a program with effects can be achieved without
the need to look at the effect handlers.
%
An abstract specification is dedicated to one verification problem (in our
context, one security property), and it is possible to define as many
abstraction specifications as required.

We write
$\func{run}_{\func{step}} : \forall \mathcal{A}, \Sigma_{\I} \rightarrow
P_{\I}(\mathcal{A}) \rightarrow \Omega \rightarrow (\mathcal{A} \times
\Sigma_{\I} \times \Omega)$ for the function which, in addition to realize a
program with effects, updates an abstract state after each effect.
%
Using $\func{run}_{\func{step}}$, we can determine both the precondition over
effects and the postcondition over effects results while an operational
semantics realizes a program with effects.

\begin{example}[Memory Controller Abstract
  Specification] \label{ex:mch-abs-specs} Let $A_{\mathrm{MCH}}$ be the abstract
  specification such that
  $A_{\mathrm{MCH}} = \langle \Omega_{\mathrm{MCH}}, \func{step}_{\mathrm{MCH}},
  \func{pre}_{\mathrm{MCH}}, \func{post}_{\mathrm{MCH}} \rangle$.
  %
  $A_{\mathrm{MCH}}$ models the following property: ``\emph{privileged reads
    targeting the SMRAM return the value which has been previously stored by a
    privileged write}’’:
  \begin{itemize}
  \item Let $\mathpzc{Smram} \subseteq \mathpzc{Loc}$ be the set of memory
    locations which belong to the SMRAM.  We define
    $\Omega_{\mathrm{MCH}} \triangleq \mathpzc{Smram} \rightarrow
    \mathpzc{Val}$, such that $\omega \in \Omega_{\mathrm{MCH}}$ models a view
    of the SMRAM as exposed by the MCH for privileged reads.
  \item We define $\func{step}_{\mathrm{MCH}}$ which updates the view of the MCH
    (modelled as a function) after each privileged write access targeting any
    SMRAM location $l$, that is
    \[ \func{step}_{\mathrm{MCH}}(e, x, \omega) \triangleq \left\{
        \begin{array}{l}
          \lambda l'.  \text{ (if } l = l' \text{ then } v \text{ else } \omega(l')) \\
          \qquad\ \ \text{ if } e = \func{Write}_{\mathrm{MCH}}(l, v, \val{privileged})
          \text{ and } l \in \mathpzc{Smram} \\
          \omega \qquad \text{ otherwise}
        \end{array}
      \right.
    \]
  \item There is no precondition to the use of the memory controller effects, so
    \[ \forall e \in \I,\forall \omega \in \Omega_{\mathrm{MCH}},
      \func{pre}_{\mathrm{MCH}}(e, \omega) \]
  \item The postcondition enforces that the result $x$ of a privileged read
    targeting the SMRAM ($\func{Read}(l, \val{privileged})$) has to match the
    value stored in $A_{\mathrm{MCH}}$ abstract state, i.e. the expected content
    for this memory location $\omega(l)$.
    \[ \func{post}_{\mathrm{MCH}}(e, x, \omega) \triangleq \forall l \in
      \mathpzc{Loc}, e = \func{Read}_{\mathrm{MCH}}(l, \val{privileged}) \wedge
      l \in \mathpzc{Smram} \Rightarrow x = \omega(l)
    \]
  \end{itemize}
\end{example}

% With an abstract specification
% $\langle \Omega, \func{step}, \func{pre}, \func{post} \rangle$, we can
% transparently update a given abstract state while realizing programs.

\subsection{Compliance and Correctness}
% -----------------------------------------------------------------------------

The verification of a component~$C$, which exhibits $\I$ and uses $\J$, consists
in proving we can derive an operational semantics $\sigma_i$ for $\I$ from an
operational semantics $\sigma_j$ for $\J$.
%
This semantics $\sigma_i$ enforces the postcondition of an abstract
specification $A_{\I}$ dedicated to $\I$ (compliance).
%
As $C$ is defined in terms of programs with effects of $\J$, the latter needs to
make a licit usage of $\J$ with respect to an abstract specification $A_{\J}$
dedicated to $\J$ (correctness).

First, $\sigma_i$ complies with $A_{\I}$ if, (1) given any effect which
satisfies $A_{\I}$ precondition, $\sigma_i$ produces a result which satisfies
its postcondition, and if (2) the new operational semantics $\sigma_i'$ also
complies with $A_{\I}$.
%
The precondition and the postcondition are parameterized by an abstract state,
so is the compliance property.

\begin{definition}[Operational Semantics
  Compliance] \label{def:freespec:compliance} Let $A$ be an abstract
  specification for an interface $\I$, defined as
  $\langle \Omega, \func{step}, \func{pre}, \func{post} \rangle$,
  $\omega \in \Omega$, then $\sigma \in \Sigma_{\I}$ complies with $A$ in
  accordance with $\omega$ (denoted by $\sigma \models A[\omega]$) iff.
  \[ \forall e \in \I, \func{pre}(e, \omega) \Rightarrow \func{post}(e, x,
    \omega) \wedge \sigma' \models A[\func{step}(e, x, \omega)] \text{ where
    }(x, \sigma') = \sigma(e)
  \]
\end{definition}

Secondly, programs with effects of $C$ make a licit usage of an operational
semantics $\sigma_j \in \Sigma_{\J}$ which complies with $A_{\J}$ if they only
use effects which satisfy $A_{\J}$ precondition.
%
As for the compliance property, correctness is parameterized with an abstract
state.

\begin{definition}[Program With Effects
  Correctness] \label{def:freespec:correctness} Let $A$ be an abstract
  specification for an interface $\I$, defined as
  $\langle \Omega, \func{step}, \func{pre}, \func{post} \rangle$,
  $\omega \in \Omega$, and $\rho \in P_{\I}(\mathcal{A})$, then $\rho$ is
  correct with respect to $A$ in accordance with $\omega$ (denoted by
  $A[\omega] \modelssym \rho$), iff.
  \[
    A[\omega] \mathrel{\reflectbox{$\models$}} \rho \triangleq \left\{
      \begin{array}{lcl}
        \text{True} & \text{ if} & \rho = \func{Pure}(x) \\
        \func{pre}(e, \omega) & \text{ if} & \rho = \func{Request}(e) \\
        \forall \sigma \in \Sigma_{\I} \text{ such that } \sigma \models
        A[\omega], & & \\
        \qquad A[\omega] \modelssym q \wedge A[\omega'] \modelssym f(x) & \text{
                                                                          if} & \rho = q \bind f \\
        \text{where }(x, \_, \omega') =
        \func{run}_{\func{step}_{\J}}(\sigma, q, \omega) & \\
      \end{array}
    \right.
  \]
  % \guillaumerk{franchement, le symbole \protect\reflectbox{$\models$} est
  % vraiment trop proche de $\models$. Je comprends l'idée mais c'est source de
  % confusion. Je choisirai un symbol bien discinct.}
\end{definition}

Every local computation ($\func{Pure}$) is correct with respect to $A$ in
accordance with~$\omega$.
%
A computation which uses an effect $e \in \I$ ($\func{Request}$) is correct with
respect to $A$ in accordance with~$\omega$ if and only if $e$ satisfies the
precondition of $A$ for the abstract state $\omega$.
%
Finally, the chaining of two programs with effects ($\func{Bind}$) is correct
with $A$ in accordance with~$\omega$ if the first program is correct with $A$ in
accordance with~$\omega$, and the second program is correct in accordance with
the abstract state reached after the realization of the first program.

Properties, inferred from an abstract specification, of a correct program with
effects only hold if it is realized by a compliant operational semantics.
%
Besides, we prove that correct programs preserve operational semantics
compliance.

\begin{theorem}[Compliance Preservation]
  Let $A$ be an abstract specification dedicated to an interface $\I$, then
  $\sigma$ a compliant operational semantics for $\I$ produces a compliant
  operational semantics $\sigma'$ when it realizes a correct program $\rho$,
  that is
  \[
    \sigma \models A[\omega] \wedge A[\omega] \modelssym \rho \Rightarrow
    \sigma' \models A[\omega'] \text{ where }\func{run}_{\func{step}}(\sigma,
    \rho, \omega) = (x, \sigma', \omega')
  \]
\end{theorem}

As for interfaces (with $\oplus$) and operational semantics (with $\otimes$), we
have also defined an abstract specification composition operator $\odot$.
%
We do not detail its definition in this article, but it has the significant
property to allow for reasoning about the composition of interfaces and
composition of operational semantics.

\begin{theorem}[Congruent Composition]
  Let $\I$ (respectively $\J$) be an interface.
  %
  Let $A_{\I}$ (respectively $A_{\J}$) be an abstract specification and
  $\sigma_i \in \Sigma_{\I}$ (respectively $\sigma_j \in \Sigma_{\J}$) be an
  operational semantics for this interface.
  \[ \sigma_i \models A_{\I}[\omega_i] \wedge \sigma_j \models A_{\J}[\omega_j]
    \Rightarrow \sigma_i \otimes \sigma_j \models (A_{\I} \odot
    A_{\J})[\omega_i, \omega_j]
  \]
\end{theorem}

% \begin{theorem}[Congruent Lifting]
%   Let $\I$ (respectively $\J$) be an interface. Let $A_I$ (respectively $A_J$)
%   be an abstract specification and $\rho_i \in P_{\I}(\mathcal{A})$
%   (respectively $\rho_j \in P_{\J}(\mathcal{A})$) be an effectful computation
%   which uses this interface.
%   \[ A_I[\omega_i] \modelssym \rho_i \Rightarrow A_I \odot A_J [\omega_i,
%     \omega_j] \modelssym \func{liftl}(\rho_i)
%   \]
%   \[ A_J[\omega_j] \modelssym \rho_j \Rightarrow A_I \odot A_J [\omega_i,
%     \omega_j] \modelssym \func{liftr}(\rho_j)
%   \]
% \end{theorem}

With the Compliance Preservation, we know that as long as we follow the abstract
specification precondition related to the effects we use, compliant operational
semantics keep enforcing the postcondition.
%
With the Compliance Preservation and Congruent Composition, we know we can
reason locally, that is component by component.

\subsection{Proofs Techniques to Show Compliance For Components}
% -----------------------------------------------------------------------------

We have dived into the mechanisms which allow for composing together compliant
operational semantics, but little has been said about how to prove the
compliance property to begin with.
%
In a typical FreeSpec use case, operational semantics are not built as-is, but
rather derived from a component model
(Definition~\ref{def:freespec:derivation}).
%
How to prove the resulting operational semantics complies with an abstract
specification depends on how the component is connected to the rest of the
system.
%
We have already discussed the consequences of the operational semantics
composition operator $\otimes$
(Definition~\ref{def:freespec:semantics-composition}).
%
Notably, a graph of components which contains a cycle, a diamond or a forward
edge cannot be easily modelled and verified in FreeSpec.
%
In its current state, FreeSpec provides some theorems to verify the properties
of a component model in terms of an abstract specification, depending on the
composition pattern.

\paragraph{Predicate of Synchronization.}
%
The most favorable scenario consists of one component which uses many
components, and is only used by one other component.
%
Let $\I$ and $\J$ be two interfaces and let $C$, a component with a set of
possible states $\mathcal{S}$, which exhibits $\I$ and uses $\J$.
%
Let $A_{\I}$ be an abstract specification dedicated to $\I$.
%
Deriving an operational semantics from $C$ which complies with $A_{\I}$ in
accordance with $\omega_i \in \Omega_I$ requires to show the existence of
$s \in \mathcal{S} \text{ and }\sigma_j \in \Sigma_{\J}$ such that
\[ \langle C, s, \sigma_j \rangle \models A_{\I}[\omega_i]. \]
%
However, proving this statement would not be very satisfying, as it ties our
verification results to one specific operational semantics $\sigma_j$, and by
extension one specific component.
%
As a consequence, we define an abstract specification $A_{\J}$ to generalize our
statement and abstracting away $\sigma_j$.
%
We now need to prove it exists $\omega_j \in \Omega_{\J}$ such that given an
operational semantics $\sigma_j$ which complies with $A_{\J}$ in accordance with
$\omega_j$, the operational semantics derived from $C$, $s$ and $\sigma_j$
complies with $A_{\I}$ in accordance with $\omega_i$, that is
\[ \forall \sigma_j \in \Sigma_{\J}\text{, }\sigma_j \models A_{\J}[\omega_j]
  \Rightarrow \langle C, s, \sigma_j \rangle \models A_{\I}[\omega_i]
\]

The combinatorial explosion of cases introduced by $\omega_i$, $s$ and
$\omega_j$, modified as the component handles effects, makes inductive reasoning
challenging.
%
The FreeSpec framework provides a useful theorem to address these challenges,
which leverages a so-called predicate of synchronization.
%
The latter is defined by the user on a case-by-case basis, to act as an
invariant for the induction, and a sufficient condition to enforce compliance.

\begin{theorem}[Derivation Compliance] \label{theorem:der-compliance} Let
  $\func{sync}$, a relation between abstract states of $\Omega_{\I}$ and
  $\Omega_\J$ and concrete states of $\mathcal{S}$, be a predicate of
  synchronization.
  %
  Then, it is expected that, $\forall \omega_i \in \Omega_{\I}$,
  $s \in \mathcal{S}$ and $\omega_j \in \Omega_{\J}$ such that
  $\func{sync}(\omega_i, s, \omega_j)$ holds, then
  $\forall \sigma_j \in \Sigma_{\J}$ such that
  $\sigma_j \models A_{\J}[\omega_j]$ and $\forall e \in \I$ such that
  $\func{pre}_{\I}(e, \omega_i)$,
  \begin{enumerate}
  \item $C$ preserves the synchronization of states, that is
    $\func{sync}(\omega_i', s', \omega_j')$
  \item $C$ is defined in terms of programs with effects which are correct with
    respect to $A_{\J}$ in accordance with $\omega_j$, that is
    $A_{\J}[\omega_j] \modelssym C(e, s)$
  \item $C$ computes a result for $e$ which satisfies $A_{\I}$ postcondition,
    that is $\func{post}_{\I}(e, x, \omega_i)$
  \end{enumerate}
  where
  $((x, s'), \sigma_j', \omega_j') = \func{run}_{\func{step}_{\J}}(\sigma_j,
  C(e, s), \omega_j)$ and $\omega_i' = \func{step}_{\I}(e, x, \omega_i)$.

  Should these three properties be verified, then we show that
  \[ \func{sync}(\omega_i, s, \omega_j) \wedge \sigma_j \models A_{\J}[\omega_j]
    \Rightarrow \langle C, s, \sigma_j \rangle \models A_{\I}[\omega_i].
  \]
\end{theorem}

\begin{example}[Memory Controller Compliance]
  We want to prove we can derive an operational semantics from
  $C_{\mathrm{MCH}}$ (Example~\ref{ex:mch-specs}) which complies with
  $A_{\mathrm{MCH}}$ (Example~\ref{ex:mch-abs-specs}).

  We define
  $A_{\mathrm{DRAM}} \triangleq \langle \Omega_{\mathrm{DRAM}},
  \func{step}_{\mathrm{DRAM}}, \func{pre}_{\mathrm{DRAM}},
  \func{post}_{\mathrm{DRAM}} \rangle$ an abstract specification dedicated to
  $\I_{\mathrm{DRAM}}$ to express the following property: ``\emph{a read access
    to a memory location which belongs to the SMRAM return the value which have
    been previously written at this memory location}.'' In particular,
  $\Omega_{\mathrm{DRAM}} = \Omega_{\mathrm{MCH}}$, i.e. they are two views of
  the SMRAM, as exposed by the DRAM controller or by the memory controller.
  %
  In this context, the behaviour of VGA is not relevant. Let $\top$ be the
  abstract specification which has no state and such that its precondition and
  postcondition are always satisfied (meaning every operational semantics always
  complies with it).
  %
  Therefore, the abstract specifications dedicated to the interface used by
  $C_{\mathrm{MCH}}$, that is $\I_{\mathrm{DRAM}} \oplus \I_{\mathrm{VGA}}$, is
  $A_{\mathrm{DRAM}} \odot \top$ whose abstract state is
  $\Omega_{\mathrm{DRAM}}$.

  We define the predicate of synchronization $\func{sync}_{\mathrm{MCH}}$ such
  that
  \[ \func{sync}_{\mathrm{MCH}}(\omega_i, s, \omega_j) \triangleq s = \val{on}
    \wedge \forall l \in \mathpzc{Smram}, \omega_i(l) = \omega_j(l)
  \] Hence, we start our reasoning from a situation where the SMRAM isolation is
  already activated and the states of the two abstract specifications are the
  same, meaning the two views of the SMRAM (as stored in the DRAM, and as
  exposed by the memory controller) coincide.
  %
  We prove $\func{sync}_{\mathrm{MCH}}$ satisfies the three premises of the
  Theorem~\ref{theorem:der-compliance}. We conclude we can derive an operational
  semantics from $C_{\mathrm{MCH}}$ which complies with $A_{\mathrm{MCH}}$.
\end{example}

\paragraph{Predicate of Non-Interference.}
%
Another common composition pattern consists of a component which is used by more
than one other component.
%
FreeSpec provides a theorem which allows for extending the result obtained with
the Theorem~\ref{theorem:der-compliance}, in the specific case where concurrent
accesses do not lead to any abstract state update, and always satisfy the
requirements over effects.
%
This represents an important constraint, but matches realistic use cases.
%
In particular, when hardware components interfaces are very large, two
components are likely to use different classes of effects that do not interfere
with each others.

\begin{definition}[Predicate of Non-Interference]
  Let $\I$ be an interface and
  $A \triangleq \langle \Omega, \func{step}, \mathbb{P}, \mathbb{Q} \rangle$ be
  an abstract specification dedicated to $\I$. Let
  $\func{pnf} : \I \rightarrow \ac{prop}$ be a subset of effects. $\func{pnf}$
  is said to be a predicate of non-interference of $A$ (denoted
  $A \| \func{pnf}$) if and only if \[
    \begin{array}{l}
      \forall \mathcal{A}\text{, } \omega \in \Omega\text{, } i \in
      \Interface{\I}{\mathcal{A}}\text{, }x \in \mathcal{A}\text{, } \\ \qquad
      (\func{pnf}(i) \Rightarrow \mathbb{P}(i, \omega)) \wedge (\func{pnf}(i)
      \wedge \mathbb{Q}(i, x, \omega) \Rightarrow \omega = \func{step}(i, x,
      \omega))
    \end{array}
  \]
\end{definition}

In a similar manner to the predicate of synchronization, FreeSpec provides a
theorem to help and guide the verification work of its users.

\begin{theorem}[Non-Interference and Concurrency]
  Let $\sigma \in \Sigma_{\I}$ be an operational semantics dedicated to
  \( \mathcal{I}\).
  %
  Let \( \func{pnf} : \I \rightarrow \ac{prop} \) be a subset of effects. Let
  \( \sigma\!\!\downarrow\!\!\func{pnf} \) be the operational semantics built
  upon \( \sigma \) which executes arbitrary sequences of effects satisfying
  \func{pnf} between two effects.
  %
  We prove that
  \[
    A \| \func{pnf} \wedge \sigma \models A[\omega] \Rightarrow
    \sigma\!\!\downarrow\!\!\func{pnf} \models A[\omega]
  \]
\end{theorem}

In other words, a second component which only uses the effects that satisfies
$\func{pnf}$ can use the interface concurrently to a component proved to be
correct with respect to \( A \).

\begin{example}[Memory Controller and IOMMU]
  As pictured in Figure\,\ref{fig:freespec:interfacedriven}, the memory
  controller not only arbitrates the memory accesses of the CPU, but also to
  other hardware components (mostly PCI and PCIe devices).
  %
  One possible predicate of non-interference for $A_{\mathrm{MCH}}$ is to deny
  the IOMMU the possibility to perform privileged write, so that only the main
  CPU could do it, that is
  %
  \[
    \func{pnf}_{\mathrm{IOMMU}}(e) \triangleq \forall l \in \mathpzc{Loc}, v \in
    \times \mathpzc{Val}, e \neq \func{Write}_{\mathrm{MCH}}(l, v,
    \texttt{privileged})
  \]
  %
  By definition of \( A_{\mathrm{MCH}} \), and more precisely according to its
  transition function, only privileged write accesses update its abstract state.
  %
  Therefore, we prove
  %
  \[
    \forall \mathcal{A}, \omega \in \Omega_{\mathrm{MCH}}, e \in
    \I|_{\mathrm{\mathcal{A}}}, x \in \mathcal{A},
    \func{pnf}_{\mathrm{IOMMU}}(e) \Rightarrow
    \func{step}_{\mathrm{MCH}}(\omega, e, x, \omega) = \omega
  \]
  %
  Besides, the precondition \( \func{pre}_{\mathrm{MCH}} \) always holds true.

  As a consequence, \( A_{\mathrm{MCH}} \| \func{pnf}_{\mathrm{IOMMU}} \), that
  is \( \func{pnf}_{\mathrm{IOMMU}} \) is a predicate of non-interference of \(
  A_{\mathrm{MCH}} \).
\end{example}

\section{Conclusion}
% =============================================================================
\label{sec:freespec:scale}

For two sections, we have introduced the FreeSpec key definitions and theorems
so that we could model a minimal memory controller component and verify its
properties in the presence of a well-behaving DRAM controller.
%
This example has been driven by a real mechanism commonly found inside x86-based
computing platforms.
%
We now discuss how FreeSpec can be leveraged to model and verify larger systems.
% and limitations we anticipate.

The typical workflow of FreeSpec can be summarized as follows: specifying the
interfaces of a system; modeling the components of the system in terms of
programs with effects of these interfaces; identifying the abstract
specifications which express the requirements over each interface; verifying
each component in terms of compliance with these abstract specifications.

Independent groups of people can use FreeSpec to modularly model and verify a
system, as long as they agree on the interfaces and abstract specifications.
%
If, during the verification process, one group finds out a given interface or
abstract specification needs to be updated, the required modifications may
impact its neighbors.
%
For instance, modeling a x86-based computing system, as pictured in
Figure~\ref{fig:freespec:interfacedriven}, using FreeSpec requires to take into
account the cache, and to verify it complies with an abstract specification
similar to the one defined in Example~\ref{ex:mch-abs-specs}.
%
Thus, FreeSpec could have helped uncover the SMRAM cache poisoning attack
previously mentioned\,\cite{wojtczuk2009smram,duflot2009smram}, and other
similar architectural attacks.

The abstract specifications are defined in terms of interfaces, \emph{i.e.}
independently from components.
%
It has two advantages.
%
First, for a given verification problem modelled with a set of abstract
specifications, two components which exhibit the same interface can be proven to
comply with the same abstract specification.
%
In such a case, we can freely interchange these components, and the verification
results remain true.
%
This is useful to consider the challenge posed by components versioning, i.e. a
new version of a component brings new features which could be leveraged by an
attacker.
%
Then, it is possible to verify a given component in terms of several abstract
specifications.
%
This means we can independently conduct several verification works against the
same component.
