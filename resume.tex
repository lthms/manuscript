\chapter{Résumé de la thèse}

\begin{otherlanguage}{french}
  Dans le cadre de cette thèse, nous nous intéressons à une classe particulière
  de mécanismes d’application de politiques de sécurité qui consistent en la
  configuration, par un ou plusieurs logiciels de confiance, de la plate-forme
  matérielle afin de contraindre l’exécution du reste de la pile logicielle à
  respecter une politique de sécurité donnée.
  %
  Nous qualifierons par la suite de mécanisme HSE (de l’anglais
  \emph{Hardware-based Security Enforcement mechanisms}) les instances de cette
  classe.
  %
  L’utilisation par le système d’exploitation des mécanismes de pagination pour
  isoler chaque application est sûrement l’exemple le plus courant de la mise en
  pratique d’un mécanisme HSE.

  \subsection*{Contexte}

  Le contournement d’une politique de sécurité normalement assurée par le biais
  d’un mécanisme HSE peut s’expliquer par une erreur dans sa mise en œuvre aussi
  bien dans l’un des logiciels de confiance que dans les mécanisme matériels sur
  lesquels il se repose.
  %
  Dans le cadre de cette thèse, nous nous somme intéressés à ce second cas, et
  plus spécifiquement encore au problème des erreurs affectant les
  spécifications de la plate-forme.
  %
  Cette dernière est composée de plusieurs dizaines de composants interagissant
  ensemble; la complexité résultante de ces interactions rend en pratique
  difficile la conception d’un mécanisme à visée sécuritaire.
  %
  Pour chaque nouvelle fonctionnalité que le concepteur de la plate-forme désire
  ajouter, il doit la mettre en perspective des mécanismes déjà présents, pour
  s’assurer
  %
  \begin{inparaenum}[(1)]
  \item qu’elle n’interfère pas avec les mécanismes HSE existants et
  %
  \item qu’elle n’est pas contournable par le biais d’une fonctionnalité
    antérieure.
  \end{inparaenum}
  %
  Un exemple extrême de ces risques est l’attaque \emph{\texttt{SENTER} Sandman}
  présentée en 2015 par Xeno Kovah \emph{et al.}\,\cite{kovah2015senter}.
  %
  Les auteurs ont montré qu’il était possible de modifier le contenu de la
  mémoire flash d’un ordinateur en utilisant une extension de l’architecture x86
  nommée Intel TXT\,\cite{intel2015txt}.
  %
  Ils ont en effet remarqué que l’instruction \texttt{SENTER} permettait
  ---~dans sa première version~--- de désactiver une composante essentielle du
  mécanisme de protection en intégrité de la mémoire flash.

  La multiplication des chemins d’attaque potentiels liée au nombre grandissant
  des composants constitue une menace clairement identifiée dans la
  littérature\,\cite{wing2003compositionalattack}.
  %
  Dans le cas particulier des mécanismes HSE, les vulnérabilités successives
  affectant l’architecture
  x86\,\cite{duflot2009smram,wojtczuk2009smram,domas2015sinkhole,kallenberg2015racecondition,kovah2015senter}
  ont été caractérisée par une sévérité très importante, car les-dits mécanismes
  visaient à assurer l’isolation de la couche la plus basse ---~et, par voie de
  conséquence, la plus privilégiée~--- de la pile logicielle.

  \subsection*{Objectifs}

  Dans cette thèse, nous avons cherché à proposer une approche rigoureuse pour
  spécifier et vérifier, par le biais de méthodes formelles, des mécanismes HSE.
  %
  Notre hypothèse de départ est qu’une telle approche bénéficierait aux à la
  fois aux concepteurs des plate-formes matérielles et aux développeurs de
  logiciels.
  %
  Les premiers pourraient vérifier que leurs mécanismes matériels permettent
  effectivement l’application des politiques de sécurité visées.
  %
  Quant aux seconds, ils pourraient profiter de spécifications décrivant sans
  ambiguïtés les exigences auxquelles leurs logiciels doivent se conformer pour
  pouvoir profiter de ces politiques.

  Notre démarche se place à la croisée de deux domaines de vérification.
  %
  La vérification matérielle, d’une part, se concentre généralement sur des
  propriétés qui s’appliquent dans l’absolu à la plate-forme comme à la pile
  logicielle exécutée par cette dernière.
  %
  De nombreux travaux ont ainsi cherché à vérifier des protocoles de cohérence
  de caches (REF), ou la correcte implémentation par un processeur d’un modèle
  mémoire (REF).
  %
  La vérification de logiciels bas niveaux, notamment des systèmes
  d’exploitation ou des hyperviseurs, d’autre part, se repose naturellement sur
  des modèles de la plate-forme matérielle sous-jacente.
  %
  Néanmoins, ces modèles abstraient bien souvent autant que faire se peut la
  complexité de l’architecture matérielle, pour n’en garder que les éléments
  essentiels ---~bien souvent, les mécanismes de pagination et les
  interruptions.
  %
  La conséquence de cet état de fait est que les mécanismes nécessitant une
  configuration logicielle sont moins souvent les sujets de vérification
  formelle.

  Les travaux qui se rapprochent le plus de notre objectif et dont nous avons
  connaissance sont ceux de Jomaa \emph{et al.}\,\cite{jomaa2016mmu}, en lien
  avec le protokernel Pip (REF).
  %
  Nous nous inscrivons dans la continuité de cette approche, mais cherchons à
  dégager un formalisme beaucoup plus générique, qui reposerait notamment sur un
  modèle matériel le plus générique et complet possible.
  %
  Cependant, un tel modèle n’est pas sans poser de sérieux défis quant à son
  applicabilité dans un problème de vérification réaliste.
  %
  En effet, la complexité d’un modèle a un impact direct sur la facilité avec
  laquelle on peut l’exploiter.
  %
  Il est donc important de se poser, en amont, les bonnes
  questions quant à l’approche utilisée pour le définir, afin que les efforts
  nécessaires pour sa conception ne soient pas dépensés en vain.
  %
  Plusieurs travaux ont plaidé en faveur d’une approche basée sur le
  \emph{compositional reasoning}, où le système est divisé en un sous-ensemble
  de composants et la vérification axée autour de leurs interactions, pour faire
  face à ces défis\,\cite{garg2010compositional,heyman2012securemodel}.

  \subsection*{Contributions}

  Dans cette thèse, nous présentons deux contributions complémentaires, qui ont
  chacune fait l’objet d’une publication à la conférence \emph{Formal Methods};
  d’abord en 2016\,\cite{letan2016speccert}, puis en
  2018\,\cite{letan2018freespec}.

  \paragraph{Une théorie des mécanismes HSE.}
  %
  Notre première contribution est une théorie des mécanismes HSE, dont
  l’objectif premier est de servir de support à la spécification et à la
  vérification de ces derniers.
  %
  Elle s’articule autour d’une méthodologie divisée en plusieurs étapes.
  %
  L’architecture matérielle est dans un premier temps modélisé sous la forme
  d’un système de transitions étiquetées (\emph{labeled transition system}, en
  anglais, désigné par la suite par l’acronyme LTS).
  %
  Un LTS est traditionnellement caractérisé par un ensemble d’états, un ensemble
  d’étiquettes et une relation de transition.
  %
  Une étiquette est attachée à chaque transition pour permettre de leur attacher
  un sens particulier.
  %
  Le plus souvent, l’étiquette permet de décrire ce qui a causé la transition.

  Dans notre théorie, un modèle matériel dans notre théorie se présente sous la
  forme d’un quadruplet \( \langle H, L_S, L_H, \rightarrow \rangle \), où
  %
  \begin{itemize}
  \item \( H \) est l’ensemble des états que peut prendre le LTS, par exemple la
    valeur des registres des différents composants matériels de la plate-forme
    et le contenu de la DRAM;
  \item \( L_S \) est l’ensemble des étiquettes attachées aux transitions dites
    logicielles;
  \item \( L_H \) est l’ensemble des étiquettes attachées aux transitions dites
    matérielles;
  \item \( \rightarrow \) est la relation de transition du système.
  \end{itemize}

  Une transition logicielle est une conséquence directe et prévisible de
  l’exécution, par la plate-forme matérielle, d’une instruction faisant parti du
  programme d’un logiciel.
  %
  Au contraire, une transition matérielle Les autres transitions, qui échappentn

  \subsection*{Travaux futures}
\end{otherlanguage}
