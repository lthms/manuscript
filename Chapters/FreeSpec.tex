\chapter{Modular Verification of Component-based Systems}
\label{chapter:freespec}

\endquote{``\emph{Give someone a program, you frustrate them for a day; teach
    them how to program, you frustrate them for a lifetime.}''

  \hfill\footnotesize --- David Leinweber}

\vspace{1cm}%
\noindent
%
For many years, industrial vendors\,\cite{reid2017arm,leslie2015sgx} and
researchers\,\cite{chong2016report,choi2017kami} have aimed to formally specify
and verify hardware architectures.
%
However, verifying properties of existing computing platforms poses significant
challenges, because they tend to be both complex and under-specified; we are not
aware of any model of existing and broadly used computing system that is
comprehensive in terms of its hardware and software components.
%
Unfortunately, such a model is a prerequisite to verify a computing platform in
terms of architectural attacks.
%
The scale of the task dictates several requirements regarding the formalism to
adopt in this particular case.
%
It must allow for considering independently each component of our system, before
composing them to conclude about the properties of the system as a whole.

This objective is reminiscent of the programming language problematic to model
and verify large programs with side effects.
%
Reasoning about side effects in purely functional languages such as {\textsc
  Gallina}, the Coq specification language, is difficult, firstly because they
imply to somehow take into account an outer \emph{stateful} environment and
secondly, because the composition of stateful computations is not well-handled
by traditional (monadic) approaches.
%
Algebraic effects and handlers\,\cite{bauer2015effects} are a generic approach
to overcome this double challenge.
%
They allow to model large classes of effects (e.g., exception, state,
non-determinism) and to compose effects within purely functional programs, while
deferring the realizations of these effects to dedicated handlers.

In this Chapter, we aim to show how a variant of algebraic effects based on Free
monads can be used to reason about large systems, by modelling their components
as effect handlers.
%
Our contribution is threefold:
\begin{itemize}
\item We propose an approach which leverages the key concepts of algebraic
  effects and handlers to model and to verify each component of a computing
  system independently, while providing the necessary abstractions to compose
  these components in order to verify the properties of the resulting system.
%
\item We have implemented FreeSpec\,\footnote{FreeSpec has been released as a
    free software, under the terms of the GPLv3.
    \url{https://github.com/ANSSI-FR/FreeSpec}}, a framework for the Coq proof
  assistant to \emph{modularly} verify programs with effects and effects
  handlers with our approach.
%
\item We have modelled and verified a simplified subset of an x86 computing
  system with FreeSpec in order to illustrate how our formalism can be leveraged
  to tackle our initial objective, that is modelling and verifying computing
  platforms.
\end{itemize}

The rest of the paper proceeds as follows.
%
We describe how we model components in terms of programs with effects and effect
handlers (Section~\ref{sec:freespec:specifying}) and we introduce so-called
abstract specifications to verify their respective properties
(Section~\ref{sec:freespec:verifying}).
%
To illustrate our definitions, we use a running example in the form of the
specification and verification of a simplified MCH.
%
Then, we discuss how the different levels of composition of FreeSpec can be
leveraged to scale the modelling and verification work for larger systems
(Section~\ref{sec:freespec:scale}).

\section{A Compositional Reasoning Framework}
% ==============================================================================

\subsection{{\scshape Minx86} Limitations}

Implementing the proofs of correctness of \( \Delta_{\mathtt{bios}} \) has been
very insightful.
%
In this subsection, we emphasize two limitations of {\scshape Minx86} ---the
hardware model which acts as a foundation of this verification work--- which
makes its use at a larger scale unlikely.
%
Then, we formulate requirements on a potential successor for {\scshape Minx86},
that would allow for taking better advantage of our \ac{hse} mechanism
definition.

\paragraph{Monolithic Model.}
%
The set of states \( H(S) \) of {\scshape Minx86} is the Cartesian product of
the sets of states of its hardware components, namely a core, a cache, a memory
controller and two arrays of memory cells.
%
That is, {\scshape Minx86} is a monolithic model, and this is not without
consequences when the time comes to reason about its correctness.

In our case, it has remained manageable in practice, because we carefully
organized our Coq development in order to keep components separated from each
other as much as possible.
%
This does not prevent some changes to the definition of \( H(S) \) to have an
important impact on proofs already written at the moment.
%
We have no doubt that such situations will arise again if we try to increase the
scope of {\scshape Minx86}.

Some transitions of {\scshape Minx86} imply several state updates may happen in
sequence.
%
This is particularly true for \( \mathrm{Read} \) and \( \mathrm{Write} \)
transitions, as both the cache and memories are updated in case of cache misses
or cache evictions.
%
The complexity of a transition postcondition has a direct impact on the proofs
we have to construct in order to verify the correctness of a given system.
%
For instance, let \( M \) be a transition system, such that the transition
relation \( R \) of \( M \) is defined as follows:
%
\[
  R \triangleq \{ (h, h')\ |\ h' = t(s(r(h))) \}
\]
%
Let \( \iota \) be a predicate on \( M \) states, such that \( \iota \) is
expected to be an invariant with respect to \( R \), that is
%
\[
  h' = t(s(r(h))) \vdash \iota(h) \Rightarrow \iota(h')
\]
%
Regarding the definition of \( r \), \( s \) and \( t \), proving this statement
all at once can quickly become unmanageable.
%
One possible approach to face this challenge is to manually divide the
transition into several change updates ---\emph{i.e.} one per state update---
and prove that \( \iota \) is preserved throughout the transition, as
illustrated in Figure~\ref{freespec:figure:seqproof}.
%
Proving \( \Delta_{\mathtt{bios}} \) was correct with respect to
\( I_{\mathtt{bios}} \) using Coq\,\cite{letan2016speccertcode} led us to
successfully adopt this approach.
%
In practice, we relied on a recurring pattern we call
``\texttt{remember};~\texttt{destruct};~\texttt{assert};~\texttt{apply}'', after
the {\scshape Ltac} tactics.
%
We illustrate the use of this pattern with the proof obligation with the proof
goal pictured in Figure~\ref{fig:freespec:postcondition}.
%
We have been extracted this goal directly from the SpecCert project; we have
only slightly simplified it so it can fit into the page.
%
\begin{enumerate}
\item Using \texttt{remember}, we can make the sequence of state updates more
  visible (see Figure~\ref{fig:freespec:remember}, compared to
  Figure~\ref{fig:freespec:entrypoint}).
  %
  As a result, the Coq goal is more readable, which greatly simplify the task to
  write the proof.
\item Using \texttt{destruct}, we can explore the alternative paths.
  %
  For instance, regarding the initial state of the system, the content of the
  address \( \mathtt{pa} \) may or may not be present in the cache
  (Figure~\ref{fig:freespec:remember}, line 7).
  %
  We explore both solution, though two complementary goals (see the two
  simplified goals in Figure~\ref{fig:freespec:destruct})
  %
\item Using \texttt{assert}, we can introduce now goals to prove intermediary
  results (like the one in Figure~\ref{fig:freespec:assert}, for instance).
  %
  In our case, we will prove that the predicate \texttt{inv} remains satisfied
  after each state update.
  %
\item Using \texttt{apply}, we can leverage lemmas about \texttt{inv}
  preservation for a given state update.
  %
  For instance, the function \texttt{update\_cache\_content}
  (Figure~\ref{fig:freespec:remember}, line 11) have a lemma called
  \texttt{update\_cache\_content\_with\_context\_preserves\_inv}.
\end{enumerate}

\begin{figure}
{\bigcentering%
  \AxiomC{}%
  \LeftLabel{\footnotesize {\scshape Id}} \UnaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      \hline
      \vdash \iota(h)
    \end{array}
    \)}%
  \AxiomC{}%
  \RightLabel{\footnotesize {\scshape Inv}\( _r \)} \UnaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      h_1 = r(h) \\
      \hline
      \vdash \iota(h) \Rightarrow \iota(h_1)
    \end{array}
    \)}%
  \LeftLabel{\footnotesize {\scshape M-P}}%
  \BinaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      h_1 = r(h) \\
      \hline
      \vdash \iota(h_1)
    \end{array}
    \)}%
  \AxiomC{}%
  \RightLabel{\footnotesize {\scshape Inv}\( _s \)} \UnaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      h_1 = r(h) \\
      h_2 = s(h_1) \\
      \hline
      \vdash \iota(h_1) \Rightarrow \iota(h_2)
    \end{array}
    \)}%
  \LeftLabel{\footnotesize {\scshape M-P}}%
  \BinaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      h_1 = r(h) \\
      h_2 = s(h_1) \\
      \hline
      \vdash \iota(h_2)
    \end{array}
    \)}%
  \AxiomC{}%
  \RightLabel{\footnotesize {\scshape Inv}\( _t \)} \UnaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      h_1 = r(h) \\
      h_2 = s(h_1) \\
      h' = t(h_2) \\
      \hline \vdash \iota(h_2) \Rightarrow \iota (h')
    \end{array}
    \)}%
  \RightLabel{\footnotesize {\scshape M-P}}%
  \BinaryInfC{\(
    \begin{array}{l}
      \iota(h) \\
      h_1 = r(h) \\
      h_2 = s(h_1) \\
      h' = t(h_2) \\
      \hline \vdash \iota (h')
    \end{array}
    \)}%
  \DisplayProof%

  \vspace{0.5cm} where {\scshape M-P} is the \emph{Modus ponens}, and {\scshape
    Inv}\( _r \), {\scshape Inv}\( _s \), and {\scshape Inv}\( _t \) are
  intermediary lemmas previously proved true.%
}

\caption{Dividing a transition into a sequences of state updates}
\label{freespec:figure:seqproof}
\end{figure}

\begin{figure}
  \inputminted{coq}{Listings/StateHell.v}

  \caption{Raw postcondition of a \texttt{Write} transition with a writeback
    strategy}
  \label{fig:freespec:entrypoint}
\end{figure}

\begin{figure}
  \inputminted{coq}{Listings/RememberPattern.v}

  \caption{Postcondition of a \texttt{Write} transition with a writeback
    strategy, after the use of the \texttt{remember} tactic}
  \label{fig:freespec:remember}
\end{figure}

\begin{figure}
  \inputminted{coq}{Listings/DestructGoal.v}

  \inputminted{coq}{Listings/DestructGoal2.v}

  \caption{Exploring alternative paths thanks to the \texttt{destruct} tactics}
  \label{fig:freespec:destruct}
\end{figure}

\begin{figure}
  \inputminted{coq}{Listings/InvGoals.v}

  \caption{Intermediary statements, generated thanks to \texttt{assert} tactics}
  \label{fig:freespec:assert}
\end{figure}

The ``\texttt{remember};~\texttt{destruct};~\texttt{assert};~\texttt{apply}''
structures the proof, but it remains cumbersome to use.
%
Besides, it emphasizes another important limitation of {\scshape Minx86}, that
is it is potentially subject to tho so-called \emph{temporary violation
  problem}\,\cite{muller2006tempviolation}, where a predicate is satisfied
\emph{before} and \emph{after} a given transition, yet is temporary violated
\emph{during} the transition.
%
For instance, if it exists a state \( h \) such that \( \neg r(h) \) or
\( \neg s(r(h)) \) holds true, then \( M \) is subject to the temporary
violation problem.
%
A well known illustration of this threat is ---once again--- the airlock system.

\begin{example}[Temporary Violation Problem in an Airlock System]
  %
  In Example~\ref{example:sota:airlocklts}, we have carefully defined the
  labeled transition system of the airlock system so that it is unambiguously
  not subject to the temporary violation problem.
  %
  We did that by avoiding transitions between states
  \( (\mathtt{open}, \mathtt{close}) \) and
  \( (\mathtt{close}, \mathtt{open}) \).
  %
  In practice, it is possible to define a transition system with these
  transitions, such that it is correct with respect to the safety property that
  at least one door should be close at anytime, for instance:

  \begin{center}
    \begin{tikzpicture}
      \node [draw, circle split, text width=30pt, text badly centered] (cc)
      {\( \mathtt{close} \) \nodepart{lower} \( \mathtt{close} \)};%
      \node [right=60pt of cc] (x) {};%
      \node [draw, circle split, above=of x, text width=30pt, text badly
      centered] (oc) {\( \mathtt{open} \) \nodepart{lower}
        \( \mathtt{close} \)};%
      \node [draw, circle split, below=of x, text width=30pt, text badly
      centered] (co) {\( \mathtt{close} \) \nodepart{lower}
        \( \mathtt{open} \)};%
      \node [draw, circle split, right=60pt of x, text width=30pt, text badly
      centered] (oo) {\( \mathtt{open} \) \nodepart{lower} \( \mathtt{open}
        \)};%

      \draw [-latex] (cc) edge [bend left] node [xshift=-5pt, left]
      {\( \mathtt{Req}_1 \)} (oc);%

      \draw [-latex] (cc) edge [bend right] node [xshift=-5pt, left]
      {\( \mathtt{Req}_2 \)} (co);%

      \draw [-latex] (oc) edge [bend left] node [right] {\( \mathtt{Req}_2 \)}
      (co);%
      \draw [-latex] (co) edge [bend left] node [left] {\( \mathtt{Req}_1 \)}
      (oc);%
    \end{tikzpicture}
  \end{center}

  We can imagine several scenarios:
  %
  \begin{inparaenum}[(1)]
  \item Doors states updates are simultaneous and instantaneous, in other words
    the transitions \emph{are} atomic.
    %
  \item The airlock system first closes one door before opening the
    other. \label{enum:freespec:goodairlock}
    %
  \item The airlock system first opens one door before closing the
    other. \label{enum:freespec:badairlock}
    %
  \end{inparaenum}
  %
  The systems modeled in Examples~\ref{example:sota:airlocklts},
  ~\ref{example:sota:airlockinterface} and~\ref{example:sota:airlockprocess}
  corresponds to the scenario (\ref{enum:freespec:goodairlock}).
  %
  On the contrary, the transition system pictures in this example is not precise
  enough to discard the eventuality that both doors are, at a given point in
  time, both open.
\end{example}

Although the \texttt{remember;~destruct;~assert;~apply} pattern can help to
uncover temporary violation of an invariant, nothing prevents the verifier from
forgetting a given state updates and yet being able to conclude the proof.
%
The temporary violation problem undermines the second \ac{hse} law, which
stipulates that the requirement on hardware state of a \ac{hse} mechanism is an
invariant of the model with respect to the requirement on software transitions
(see Definition~\ref{def:speccert:laws}).
%
For the \ac{hse} mechanism \( \Delta_{\mathtt{bios}} \) ---defined as
\( \langle S, T, \mathrm{context}, \mathrm{hardware\_req}, \mathrm{bios\_req}
\rangle \), see Definition~\ref{def:speccert2:minx86}--- this translates as
follows:
%
\[
  \begin{array}{l}
    \forall (h, l, h') \in H(S) \times L \times H(S), \\
    \qquad\func{hardware\_req}(h) \\
    \qquad\Rightarrow (l \in L_S \Rightarrow \func{bios\_req}(h, l)) \\
    \qquad\Rightarrow \func{hardware\_req}(h')
  \end{array}
\]
%
In practice, transitions in {\scshape Minx86} are not atomic (they are made of
several state updates), and an attacker may be able to leverage a temporary
violation of invariant, similarly to the Speed Rcare
attack\,\cite{kallenberg2015racecondition} detailed in
Subsection~\ref{subsec:usecase:hse:speed}.
%
To model that threat without changing the modeling structure of {\scshape
  Minx86} requires increasing the granularity of the transitions, with the
direct consequence to increase the model overall complexity.

\paragraph{Abstract Model.}
%
The definition of {\scshape Minx86} has been governed by the use case we have
used it for.
%
The memory location ownership we have embedded inside the model is the most
visible demonstration of that fact.
%
By construction, {\scshape Minx86} abstracts away the concrete domain of memory
location contents (that are, bytes of bits), similarly to what a type inference
algorithm can do.
%
It worked, because we did not modeled hardware features whose behavior depends
for instance on configuration stored in memory for instance (\emph{e.g.} a
\ac{mmu} and its page tables).
%
We have tried to address this issue by modifying the model, so that both the
concrete value and its abstraction cohabit.
%
However, if we ever try to verify a \ac{hse} mechanism with respect to a
security policies which rely on totally different abstract domains, we will have
to modify the model another time.
%
This greatly reduces the opportunity to reuse {\scshape Minx86} for other
security policies, and therefore contradicts our initial goal to verify \ac{hse}
mechanisms of the same architecture against the same model.

\begin{table}
  \center
  \begin{tabular}{ccccc}
    $I_{\mathrm{C}}$
    & $\xrightarrow{\mathrm{Core}}$
    & $I_{\mathrm{MCH}}$ \\
    \hline
    \hline
    $\mathbb{P}$
    & $\Longrightarrow$
    & \ $\mathbb{P}'$ \\
    $\Downarrow$
    &
    &
      $\Downarrow$ \\
    $\mathbb{Q}$
    & $\Longleftarrow$
    & \ $\mathbb{Q}'$ \\
    \hline
  \end{tabular}
  \caption{Scheme of the verification proof for a component}
\end{table}

\subsection{Approach Overview}

During the development of SpecCert, we have carefully organized our work to
model and verify each component of {\scshape Minx86} in isolation prior to
reason about the architecture as a whole.
%
Even though these efforts were sufficient in our case, we believe they should be
supported by an appropriate framework to reduce risk of error of omission, and
to automate the verification process.
%
Besides, there are certain crucial properties that we cannot express easily in
{\scshape Gallina} without a proper formalism, like the non-temporary violation
property, or the concurrent interactions of components (\emph{e.g.}  concurrent
access of the \ac{dram} by \acp{cpu} and peripherals).

In this Chapter, we address detailed limitations of {\scshape Minx86} by
introducing such a compositional reasoning framework.
%
We leverage the key concepts of algebraic effects and effects handlers to model
and to verify each component of a computing system independently.
%
We also provide the necessary abstractions to compose these components together
in order to verify the properties of the resulting systems.
%
We have implemented our framework in Coq, in a project called
FreeSpec\,\cite{letan2018freespeccode}.
%
This Chapter focuses on the theoretical foundation of FreeSpec.
%
The interested reader can refer to the Appendix~\ref{appendix:freespec}, which
gives a tutorial for FreeSpec.

\begin{figure}
  \centering
  \begin{tikzpicture}
    % Memory Controller
    \node [inner sep=15pt, draw] (MC) {Memory Controller};%
    \draw ([yshift=5pt, xshift=3pt]MC.north west) -- ([yshift=5pt,
    xshift=-3pt]MC.north east);%
    \node [right=4pt of MC.north east, yshift=3pt, text width=0.5cm] (Im)
    {$I_{\mathrm{MC}}$};%
    \node [left=4pt of MC.north west, yshift=3pt, text width=0.5cm] (Im_shadow)
    {};%

    % Cache & IOMMU
    \node [above=30pt of MC] (CIO) {};%
    % -- Cache
    \node [inner sep=8pt, draw, right=13pt of CIO.center] (Cache) {Cache};%
    \draw ([yshift=5pt, xshift=3pt]Cache.north west) -- ([yshift=5pt,
    xshift=-3pt]Cache.north east);%
    \node [right=4pt of Cache.north east, yshift=3pt, text width=0.5cm] (Ic)
    {$I_{\mathrm{Cache}}$};%
    \node [left=4pt of Cache.north west, yshift=3pt, text width=0.5cm]
    (Ic_shadow) {};%
    % -- IOMMU
    \node [inner sep=8pt, draw, dashed, left=5pt of CIO.center] (IOMMU) {I/O
      MMU};%

    % CPU
    \node [inner sep=8pt, draw, above=20pt of Cache] (CPU) {Core};%
    \draw ([yshift=5pt, xshift=3pt]CPU.north west) -- ([yshift=5pt,
    xshift=-3pt]CPU.north east);%
    \node [right=4pt of CPU.north east, yshift=3pt] (Ic) {$I_{\mathrm{C}}$};%

    % Software
    \node [inner sep=8pt, draw, dashed, above=30pt of CPU.center] (S)
    {Software};%

    % Mems
    \node [below=50pt of MC.center] (M) {};%
    % -- DRAM
    \node [inner sep=8pt, draw, left=3pt of M.center, text width=1.3cm, text
    badly centered] (DRAM) {DRAM};%
    \draw ([yshift=5pt, xshift=3pt]DRAM.north west) -- ([yshift=5pt,
    xshift=-3pt]DRAM.north east);%
    \node [left=4pt of DRAM.north west, yshift=3pt, text width=1cm] (Id)
    {$I_{\mathrm{DRAM}}$};%
    % -- VGA
    \node [inner sep=8pt, draw, right=3pt of M.center, text width=1.3cm, text
    badly centered] (VGA) {VGA};%
    \draw ([yshift=5pt, xshift=3pt]VGA.north west) -- ([yshift=5pt,
    xshift=-3pt]VGA.north east);%
    \node [right=4pt of VGA.north east, yshift=3pt, text width=1cm] (Iv)
    {$I_{\mathrm{VGA}}$};%

    % arrows
    \draw [-latex] (CPU.south) -- ([yshift=5pt]Cache.north);%
    \draw [-latex] (S.south) -- ([yshift=5pt]CPU.north);%
    \draw [latex-] ([yshift=5pt]DRAM.north) |- (MC.south);%
    \draw [latex-] ([yshift=5pt]VGA.north) |- (MC.south);%
    \draw [-latex] (IOMMU.south) -- ([yshift=-41pt]IOMMU.north);%
    \draw [-latex] (Cache.south) -- ([yshift=-41pt]Cache.north);
  \end{tikzpicture}

  \caption{Interface-driven modeling of the x86 architecture}
  \label{fig:freespec:interfacedriven}
\end{figure}

\paragraph{Components and Interfaces}
%
An interface is a set of interdependent operations, which are expected to
produce a value.
%
A component is characterized primarily by the interface it exposes to the rest
of the system, and secondarily by its current state and the interfaces it uses
in order to operate.
%
A component receives requests to compute results of operations through its
interface, and sends operations requests to other components it is connected to
\emph{via} their interfaces and waits for their results.
%
Figure~\ref{fig:freespec:interfacedriven} pictures how this could materialize to
model a simplified x86 architecture.
%
The software components interact with the core \emph{via} its instructions set.
%
When the core needs to read from or write to memory, it leverages its cache.
%
In case of cache miss or cache eviction, the cache interacts with the system
memory through the memory controller, whose goal is to dispatch memory accesses
between \emph{e.g.} \ac{dram} and the VGA controller.
%
In addition, the memory controller dispatches memory requests coming from other
sources, for instance an I/O~MMU.

Figure~\ref{fig:freespec:seqdiagr} illustrates the class of scenarios we are
seeking to model with our framework.

\begin{figure}
  \bigcentering
  \begin{sequencediagram}
    \newthread{S}{Software}%
    \newinst[1.5]{C}{Core}%
    \newinst[1.5]{Ca}{Cache}{}%
    \newinst[1.5]{MC}{Memory Controller}{}%
    \newinst[1.5]{IO}{I/O~MMU}{}%

    \begin{call}{S}{\texttt{movq~\$0,~(\%rax)}}{C}{}%
      \begin{call}{C}{\texttt{read\_reg(\%rax)}}{C}{\( p \)}
      \end{call}

      \begin{call}{IO}{\texttt{\texttt{write}(\( p'' \), \( v' \),
            \texttt{unpriv})}}{MC}{}
      \end{call}

      \begin{call}{C}{\texttt{write}(\( p \), 0, \texttt{priv})}{Ca}{}%
        \begin{call}{Ca}{\texttt{\texttt{cache\_hit}(\( p
              \))}}{Ca}{\texttt{false}}
        \end{call}
        \begin{call}{Ca}{\texttt{\texttt{write}(\( p' \), v,
              \texttt{priv})}}{MC}{}
        \end{call}
        \begin{call}{Ca}{\texttt{\texttt{write\_cache\_line}(\( \func{index}(p),
              0 \))}}{Ca}{}
        \end{call}
      \end{call}
    \end{call}
  \end{sequencediagram}

  \caption{Sequence diagram of the execution of \texttt{movq~\$0, (\%rax)}}
  \label{fig:freespec:seqdiagr}
\end{figure}

\section{Modelling Programs with Effects}
% ==============================================================================
\label{sec:freespec:specifying}

The first objective of FreeSpec is to incrementally model a complex system, one
component at a time.
%
To do so, we use the key concepts of algebraic effects and effect handlers,
implemented with a variant of the Free monad called the Program monad as defined
in the \texttt{operational} package of Haskell\,\cite{operational}.

\begin{center}
  \begin{tikzpicture}
    % Mems
    % -- DRAM
    \node (M) {};%
    \node [inner sep=8pt, dashed, draw, left=3pt of M.center, text width=1.3cm,
    text badly centered] (DRAM) {DRAM};%
    \draw ([yshift=5pt, xshift=3pt]DRAM.north west) -- ([yshift=5pt,
    xshift=-3pt]DRAM.north east);%
    \node [left=4pt of DRAM.north west, yshift=3pt, text width=1cm] (Id)
    {$I_{\mathrm{DRAM}}$};%
    % -- VGA
    \node [inner sep=8pt, dashed, draw, right=3pt of M.center, text width=1.3cm,
    text badly centered] (VGA) {VGA};%
    \draw ([yshift=5pt, xshift=3pt]VGA.north west) -- ([yshift=5pt,
    xshift=-3pt]VGA.north east);%
    \node [right=4pt of VGA.north east, yshift=3pt, text width=1cm] (Iv)
    {$I_{\mathrm{VGA}}$};%

    % Memory Controller
    \node [inner sep=8pt, draw, above=30pt of M.center] (MC) {Memory
      Controller};%
    \draw ([yshift=5pt, xshift=3pt]MC.north west) -- ([yshift=5pt,
    xshift=-3pt]MC.north east);%
    \node [right=4pt of MC.north east, yshift=3pt] (Im) {$I_{\mathrm{MC}}$};%

    % CPU
    \node [inner sep=16pt, draw, dashed, above=30pt of MC.center]
    (CPU) {CPU};%

    % arrows
    \draw [-latex] (CPU.south) -- ([yshift=5pt]MC.north);%
    \draw [latex-] ([yshift=5pt]DRAM.north) |- (MC.south);%
    \draw [latex-] ([yshift=5pt]VGA.north) |- (MC.south);%

    % blank
    \node [below=of M.center] (Blank) {};
  \end{tikzpicture}
\end{center}

This section and the one afterwards proceed through a running example: a
minimalist Memory Controller Hub (MCH) of the x86 hardware architecture.
%
The MCH acts as a dispatcher for the CPU memory accesses; in our case, to the
VGA controller or the DRAM controller.
%
The MCH takes part in the isolation of the SMRAM, that is the special-purpose
memory region inside the system memory which contains the SMM code.
%
If correctly configured, the MCH will reroute any memory access which targets
the SMRAM to the VGA controlled, if this access is done by a CPU in another
execution mode than SMM.

% pictured in the Figure~\ref{fig:mch-running-example}.
% \begin{figure}
%   \centering \includestandalone[width=.5\textwidth]{running-example}
%
%   \caption{Idealised Memory Controller Hub}
%   \label{fig:mch-running-example}
% \end{figure}

\subsection{Interface of Effects}
% ------------------------------------------------------------------------------

Within a computing system, interconnected components communicate through
interfaces.
%
A component which exhibits an interface receives computational requests from
other components; it handles these requests by computing their results and
sending the latter back to the client component.
%
In FreeSpec, a computational request is modelled with an effect, that is a
symbolic value which describes the request and its potential result.

For $\I$ an interface, we denote by $\Interface{\I}{\mathcal{A}} \subseteq \I$
the subset of effects whose results belong to a set~$\mathcal{A}$.

\begin{example}[MCH Interfaces]
  The VGA and the DRAM controllers exhibit a similar interface which allows for
  reading and writing into a memory region.
  %
  Their interfaces are denoted by $\I_{\mathrm{VGA}}$ and $\I_{\mathrm{DRAM}}$
  respectively.
  %
  Let $\mathpzc{Loc}$ be the set of memory locations and $\mathpzc{Val}$ the set
  of values stored inside the memory region.
  %
  We use the unit value \ac{unit} to model effects without results (similarly to
  the \texttt{void} keyword in an imperative language).
  %
  We define $\I_{\mathrm{DRAM}}$ (respectively $\I_{\mathrm{VGA}}$) with two
  constructors:
  \begin{itemize}
  \item
    $\func{Read}_{\mathrm{DRAM}} : \mathpzc{Loc} \rightarrow
    \Interface{\I_{\mathrm{DRAM}}}{\mathpzc{Val}}$
  \item
    $\func{Write}_{\mathrm{DRAM}} : \mathpzc{Loc} \rightarrow \mathpzc{Val}
    \rightarrow \Interface{\I_{\mathrm{DRAM}}}{\{\ac{unit}\}}$
  \end{itemize}

  Then,
  $\I_{\mathrm{DRAM}} =
  \Interface{\I_{\mathrm{DRAM}}}{\{\ac{unit}\}}\,\cup\,\Interface{\I_{\mathrm{DRAM}}}{\mathpzc{Val}}$,
  and
  $\func{Read}_{\mathrm{DRAM}}(l) \in
  \Interface{\I_{\mathrm{DRAM}}}{\mathpzc{Val}}$ is an effect that describes a
  memory access to read the value~$v \in \mathpzc{Val}$ stored at the
  location~$l \in \mathpzc{Loc}$.

  The MCH interface is similar, but it distinguishes between privileged and
  unprivileged accesses.
  %
  It also provides one effect to lock the SMRAM protection mechanism, i.e. it
  enables the SMRAM isolation until the next hardware reset.
  %
  We define the set
  $\mathpzc{Priv}~\triangleq~\{\,\val{smm}, \val{unprivileged}\,\}$ to
  distinguish between privileged memory accesses made by a CPU in SMM and
  unprivileged accesses made the rest of the time.
  %
  The MCH interface, denoted by $\I_{\mathrm{MCH}}$, is defined with three
  constructors:
  \begin{itemize}
  \item
    $\func{Read}_{\mathrm{MCH}} : \mathpzc{Loc} \rightarrow \mathpzc{Priv}
    \rightarrow \Interface{\I_{\mathrm{MCH}}}{\mathpzc{Val}}$
  \item
    $\func{Write}_{\mathrm{MCH}} : \mathpzc{Loc} \rightarrow \mathpzc{Val}
    \rightarrow \mathpzc{Priv} \rightarrow
    \Interface{\I_{\mathrm{MCH}}}{\{\ac{unit}\}}$
  \item $\func{Lock} : \Interface{\I_{\mathrm{MCH}}}{\{\ac{unit}\}}$
  \end{itemize}
\end{example}

\subsection{Operational Semantics for Effects}
% -----------------------------------------------------------------------------

An effect corresponds to a computational request made to an implementation of a
given interface.
%
To compute the result of the computational request, we define its
\emph{operational semantics}.
%
Ultimately, we will model a component as an operational semantics for all the
effects of its interface.
%
Since operational semantics are defined using a purely functional language, they
always compute the same result for a given effect, which is inconsistent with
the stateful aspect of hardware components.
%
Thus, an operational semantics produces not only a result, but also a new
operational semantics, which encapsulates the new state of the component.

\begin{definition}[Operational Semantics]
  We write $\Sigma_{\I}$ for the set of operational semantics for a given
  interface $\I$, defined co-inductively as
  %
  \[
    \Sigma_{\I} \triangleq \{\,\sigma\,|\,\sigma : \forall \mathcal{A},
    \Interface{\I}{\mathcal{A}} \rightarrow \mathcal{A} \times \Sigma_{\I} \,\}.
  \]
  %
  An operational semantics~$\sigma \in \Sigma_{\I}$ is a function which, given
  any effect of $\I$, produces both a result which belongs to the expected set
  and a new operational semantics to use afterwards.
\end{definition}

A component may use more than one interface.
%
For instance, the MCH of our running example can access the system memory and
the memory shared by the VGA controller.
%
But an operational semantics is defined for only one interface.
%
In FreeSpec, we solve this issue by composing interfaces together to create new
ones.

\begin{definition}[Interfaces Composition]
  Let $\I$ and $\J$ be two interfaces. $\oplus$~is the interface composition
  operator, defined with two constructors:
  \begin{itemize}
  \item
    $\func{InL} : \forall \mathcal{A}, \Interface{\I}{\mathcal{A}} \rightarrow
    \Interface{(\I \oplus \J)}{\mathcal{A}}$
  \item
    $\func{InR} : \forall \mathcal{A}, \Interface{\J}{\mathcal{A}} \rightarrow
    \Interface{(\I \oplus \J)}{\mathcal{A}}$
  \end{itemize}
\end{definition}

The resulting interface $\I \oplus \J$ contains the effects of both $\I$ and
$\J$, wrapped into either $\func{InL}$ or $\func{InR}$ constructors, defined to
preserve the effects results sets.
%
% Notice that this usage of a tagged union allows for composing the same
% interface twice, so a component can use two components which exhibit the same
% interface.

\begin{example}[VGA and DRAM Composition]
  We consider $\I_{\mathrm{DRAM}} \oplus \I_{\mathrm{VGA}}$. Then,
  $\func{InL}(\func{Read}_{\mathrm{DRAM}}(l)) \in \Interface{(\I_{\mathrm{DRAM}}
    \oplus \I_{\mathrm{VGA}})}{\mathpzc{Val}}$ is an effect that describes a
  read access targeting the DRAM controller, whereas
  $\func{InR}(\func{Write}_{\mathrm{VGA}}(l, c)) \in
  \Interface{(\I_{\mathrm{DRAM}} \oplus \I_{\mathrm{VGA}})}{\{\ac{unit}\}}$ is
  an effect that describes a write access targeting the VGA controller.
\end{example}

Using $\oplus$, we can compose several interfaces together.
%
We then need another composition operator, this time for operational semantics.
%
We compose operational semantics together to construct a new operational
semantics for the composed interface.

\begin{definition}[Operational Semantics
  Composition] \label{def:freespec:semantics-composition} Let $\I$ and $\J$ be
  two interfaces, $\sigma_i \in \Sigma_{\I}$ and $\sigma_j \in \Sigma_{\J}$ be
  two operational semantics dedicated to these interfaces.
  %
  In this article, we use the $\lambda$-calculus abstraction notation for
  functions.
  %
  $\otimes$~is the composition operator for operational semantics, defined as
  \[ \sigma_i \otimes \sigma_j \triangleq \lambda e. \left \{
      \begin{array}{lcl}
        (x, \sigma_i' \otimes \sigma_j) & \text{when} & e =
                                                        \func{InL}(e_i)
                                                        \text{ and }
                                                        \sigma_i(e_i)
                                                        = (x,
                                                        \sigma_i') \\
        (x, \sigma_i \otimes \sigma_j') & \text{when} & e =
                                                        \func{InR}(e_j)
                                                        \text{ and }
                                                        \sigma_j(e_j)
                                                        = (x, \sigma_j')
      \end{array}
    \right.
  \]
\end{definition}

The definition of $\otimes$ has an important impact over what we can specify in
FreeSpec.
%
% When $\sigma_i \otimes \sigma_j$ handles an effect of $\I$, only $\sigma_i$
% ``changes.''
%
Handling an effect of $\I$ (respectively $\J$) does not interfere with
$\sigma_j$ (respectively $\sigma_i$).
%
As a consequence, \emph{we cannot specify as-is a graph of components which
  contains a cycle or a diamond}.
%
This is the main limitation of FreeSpec, but its incidence is abated because
computing platforms are often designed as a hierarchical succession of layers.

\subsection{The Program Monad}
% -----------------------------------------------------------------------------

Modelling programs with side effects in purely functional languages such as
{\textsc Gallina} (the Coq specification language) or Haskell is usually
achieved thanks to monads\,\cite{hoareetal2001monad}.
%
FreeSpec leverages a variant of the Free monad called the Program
monad\,\cite{operational} to model programs with effects. Operational semantics
play the role of \texttt{operational}\,\cite{operational} interpreters.
%
We write $P_{\I}(\mathcal{A})$ for the set of programs with effects which
belongs to $\I$, modelled thanks to the Program monad, and whose result belongs
to a set $\mathcal{A}$.

\begin{definition}[Program Monad]
  $P_{\I}(\mathcal{A})$ is defined with three constructors:
  \begin{itemize}
  \item $\func{Pure} : \mathcal{A} \rightarrow P_{\I}(\mathcal{A})$
  \item
    $\func{Bind} : \forall \mathcal{B}, P_{\I}(\mathcal{B}) \rightarrow
    (\mathcal{B} \rightarrow P_{\I}(\mathcal{A})) \rightarrow
    P_{\I}(\mathcal{A})$
  \item
    $\func{Request} : \Interface{\I}{\mathcal{A}} \rightarrow
    P_{\I}(\mathcal{A})$
  \end{itemize}
\end{definition}
%
These constructors allow for the construction of values which act similarly to
abstract syntax trees to model programs with effects.
%
On the one hand, $\func{Pure}$ and $\func{Request}$ are comparable to the leaves
of a syntax tree and model atomic computations; $\func{Pure}$ models local
computations, whereas $\func{Request}$ models deferring a computational request
to a handler and waiting for its result.
%
On the other hand, $\func{Bind}$ (usually written thanks to the infix operator
$\bind$) models the control flow of a program with effects, like the abstract
syntax tree nodes would.
%
It defines how the result of one computation determines the following ones.

\begin{example}[Copy]
  We define
  $\func{copy} : \mathpzc{Loc} \rightarrow \mathpzc{Loc} \rightarrow
  P_{\I_{\mathrm{DRAM}}}(\{\ac{unit}\})$ such that $\func{copy}(l, l')$ models a
  program with effects that returns no result, but copies the value $v$ stored
  at the memory location $l$ inside the memory location $l'$.
  %
  \[ \func{copy}(l, l') \triangleq
    \func{Request}(\func{Read}_{\mathrm{DRAM}}(l)) \bind \lambda
    v. \func{Request}(\func{Write}_{\mathrm{DRAM}}(l', v))
  \]
\end{example}

Given $l \in \mathpzc{Loc}$ and $l' \in \mathpzc{Loc}$, $\func{copy}(l, l')$
symbolically models a program with effects.
%
To assign an interpretation of this program, it must be completed with an
operational semantics which realizes the interface
$\mathcal{I}_{\mathrm{DRAM}}$.

\begin{definition}[Program With Effects
  Realization] \label{def:freespec:realisation} Let $\I$ be an interface,
  $\sigma \in \Sigma_{\I}$ an operational semantics for this interface and
  $\rho \in P_{\I}(\mathcal{A})$ a program with effects which belong to this
  interface.
  %
  $\sigma[\rho] \in \mathcal{A} \times \Sigma_{\I}$ denotes the realization of
  this program by $\sigma$, defined as:
  \[ \sigma[\rho] \triangleq \left\{
      \begin{array}{lcl} (x, \sigma) & \text{if} & \rho =
                                                   \func{Pure}(x) \\
        \sigma(e) & \text{if} & \rho =
                                \func{Request}(e) \\
        \sigma'[f(y)] & \text{if} & \rho =
                                    q \bind f\text{ and }(y, \sigma') = \sigma[q] \\
      \end{array}
    \right.
  \]
\end{definition}

\subsection{Components as Programs with Effects}
% -----------------------------------------------------------------------------

With the interfaces, their operational semantics, the $\oplus$ and $\otimes$
operators to compose them and the Program monad to model programs with effects
which belong to these interfaces, we now have all we need to model a given
component which exposes an interface $\I$ and uses another interface $\J$.
%
We proceed with the following steps: modelling the component in terms of
programs with effects, then deriving one operational semantics for $\I$ from
these programs, assuming provided an operational semantics for $\J$.

The behaviour of a component is often determined by a local, mutable state.
%
When it computes the result of a computational request, not only a component may
read its current state; but it can also modify it, for instance to handle the
next computational request differently.
%
This means we have to model the state of a component with a set $\mathcal{S}$ of
symbolic state representations.
%
We map the current state of the component and effects of $\I$ to a program with
effects of $\J$.
%
These programs must compute the effect result and the new state of the
component.

\begin{definition}[Component] \label{def:freespec:component-model} Let $\I$ be
  the interface exhibited by a component and $\J$ the interface it uses.
  %
  Let $\mathcal{S}$ be the set of its states.
  %
  The component $C$, defined in terms of programs with effects of $\J$, is of
  the form
  \[ \forall \mathcal{A}, \Interface{\I}{\mathcal{A}} \rightarrow \mathcal{S}
    \rightarrow P_{\J}(\mathcal{A} \times \mathcal{S}) \]
\end{definition}

Hence, $C$ specifies how the component handles computational requests, both in
terms of computation results and state changes.

\begin{example}[Minimal MCH Model] \label{ex:mch-specs} Let $C_{\mathrm{MCH}}$
  be the MCH defined in terms of programs with effects of
  $\I_{\mathrm{DRAM}} \oplus \I_{\mathrm{VGA}}$, then $C_{\mathrm{MCH}}$ is of
  the form
  \[
    \forall \mathcal{A}, \Interface{\I_{\mathrm{MCH}}}{\mathcal{A}} \rightarrow
    \mathcal{S}_{\mathrm{MCH}} \rightarrow P_{\I_{\mathrm{DRAM}} \oplus
      \I_{\mathrm{VGA}}}(\mathcal{A} \times \mathcal{S}_{\mathrm{MCH}})
  \] where $\mathcal{S}_{\mathrm{MCH}} \triangleq \{ \val{on}, \val{off} \}$
  means the SMRAM protection is either activated ($\val{on}$) or deactivated
  ($\val{off}$).

  One the one hand, the \func{Lock} effect will activate the isolation mechanism
  of the MCH, setting its state to $\val{on}$.
  %
  On the other hand, the effects constructed with $\func{Read}_{\mathrm{MCH}}$
  and $\func{Write}_{\mathrm{MCH}}$ will use the current state of the MCH, the
  privileged parameter of the effect and the memory location to lookup to
  determine if it uses the DRAM or the VGA controller.
  %
  By default, it fetches the memory of the DRAM controller, except if the
  isolation mechanism is activated, the access is unprivileged and the targeted
  memory location belongs to the SMRAM.
  %
  In such a case, it reroutes access to the VGA controller.
\end{example}

A component $C$ defined in terms of programs with effects cannot be used as-is
to compute the result of a given effect.
%
To do that, we need to derive an operational semantics for~$\I$ from $C$.

\begin{definition}[Deriving Operational
  Semantics] \label{def:freespec:derivation} Let $C$ be a component which
  exhibits an interface $\I$, uses an interface~$\J$ and whose states belong to
  $\mathcal{S}$.
  %
  Let $s \in \mathcal{S}$ be the current state of the component and
  $\sigma_j \in \Sigma_{\J}$ be an operational semantics for~$\J$.
  %
  We can derive an operational semantics for $\mathcal{I}$, denoted by
  $\langle C, s, \sigma_j \rangle$, defined as
  \[ \langle C, s, \sigma_j \rangle \triangleq \lambda i. (x, \langle C, s',
    \sigma_j' \rangle) \text{ where } ((x, s'), \sigma_j') = \sigma_j[C (i, s)]
  \]
\end{definition}

% On the one hand, components are defined in terms of programs with effects,
% meaning each component can be modelled independently from the rest of the
% system.
%%
% On the other hand, FreeSpec introduces the mechanism of derivation to
% aggregate these models together.
%
The resulting operational semantics models a system made of interconnected
components, and can then be used to derive another component model into an
operational semantics which models a larger system.
%
For instance, we can proceed with the following steps to comprehensively model
our running example: (i) defining the operational semantics for the DRAM and VGA
controllers; (ii) using these operational semantics to derive an operational
semantics from $C_{\mathrm{MCH}}$.
%
The resulting operational semantics can take part in the derivation of a cache
defined in terms of programs with effects of $\I_{\mathrm{MCH}}$, to model a
larger part of the system pictured in the
Figure~\ref{fig:freespec:computing-platform}.

\section{Modular Verification of Programs with Effects}
% =============================================================================
\label{sec:freespec:verifying}

The first objective of FreeSpec is to provide the required tools to model each
component of a system independently, and to compose these components to model
the whole system.
%
Its second objective is to verify that the composition of several components
satisfies a set of properties.
%
To achieve that, we introduce the so-called abstract specifications, which
allows for specifying, for each interface, expected properties for the effect
results, independently of any underlying handler.
%
Abstract specifications can be used to emphasize the responsibility of each
component of a system regarding the enforcement of a given security policy.
%
Verifying a component is done against abstract specifications of the interfaces
it directly uses, even if it relies on a security property enforced by a deeper
component in the components graph.
%
In this case, we have to verify that every single component which separate them
preserve this property.
%
This procedure can help to prevent or uncover architectural attacks.

In this section, we proceed with our running example by verifying that the MCH
correctly isolates the SMRAM.
%
In order to do that, we define an abstract specification which states that
privileged reads targeting the SMRAM returns the value which has previously been
stored by a privileged write. It models the SMRAM isolation: unprivileged writes
cannot tamper with the content of the SMRAM, as read by a privileged CPU.

\subsection{Abstract Specification}
% -----------------------------------------------------------------------------

In FreeSpec, an abstract specification dedicated to an interface $\I$ is
twofold.
%
It defines a precondition over the effects that a caller must satisfy; and, in
return, it specifies a postcondition over the effects results that an
operational semantics must enforce.
%
Since both the precondition and the postcondition may vary in time, we
parameterize an abstraction specification with an abstract state and a step
function to update this state after each effect realization.

\begin{definition}[Abstract Specification] \label{def:freespec:abstract-specs}
  We write $A$ for an abstract specification dedicated to an interface $\I$,
  defined as a tuple
  $\langle \Omega, \func{step}, \func{pre}, \func{post} \rangle$ where
  \begin{itemize}
  \item $\Omega$ is a set of abstract states
  \item
    $\func{step} : \forall \mathcal{A}, \Interface{\I}{\mathcal{A}} \rightarrow
    \mathcal{A} \rightarrow \Omega \rightarrow \Omega$ is a transition function
    for the abstract state.
  \item $\func{pre} \subseteq \I \times \Omega$ is the precondition over
    effects, such that $(e, \omega) \in \func{pre}$ if and only if the effect
    $e$ satisfies the precondition parameterized with the abstract state
    $\omega$ (denoted by $\func{pre}(e, \omega)$).
  \item
    $\func{post} \subseteq \bigcup_{\mathcal{A}} (\Interface{\I}{\mathcal{A}}
    \times \mathcal{A} \times \Omega)$ is the postcondition over effects
    results, such that $(e, x, \omega) \in \func{post}$ if and only if the
    results $x$ computed for the effects $e$ satisfies the postcondition
    parameterized with the abstract state $\omega$ (denoted by
    $\func{post}(e, x, \omega)$).
  \end{itemize}
\end{definition}

By defining an abstract specification of an interface $\I$, it becomes possible
to abstract away the effect handler, i.e. the underlying component.
%
As a consequence, reasoning about a program with effects can be achieved without
the need to look at the effect handlers.
%
An abstract specification is dedicated to one verification problem (in our
context, one security property), and it is possible to define as many
abstraction specifications as required.

We write
$\func{run}_{\func{step}} : \forall \mathcal{A}, \Sigma_{\I} \rightarrow
P_{\I}(\mathcal{A}) \rightarrow \Omega \rightarrow (\mathcal{A} \times
\Sigma_{\I} \times \Omega)$ for the function which, in addition to realize a
program with effects, updates an abstract state after each effect.
%
Using $\func{run}_{\func{step}}$, we can determine both the precondition over
effects and the postcondition over effects results while an operational
semantics realizes a program with effects.

\begin{example}[MCH Abstract Specification] \label{ex:mch-abs-specs} Let
  $A_{\mathrm{MCH}}$ be the abstract specification such that
  $A_{\mathrm{MCH}} = \langle \Omega_{\mathrm{MCH}}, \func{step}_{\mathrm{MCH}},
  \func{pre}_{\mathrm{MCH}}, \func{post}_{\mathrm{MCH}} \rangle$.
  %
  $A_{\mathrm{MCH}}$ models the following property: ``\emph{privileged reads
    targeting the SMRAM return the value which has been previously stored by a
    privileged write}’’:
  \begin{itemize}
  \item Let $\mathpzc{Smram} \subseteq \mathpzc{Loc}$ be the set of memory
    locations which belong to the SMRAM.  We define
    $\Omega_{\mathrm{MCH}} \triangleq \mathpzc{Smram} \rightarrow
    \mathpzc{Val}$, such that $\omega \in \Omega_{\mathrm{MCH}}$ models a view
    of the SMRAM as exposed by the MCH for privileged reads.
  \item We define $\func{step}_{\mathrm{MCH}}$ which updates the view of the MCH
    (modelled as a function) after each privileged write access targeting any
    SMRAM location $l$, that is
    \[ \func{step}_{\mathrm{MCH}}(e, x, \omega) \triangleq \left\{
        \begin{array}{l}
          \lambda l'.  \text{ (if } l = l' \text{ then } v \text{ else } \omega(l')) \\
          \qquad\ \ \text{ if } e = \func{Write}_{\mathrm{MCH}}(l, v, \val{smm})
          \text{ and } l \in \mathpzc{Smram} \\
          \omega \qquad \text{ otherwise}
        \end{array}
      \right.
    \]
  \item There is no precondition to the use of the MCH effects, so
    \[ \forall e \in \I,\forall \omega \in \Omega_{\mathrm{MCH}},
      \func{pre}_{\mathrm{MCH}}(e, \omega) \]
  \item The postcondition enforces that the result $x$ of a privileged read
    targeting the SMRAM ($\func{Read}(l, \val{smm})$) has to match the value
    stored in $A_{\mathrm{MCH}}$ abstract state, i.e. the expected content for
    this memory location $\omega(l)$.
    \[ \func{post}_{\mathrm{MCH}}(e, x, \omega) \triangleq \forall l \in
      \mathpzc{Loc}, e = \func{Read}_{\mathrm{MCH}}(l, \val{smm}) \wedge l \in
      \mathpzc{Smram} \Rightarrow x = \omega(l)
    \]
  \end{itemize}
\end{example}

% With an abstract specification
% $\langle \Omega, \func{step}, \func{pre}, \func{post} \rangle$, we can
% transparently update a given abstract state while realizing programs.

\subsection{Compliance and Correctness}
% -----------------------------------------------------------------------------

The verification of a component~$C$, which exhibits $\I$ and uses $\J$, consists
in proving we can derive an operational semantics $\sigma_i$ for $\I$ from an
operational semantics $\sigma_j$ for $\J$.
%
This semantics $\sigma_i$ enforces the postcondition of an abstract
specification $A_{\I}$ dedicated to $\I$ (compliance).
%
As $C$ is defined in terms of programs with effects of $\J$, the latter needs to
make a licit usage of $\J$ with respect to an abstract specification $A_{\J}$
dedicated to $\J$ (correctness).

First, $\sigma_i$ complies with $A_{\I}$ if, (1) given any effect which
satisfies $A_{\I}$ precondition, $\sigma_i$ produces a result which satisfies
its postcondition, and if (2) the new operational semantics $\sigma_i'$ also
complies with $A_{\I}$.
%
The precondition and the postcondition are parameterized by an abstract state,
so is the compliance property.

\begin{definition}[Operational Semantics
  Compliance] \label{def:freespec:compliance} Let $A$ be an abstract
  specification for an interface $\I$, defined as
  $\langle \Omega, \func{step}, \func{pre}, \func{post} \rangle$,
  $\omega \in \Omega$, then $\sigma \in \Sigma_{\I}$ complies with $A$ in
  accordance with $\omega$ (denoted by $\sigma \models A[\omega]$) iff.
  \[ \forall e \in \I, \func{pre}(e, \omega) \Rightarrow \func{post}(e, x,
    \omega) \wedge \sigma' \models A[\func{step}(e, x, \omega)] \text{ where
    }(x, \sigma') = \sigma(e)
  \]
\end{definition}

Secondly, programs with effects of $C$ make a licit usage of an operational
semantics $\sigma_j \in \Sigma_{\J}$ which complies with $A_{\J}$ if they only
use effects which satisfy $A_{\J}$ precondition.
%
As for the compliance property, correctness is parameterized with an abstract
state.

\begin{definition}[Program With Effects
  Correctness] \label{def:freespec:correctness} Let $A$ be an abstract
  specification for an interface $\I$, defined as
  $\langle \Omega, \func{step}, \func{pre}, \func{post} \rangle$,
  $\omega \in \Omega$, and $\rho \in P_{\I}(\mathcal{A})$, then $\rho$ is
  correct with respect to $A$ in accordance with $\omega$ (denoted by
  $A[\omega] \modelssym \rho$), iff.
  \[
    A[\omega] \mathrel{\reflectbox{$\models$}} \rho \triangleq \left\{
      \begin{array}{lcl}
        \text{True} & \text{ if} & \rho = \func{Pure}(x) \\
        \func{pre}(e, \omega) & \text{ if} & \rho = \func{Request}(e) \\
        \forall \sigma \in \Sigma_{\I} \text{ such that } \sigma \models
        A[\omega], & & \\
        \qquad A[\omega] \modelssym q \wedge A[\omega'] \modelssym f(x) & \text{
                                                                          if} & \rho = q \bind f \\
        \text{where }(x, \_, \omega') =
        \func{run}_{\func{step}_{\J}}(\sigma, q, \omega) & \\
      \end{array}
    \right.
  \]
  % \guillaumerk{franchement, le symbole \protect\reflectbox{$\models$} est
  % vraiment trop proche de $\models$. Je comprends l'idée mais c'est source de
  % confusion. Je choisirai un symbol bien discinct.}
\end{definition}

Every local computation ($\func{Pure}$) is correct with respect to $A$ in
accordance with~$\omega$.
%
A computation which uses an effect $e \in \I$ ($\func{Request}$) is correct with
respect to $A$ in accordance with~$\omega$ if and only if $e$ satisfies the
precondition of $A$ for the abstract state $\omega$.
%
Finally, the chaining of two programs with effects ($\func{Bind}$) is correct
with $A$ in accordance with~$\omega$ if the first program is correct with $A$ in
accordance with~$\omega$, and the second program is correct in accordance with
the abstract state reached after the realization of the first program.

Properties, inferred from an abstract specification, of a correct program with
effects only hold if it is realized by a compliant operational semantics.
%
Besides, we prove that correct programs preserve operational semantics
compliance.

\begin{theorem}[Compliance Preservation]
  Let $A$ be an abstract specification dedicated to an interface $\I$, then
  $\sigma$ a compliant operational semantics for $\I$ produces a compliant
  operational semantics $\sigma'$ when it realizes a correct program $\rho$,
  that is
  \[
    \sigma \models A[\omega] \wedge A[\omega] \modelssym \rho \Rightarrow
    \sigma' \models A[\omega'] \text{ where }\func{run}_{\func{step}}(\sigma,
    \rho, \omega) = (x, \sigma', \omega')
  \]
\end{theorem}

As for interfaces (with $\oplus$) and operational semantics (with $\otimes$), we
have also defined an abstract specification composition operator $\odot$.
%
We do not detail its definition in this article, but it has the significant
property to allow for reasoning about the composition of interfaces and
composition of operational semantics.

\begin{theorem}[Congruent Composition]
  Let $\I$ (respectively $\J$) be an interface.
  %
  Let $A_{\I}$ (respectively $A_{\J}$) be an abstract specification and
  $\sigma_i \in \Sigma_{\I}$ (respectively $\sigma_j \in \Sigma_{\J}$) be an
  operational semantics for this interface.
  \[ \sigma_i \models A_{\I}[\omega_i] \wedge \sigma_j \models A_{\J}[\omega_j]
    \Rightarrow \sigma_i \otimes \sigma_j \models (A_{\I} \odot
    A_{\J})[\omega_i, \omega_j]
  \]
\end{theorem}

% \begin{theorem}[Congruent Lifting]
%   Let $\I$ (respectively $\J$) be an interface. Let $A_I$ (respectively $A_J$)
%   be an abstract specification and $\rho_i \in P_{\I}(\mathcal{A})$
%   (respectively $\rho_j \in P_{\J}(\mathcal{A})$) be an effectful computation
%   which uses this interface.
%   \[ A_I[\omega_i] \modelssym \rho_i \Rightarrow A_I \odot A_J [\omega_i,
%     \omega_j] \modelssym \func{liftl}(\rho_i)
%   \]
%   \[ A_J[\omega_j] \modelssym \rho_j \Rightarrow A_I \odot A_J [\omega_i,
%     \omega_j] \modelssym \func{liftr}(\rho_j)
%   \]
% \end{theorem}

With the Compliance Preservation, we know that as long as we follow the abstract
specification precondition related to the effects we use, compliant operational
semantics keep enforcing the postcondition.
%
With the Compliance Preservation and Congruent Composition, we know we can
reason locally, that is component by component.

\subsection{Proofs Techniques to Show Compliance For Components}
% -----------------------------------------------------------------------------

We have dived into the mechanisms which allow for composing together compliant
operational semantics, but little has been said about how to prove the
compliance property to begin with.
%
In a typical FreeSpec use case, operational semantics are not built as-is, but
rather derived from a component model
(Definition~\ref{def:freespec:derivation}).
%
How to prove the resulting operational semantics complies with an abstract
specification depends on how the component is connected to the rest of the
system.
%
We have already discussed the consequences of the operational semantics
composition operator $\otimes$
(Definition~\ref{def:freespec:semantics-composition}).
%
Notably, a graph of components which contains a cycle, a diamond or a forward
edge cannot be easily modelled and verified in FreeSpec.
%
In its current state, FreeSpec provides some theorems to verify the properties
of a component model in terms of an abstract specification, depending on the
composition pattern.

The most favourable scenario consists of one component which uses many
components, and is only used by one other component.
%
Let $\I$ and $\J$ be two interfaces and let $C$, a component with a set of
possible states $\mathcal{S}$, which exhibits $\I$ and uses $\J$.
%
Let $A_{\I}$ be an abstract specification dedicated to $\I$.
%
Deriving an operational semantics from $C$ which complies with $A_{\I}$ in
accordance with $\omega_i \in \Omega_I$ requires to show the existence of
$s \in \mathcal{S} \text{ and }\sigma_j \in \Sigma_{\J}$ such that
\[ \langle C, s, \sigma_j \rangle \models A_{\I}[\omega_i]. \]
%
However, proving this statement would not be very satisfying, as it ties our
verification results to one specific operational semantics $\sigma_j$, and by
extension one specific component.
%
As a consequence, we define an abstract specification $A_{\J}$ to generalize our
statement and abstracting away $\sigma_j$.
%
We now need to prove it exists $\omega_j \in \Omega_{\J}$ such that given an
operational semantics $\sigma_j$ which complies with $A_{\J}$ in accordance with
$\omega_j$, the operational semantics derived from $C$, $s$ and $\sigma_j$
complies with $A_{\I}$ in accordance with $\omega_i$, that is
\[ \forall \sigma_j \in \Sigma_{\J}\text{, }\sigma_j \models A_{\J}[\omega_j]
  \Rightarrow \langle C, s, \sigma_j \rangle \models A_{\I}[\omega_i]
\]

The combinatorial explosion of cases introduced by $\omega_i$, $s$ and
$\omega_j$, modified as the component handles effects, makes inductive reasoning
challenging.
%
The FreeSpec framework provides a useful theorem to address these challenges,
which leverages a so-called predicate of synchronization.
%
The latter is defined by the user on a case-by-case basis, to act as an
invariant for the induction, and a sufficient condition to enforce compliance.

\begin{theorem}[Derivation Compliance] \label{theorem:der-compliance} Let
  $\func{sync}$, a relation between abstract states of $\Omega_{\I}$ and
  $\Omega_\J$, states of $\mathcal{S}$, be a predicate of synchronization.
  %
  Then, it is expected that, $\forall \omega_i \in \Omega_{\I}$,
  $s \in \mathcal{S}$ and $\omega_j \in \Omega_{\J}$ such that
  $\func{sync}(\omega_i, s, \omega_j)$ holds, then
  $\forall \sigma_j \in \Sigma_{\J}$ such that
  $\sigma_j \models A_{\J}[\omega_j]$ and $\forall e \in \I$ such that
  $\func{pre}_{\I}(e, \omega_i)$,
  \begin{enumerate}
  \item $C$ preserves the synchronization of states, that is
    $\func{sync}(\omega_i', s', \omega_j')$
  \item $C$ is defined in terms of programs with effects which are correct with
    respect to $A_{\J}$ in accordance with $\omega_j$, that is
    $A_{\J}[\omega_j] \modelssym C(e, s)$
  \item $C$ computes a result for $e$ which satisfies $A_{\I}$ postcondition,
    that is $\func{post}_{\I}(e, x, \omega_i)$
  \end{enumerate}
  where
  $((x, s'), \sigma_j', \omega_j') = \func{run}_{\func{step}_{\J}}(\sigma_j,
  C(e, s), \omega_j)$ and $\omega_i' = \func{step}_{\I}(e, x, \omega_i)$.
  %
  Should these three properties be verified, then we show that
  \[ \func{sync}(\omega_i, s, \omega_j) \wedge \sigma_j \models A_{\J}[\omega_j]
    \Rightarrow \langle C, s, \sigma_j \rangle \models A_{\I}[\omega_i].
  \]
\end{theorem}

\begin{example}[MCH Compliance]
  We want to prove we can derive an operational semantics from
  $C_{\mathrm{MCH}}$ (Example~\ref{ex:mch-specs}) which complies with
  $A_{\mathrm{MCH}}$ (Example~\ref{ex:mch-abs-specs}).

  We define
  $A_{\mathrm{DRAM}} \triangleq \langle \Omega_{\mathrm{DRAM}},
  \func{step}_{\mathrm{DRAM}}, \func{pre}_{\mathrm{DRAM}},
  \func{post}_{\mathrm{DRAM}} \rangle$ an abstract specification dedicated to
  $\I_{\mathrm{DRAM}}$ to express the following property: ``\emph{a read access
    to a memory location which belongs to the SMRAM return the value which have
    been previously written at this memory location}.'' In particular,
  $\Omega_{\mathrm{DRAM}} = \Omega_{\mathrm{MCH}}$, i.e. they are two views of
  the SMRAM, as exposed by the DRAM controller or by the MCH.
  %
  In this context, the behaviour of VGA is not relevant. Let $\top$ be the
  abstract specification which has no state and such that its precondition and
  postcondition are always satisfied (meaning every operational semantics always
  complies with it).
  %
  Therefore, the abstract specifications dedicated to the interface used by
  $C_{\mathrm{MCH}}$, that is $\I_{\mathrm{DRAM}} \oplus \I_{\mathrm{VGA}}$, is
  $A_{\mathrm{DRAM}} \odot \top$ whose abstract state is
  $\Omega_{\mathrm{DRAM}}$.

  We define the predicate of synchronization $\func{sync}_{\mathrm{MCH}}$ such
  that
  \[ \func{sync}_{\mathrm{MCH}}(\omega_i, s, \omega_j) \triangleq s = \val{on}
    \wedge \forall l \in \mathpzc{Smram}, \omega_i(l) = \omega_j(l)
  \] Hence, we start our reasoning from a situation where the SMRAM isolation is
  already activated and the states of the two abstract specifications are the
  same, meaning the two views of the SMRAM (as stored in the DRAM, and as
  exposed by the MCH) coincide.
  %
  We prove $\func{sync}_{\mathrm{MCH}}$ satisfies the three premises of the
  Theorem~\ref{theorem:der-compliance}. We conclude we can derive an operational
  semantics from $C_{\mathrm{MCH}}$ which complies with $A_{\mathrm{MCH}}$.
\end{example}

\paragraph{}
%
Another common composition pattern consists of a component which is used by more
than one other component.
%
FreeSpec provides a theorem which allows for extending the result obtained with
the Theorem~\ref{theorem:der-compliance}, in the specific case where concurrent
accesses do not lead to any change of the abstract state.
%
In FreeSpec, two interfaces are assumed to be independent, which means the use
of one does not interfere with the use of the other.
%
This key property allows a FreeSpec user to compose interfaces and operational
semantics together and abstract them away with abstract specifications.
%
With the operational semantics composition
(Definition\,\ref{def:freespec:semantics-composition}), we can specify a tree of
components, where each node, from the root to the leaves, exhibits one interface
and uses as many independent interfaces as it needs.
%
With the abstract specifications
(Definition\,\ref{def:freespec:abstract-specs}), we can abstract away the upper
and lower layers of the tree for each node.
%
This leaves one common pattern we have not covered yet: the concurrent use of
one interface by several components.

Dealing with concurrency in FreeSpec is a challenge in the general case.
%
If two components are using the same functionalities of an interface, there is a
great chance they both have an influence on its abstraction.
%
As a consequence, this scenario implies verifying all the possible effects
interlacing their concurrent uses may induce. It can quickly become unbearable.

Nevertheless, if the use of one component does not interfere with the
abstraction used by another, then from the point of view of the latter, the
verification work is dramatically simplified.
%
This property is not necessarily symmetric.

\begin{definition}[Predicate of Non-Interference]
  Let $\I$ be an interface and
  $A \triangleq \langle \Omega, \func{step}, \mathbb{P}, \mathbb{Q} \rangle$ be
  an abstract specification dedicated to $\I$. Let
  $\func{pnf} : \I \rightarrow \ac{prop}$ be a subset of effects. $\func{pnf}$
  is said to be a predicate of non-interference of $A$ (denoted
  $A \| \func{pnf}$) if and only if \[
    \begin{array}{l}
      \forall \mathcal{A}\text{, } \omega \in \Omega\text{, } i \in
      \Interface{\I}{\mathcal{A}}\text{, }x \in \mathcal{A}\text{, } \\ \qquad
      (\func{pnf}(i) \Rightarrow \mathbb{P}(i, \omega)) \wedge (\func{pnf}(i)
      \wedge \mathbb{Q}(i, x, \omega) \Rightarrow \omega = \func{step}(i, x,
      \omega))
    \end{array}
  \]
\end{definition}

In a similar manner to the predicate of synchronization, FreeSpec provides a
theorem to help and guide the verification work of its users.

\begin{theorem}[Non-Interference and Concurrency]
  Let $\sigma \in \Sigma_{\I}$ be an operational semantics dedicated to
  $\mathcal{I}$. Let $\func{pnf} : \I \rightarrow \ac{prop}$ be a subset of
  effects. Let $\sigma\!\!\downarrow\!\!\func{pnf}$ be the operational semantics
  built upon $\sigma$ which executes arbitrary sequences of effects satisfying
  $\func{pnf}$ between two effects.  We prove that
  \[ A \| \func{pnf} \wedge \sigma \models A[\omega] \Rightarrow
    \sigma\!\!\downarrow\!\!\func{pnf} \models A[\omega]
  \]
\end{theorem}

In other words, a second component which only uses the effects that satisfies
$\func{pnf}$ can use the interface concurrently to a component that abstracts it
away with $A$.

\begin{example}[MCH and IOMMU]
  As pictured in Figure\,\ref{fig:freespec:computing-platform}, the Memory
  controller not only arbitrates the memory accesses of the CPU, but also to
  other hardware components (mostly PCI and PCIe devices).
  %
  One possible predicate of non-interference for $A_{MCH}$ is to deny the IOMMU
  the possibility to perform privileged write, so that only the main CPU could
  do it.
\end{example}

\section{Conclusion}
% =============================================================================
\label{sec:freespec:scale}

For two sections, we have introduced the FreeSpec key definitions and theorems
so that we could model a minimal MCH component and verify its properties in the
presence of a well-behaving DRAM controller.
%
This example has been driven by a real mechanism commonly found inside x86-based
computing platforms.
%
We now discuss how FreeSpec can be leveraged to model and verify larger systems.
% and limitations we anticipate.

The typical workflow of FreeSpec can be summarized as follows: specifying the
interfaces of a system; modelling the components of the system in terms of
programs with effects of these interfaces; identifying the abstract
specifications which express the requirements over each interface; verifying
each component in terms of compliance with these abstract specifications.

Independent groups of people can use FreeSpec to modularly model and verify a
system, as long as they agree on the interfaces and abstract specifications.
%
If, during the verification process, one group finds out a given interface or
abstract specification needs to be updated, the required modifications may
impact its neighbours.
%
For instance, modelling a x86-based computing system, as pictured in
Figure~\ref{fig:freespec:computing-platform}, using FreeSpec requires to take
into account the CPU cache, and to verify it complies with an abstract
specification similar to the one defined in Example~\ref{ex:mch-abs-specs}.
%
Thus, FreeSpec could have helped uncover the SMRAM cache poisoning attack
previously mentioned\,\cite{wojtczuk2009smram,duflot2009smram}, and other
similar architectural attacks.

The abstract specifications are defined in terms of interfaces, i.e.
independently from components.
%
It has two advantages.
%
First, for a given verification problem modelled with a set of abstract
specifications, two components which exhibit the same interface can be proven to
comply with the same abstract specification.
%
In such a case, we can freely interchange these components, and the verification
results remain true.
%
This is useful to consider the challenge posed by components versioning, i.e. a
new version of a component brings new features which could be leveraged by an
attacker.
%
Then, it is possible to verify a given component in terms of several abstract
specifications.
%
This means we can independently conduct several verification works against the
same component.
