\chapter{Intel x86 Hardware and BIOS Background}
\label{chapter:usecase}

\endquote{``\emph{You’re building your own maze, in a way, and you might just
    get lost in it.}''

  \hfill\footnotesize --- Marijn Haverbeke}

\vspace{1cm}\noindent
%
Our motivation to formally specify and verify architectural attacks comes from
our experience with the x86 hardware architecture.
%
Over the past decade, the security of the lowest levels of abstraction (hardware,
firmware, system software) has grown in importance, and several critical
vulnerabilities which fall in our definition of architectural attacks have been
disclosed.
%
While our contributions are intended to be applicable to other hardware
architectures, for purposes of evaluating our work, we have adopted the systemic
approach to apply them to a x86 real example.
%
We have chosen to focus on the \ac{hse} mechanism implemented by the BIOS at
runtime to stay isolated from the rest of the software stack, including the
system software.
%
Because the BIOS is the most privileged piece of software executed by the
hardware architecture, this \ac{hse} mechanism is of key importance.
%
Despite this fact, it has been defeated several times, and therefore, it
illustrates perfectly our motivations.
%
However, it is important to emphasize that other mainstream architecture
(\emph{e.g.}  ARM) work on a similar basis and suffer similar issues.

The rest of this Chapter proceeds as follows.
%
We describe how a typical x86 hardware architecture is organized, and the
consequences of this organization in terms of security
(Section~\ref{sec:usecase:architecture}).
%
We then focus on the key role played by the \ac{bios}, and the security model it
requires so it can play this role (Section~\ref{sec:usecase:firmware}).
%
Once the role of the \ac{bios} has been established, we detail \ac{hse}
mechanisms it implements, and several architectural attacks which have defeated
these \ac{hse} mechanisms in the past (Section~\ref{sec:usecase:hse}).

\section{Hardware Architecture Overview}
\label{sec:usecase:architecture}

Describing hardware architectures in depth is challenging, because they tend to
be made of many interconnected components of various natures.
%
From this perspective, the x86 hardware architecture is a textbook case, and
this is probably best illustrated by the scale of its documentation.
%
At the time of writing this thesis\,\footnote{Spring 2018.}, the \emph{Intel 64
  and IA-32 Architectures Software Developer’s Manual} is 4842 pages long.
%
Executed on the computer used to write the present thesis, the GNU/Linux
command-line application \texttt{lshw} lists about 30 hardware components, which
come with their own documentation, often in the form of large data sheet.

A x86 computing platform is built upon two key components: \acp{cpu} and memory
(\ref{subsec:usecase:cpumem}).
%
The \ac{cpu} communicates with peripherals to interact with the outside world
(\emph{e.g.} another computing platform, a user) (\ref{subsec:usecase:perif}).

\subsection{Processors and Memory}
\label{subsec:usecase:cpumem}

A computer platform goal is to execute programs to perform arbitrary tasks.
%
To that end, it relies on one or more \acp{cpu}.
%
A \ac{cpu} takes so-called ``instructions'' as input, and manipulates its
internal states and data stored in a memory, as output
%
A program is a sequence of instructions, often stored in the same memory as the
data it manipulates.
%
Overall, a \ac{cpu} basically repeats the following task, over and over:

\begin{enumerate}
\item Read the content of its (internal) \emph{program counter} register, and
  interpret it as the address of the next instruction.
%
\item Fetch the content of this address from memory.
%
\item Decode the instruction, that is identified the desired operation to
  perform
%
\item Act accordingly, by modifying its internal state, and interacting with the
  memory.
%
\item Update the content of its \emph{program counter} register according to the
  semantics of the instruction it has executed. Most of the time, it increases
  it to fetch the next instruction, but it can also set it to an arbitrary value
  (\emph{e.g.} with jump instructions).
\end{enumerate}

From the \ac{cpu} perspective, the memory is abstracted into a contiguous array
of storage cells, identified by an address.
%
A \ac{cpu} can interact with the memory by reading or writing to a given
address.
%
In reality, a hardware architecture contains several memories of various natures.
%
The \ac{dram} remains the most important, and is often called the \emph{system
  memory}, but it is not the only memory present in a hardware architecture.
%
Peripherals expose memories too; the latter are used as communication channels
between them and the \acp{cpu}.
%
That is, to ``receives a message'' from a peripheral, a \ac{cpu} reads the
content of the memory it exposed, while it can ``send a message'' by writing to
the same memory.

\paragraph{}
%
Historically, x86 \acp{cpu} were using two distinct memory spaces to communicate
either with the \ac{dram} or with the peripherals, \emph{via} two families of
instructions.
%
Nowadays, the memories exposed by the peripherals are mapped within the same
address space, and accessed with the same instructions.
%
That is, when a \ac{cpu} read or write to an address, the access is
transparently dispatched either to the \ac{dram} or to a peripheral.
%
The first component to intervene in the decision process is the Memory
Controller (formally known as the \emph{northbridge}, and now integrated to the
\ac{cpu} Die).
%
The Memory Controller is connected to the \ac{dram} and to peripherals which
require small latency, such as a graphic card or a ethernet controller.
%
If a given memory access does not target one of its peripherals or the
\ac{dram}, the Memory Controller forwards the memory access to the \ac{pch}
(formally known as the \emph{southbridge}).
%
The \ac{pch} acts as a proxy for the remaining peripherals.

\paragraph{}
%
One important property of x86 hardware architecture is that the memory map,
which is the correspondence between the addresses used by the \ac{cpu} and the
storage cells scattered among the hardware architecture, is dynamically
configurable.
%
As such, determining which hardware component will receive a given memory access
is far from being trivial.

\subsection{Active Peripherals}
\label{subsec:usecase:perif}

It is worth mentioning that, since 2008, Intel embeds the Management Engine, a
processor \emph{inside} the memory controller.
%
The Management Engine executes a complete software stack, and is capable of
interacting with the \ac{dram} as well as other hardware components.
%
Intel leverages the Management Engine to provide out-of-band management
solution, which means it can interact with the rest of the world without the
cooperation of the main \ac{cpu}.
%
Although the Management Engine supposedly operates in a transparent manner from
the \ac{cpu} perspective, we emphasize that a Management Engine vulnerability, a
scenario which is not without precedent, potentially defeats any security
measures implemented at the \ac{cpu} level.

The security threat posed by the Management Engine is not an isolated case.
%
On the contrary, x86 hardware architectures contain several \emph{active}
peripherals.
%
We say a peripheral is active if it can autonomously read and write to the
system memory, using a feature called \ac{dma}.
%
This feature brings an important performance improvement, but it also opens an
important surface of attacks.

Historically, peripherals have been part of the \ac{tcb} of every x86 \ac{hse}
mechanisms, with important consequences on the computing platform security.
%
For instance, Loic Duflot \emph{et al.} have been able to take control of a
network card, because the piece of software responsible for processing network
packets was vulnerable\,\cite{duflot2010network}.
%
Because the network card can perform \ac{dma}, they were able to tamper with the
system software code and data.
%
It has also been repeatedly shown that the various physical interface exposed by
the computer (\emph{e.g.} USB\,\cite{nohl2014badusb},
Thunderbolt\,\cite{hudson2015thunderstrike}, PCI\,\cite{chifflier2013uefi})
could be leveraged to achieve similar goals.

In that respect, the current situation has improved.
%
Modern x86 \acp{cpu} provide a feature called I/O MMU, which allows for
configuring the memory ranges each peripheral can access to.
%
In addition, Intel tends to take rogue peripherals into account when it
conceives new security features.
%
A good example is the \ac{sgx} technology, whose \ac{tcb} is limited to the
\ac{cpu} and its Memory Controller\,\cite{costan2016sgxexplained}.

\subsection{Security Properties}

From a security perspective, the attack surface on x86 computing platform is
large.
%
The different software components which form the software stack are executed by
the same \acp{cpu}, the instructions which form their programs are stored within
the same memories, which they also manipulate concurrently \emph{via} a
configurable memory map.
%
In addition, active peripherals can also access the main memory concurrently
with the \ac{cpu}, and they tend to be part of the \ac{tcb}.
%
As a consequence, most of the \ac{hse} mechanisms implemented in x86 computing
platforms aim to enforce isolation properties, to prevent untrusted software
components to tamper with the execution of trusted ones.
%
These isolation properties can take three forms.

\begin{definition}[Integrity]
  \label{def:usecase:int}
  The trusted software component is assigned a portion of the memory map.
  %
  Untrusted software components cannot tamper with the result of read accesses
  targeting this portion and performed by the trusted software component,
\end{definition}

\begin{definition}[Confidentiality]
  The trusted software component is assigned a portion of the memory map.
  %
  It can hide its secrets inside this portion, and untrusted software components
  cannot get these secrets from the result of a read access.
\end{definition}

Integrity and confidentiality properties have to be considered from an
information flow perspective.
%
The content of specific storage cells inside the hardware architecture is less
relevant than the logical view exposed to the \acp{cpu}.

\begin{definition}[Availability]
Untrusted software components cannot prevent the execution of a trusted
  software component
\end{definition}

On the contrary, there are complete classes of security properties which are not
covered by \ac{hse} mechanisms.
%
The most famous is probably noninterference properties, notably defeated
\emph{via} side-channel attacks (\emph{e.g.} cache-timing attacks). Indeed,
Intel documentation clearly state:

\begin{quote}
  The Intel architecture aims to provide protection against software
  side-channel attacks at the cache line granularity.

  \hfill\small \emph{Intel Software Guard Extensions, Developer Guide}
\end{quote}

Because computer programs rarely fit inside a cache line, preventing
side-channel attacks therefore additional software-based security enforcement
mechanisms.

\section{BIOS Overview}
\label{sec:usecase:firmware}

The \ac{bios} plays a significant role in Intel x86 computing platform.
%
It is the first piece of software executed by the \ac{cpu}, and initiates both
the hardware architecture and the system software execution during the boot
sequence (\ref{subsec:usecase:firm:boot}).
%
At runtime, it remains active to perform various tasks, including and not
limited to platform-specific events, device emulation, \ac{bios} update
management (\ref{subsec:usecase:firm:runtime})
%
As such, it is a natural part of the rest of the software stack \ac{tcb}, and it
can only operate if certain security requirements are met
(\ref{subsec:usecase:firm:sec}).

\subsection{During the boot sequence}
\label{subsec:usecase:firm:boot}

The \ac{bios} program is stored inside a flash memory, a small memory connected
to the \ac{pch} through the Serial Peripheral Interface (SPI) bus on modern x86
computing platform.
%
When the \ac{cpu} is powered up, it is programmed to fetch the code stored at a
hard-coded address within the flash memory.
%
The first task of the \ac{bios} is to initiate the hardware architecture,
starting with the \ac{dram}.
%
Once the hardware components of the computing platform have been initiated, the
\ac{bios} searches for a system software to load into memory.
%
Historically, ``legacy'' \acp{bios} were looking for a Master Boot Record (MBR)
at the beginning of mass storage devices (\emph{e.g.} hard drive, USB stick).
%
The MBR, whose size is limited to 512 bytes, contains a small program to
initiate a loader for the system software.
%
Modern \acp{bios} implement the \ac{uefi}, whose purpose is to standardize the
boot sequence process in order to favour interoperability of \ac{bios}
implementations.
%
In particular, UEFI-compliant \ac{bios} can load so-called UEFI applications of
arbitrary size, leading modern operating systems to be packaged as UEFI
applications.

The \ac{uefi} standard includes several interesting security mechanisms.
%
For instance, it defines a protocol called the Secure Boot, which can be
leveraged to improve the security of the boot sequence.
%
If Secure Boot is enabled, the UEFI-compliant \ac{bios} will only execute
applications which provide an acceptable cryptographic signature, with respects
to a key hierarchy configurable by the computing platform owner.
%
Ironically, the \ac{uefi} standard makes it easier to write portable piece of
software which can be executed prior to any system software.
%
As a consequence, it increases the attack surface of the computing platform in
case of bad \ac{bios} configuration (\emph{e.g.} Secure Boot is disabled).

\subsection{At runtime}
\label{subsec:usecase:firm:runtime}

Once a system software has been selected and loaded into memory (ideally,
without any tampering with the \ac{bios}), the boot sequence ends, and the
runtime begins.
%
At runtime, the system software is in charge of the \ac{cpu} control flow,
meaning it decides which piece of software is executed at a given time.
%
However, the \ac{bios} remains active.

Firstly, it provides a software interface to the system software.
%
Some of these \emph{runtime services}, as they are called by the \ac{uefi}
standard, can be leveraged by the system software as an intermediary layer to
interact with the hardware architecture.
%
In doing so, it reduces the coupling between the system software and the
hardware components.
%
Other runtime services are mandatory gates towards certain computing platform
features.
%
For instance, software update for the \ac{bios} code is performed by the
\ac{bios} itself, so that the latter can validate the validity of the update.

Secondly, the \ac{bios} often needs to operate independently of the system
software.
%
For instance, it manages platform-specific events whose internals are not
publicly documented.
%
Some \acp{bios} also emulate complete hardware devices, in a transparent manner
from the system software perspective.
%
The \ac{bios} autonomy from the system software has important consequences in
terms of security.
%
Software vulnerabilities affecting the \ac{bios} could by used by an
attacker to take complete control over the software stack executed by the
\ac{cpu}.

\subsection{Security Model}
\label{subsec:usecase:firm:sec}

The \ac{bios} is provided by the hardware architecture’s manufacturer.
%
In most cases, it is a proprietary software, and the computer owner has little
control over it.
%
From the manufacturer software stack, the rest of the software stack is
considered untrusted, and the main goal of the \ac{bios} is to keep the computer
in a working state.
%
Indeed, a malicious or erroneous system software could theoretically.
%
The question whether this model benefits the x86 computing platform is out of the
scope of this thesis.
%
We rather focus on its implementation, because of the important consequences in
terms of security if an attacker succeeds in defeating it.

The security model of a x86 \ac{bios} can be divided into two complementary
security properties.

\begin{definition}[BIOS Integrity]
  \label{def:usecase:biosint}
  The \ac{bios} is assigned two memories: the memory flash and a subset of the
  \ac{dram}, and the rest of the software stack cannot tamper with the result of
  read accesses performed by the \ac{bios} which target one of these memories.
\end{definition}

The \ac{bios} should be the only software component with the capability to
modify the memory flash content.
%
This prevents the scenario where an arbitrary system software rewrite the
\ac{bios} code inside the flash memory, then provoke a reboot.
%
Besides, the flash memory cannot be the only memory dedicated to the \ac{bios}.
%
Memory accesses which target the flash memory are slow, as the latter is
connected to the \ac{pch}, behind the Memory Controller.
%
This is why Intel dedicates a portion of the system memory to the \ac{bios}
runtime code, and for understandable reason provides the means to prevent the
system software to tamper with this portion.

\begin{definition}[BIOS Availability]
  \label{def:usecase:biosav}
  If needed, the \ac{bios} can temporarily retrieve the \ac{cpu} control flow,
  without any cooperation required from the system software.
\end{definition}

The system software is untrusted, but it controls the \ac{cpu} control flow.
%
We want to avoid a scenario where an arbitrary system software prevent the
execution of the \ac{bios} at runtime.

\section{BIOS HSE Mechanism and Architectural Attacks}
\label{sec:usecase:hse}

To stay isolated from the rest of the software stack at runtime, the \ac{bios}
implements a \ac{hse} mechanism whose key hardware feature is the \ac{smm}, a
dedicated execution mode of x86 \acp{cpu} (\ref{subsec:usecase:hse:smm}).
%
The \ac{smm} provides the necessary features to enforce both \ac{bios} Integrity
(Definition~\ref{def:usecase:biosint}) and \ac{bios} Availability
(Definition~\ref{def:usecase:biosav}).
%
Despite the key importance of \ac{smm}, several architectural attacks have been
disclosed over the past decade, including the SMRAM Cache Poisoning Attack
(\ref{subsec:usecase:hse:smram}), SENTER Sandman
(\ref{subsec:usecase:hse:sandman}) and Speed Racer
(\ref{subsec:usecase:hse:speed}).

\subsection{System Management Mode}
\label{subsec:usecase:hse:smm}

To handle several software components with different level of privileges, Intel
\acp{cpu} provide several execution modes.
%
An execution mode can be roughly assimilated to a set of hardware capabilities.
%
For instance, in a given execution mode, a \ac{cpu} may refuse to execute
certain assembly instructions, and the software component executed at the time
will not be able to leverage the side effects involved by the execution of these
instructions.
%
Contrary to a common belief, x86 execution modes are not organized in a
linear hierarchy, but are rather a matrix of complementary hardware features:
ring levels, paging configuration, virtualization technologies, etc.
%
Intel describes the \ac{smm} as follows:

\begin{quote}
  \ac{smm} is a special purpose operating mode provided for handling systemwide
  functions like power management, system hardware control, or proprietary
  OEM-designed code.
  %
  It is intended for use only by system firmware, not by application software
  or general-purpose system software.
  %
  \emph{The main benefit of \ac{smm} is that it offers a distinct and easily
    isolated processor environment that operates transparently to the operating
    system or executive and software applications.}

  \hfill \small \emph{Intel 64 and IA-32 Architectures Software Developer’s
    Manual}
\end{quote}

The emphasis is ours, and does not exist in the original document.
%
This sentence roughly corresponds to our definitions of \ac{bios} Integrity and
\ac{bios} Availability.
%
The \ac{smm} requires two additional hardware features: the SMRAM and the
\ac{smi}.

\paragraph{System Management RAM}
%
The SMRAM is the name given by Intel to the subset of the system memory
dedicated to the \ac{smm}.
%
The exact location and size of the SMRAM are architecture dependent.
%
To locate it, the \ac{cpu} has a register named \texttt{SMBASE}, to be
configured by the \ac{bios} during the boot sequence.
%
As its name suggests, the \texttt{SMBASE} value should point to the base of the
SMRAM.

At the beginning of the boot sequence, the SMRAM is left unprotected, meaning
arbitrary memory accesses targeting the SMRAM are authorized.
%
This design has been made to help \ac{bios} initialize the SMRAM content.
%
Once the \ac{smm} code ---the \ac{bios} code intended to be executed at runtime
in \ac{smm}--- has been correctly loaded into the SMRAM, and prior to giving the
\ac{cpu} control flow to the system software, the \ac{bios} has to lock the
SMRAM.
%
A locked SMRAM can only be accessed by a \ac{cpu} in \ac{smm}, and is invisible
to a \ac{cpu} not in \ac{smm}.
%
This access control mechanism is implemented by the Memory Controller.
%
It can be configured by the \ac{bios} during the boot sequence, by setting the
\texttt{D\_LCK} bit of the \texttt{SMRAMC} configuration register.
%
A Memory Controller with the \texttt{D\_LCK} bit set will prevent a \ac{cpu} not
in \ac{smm} to tamper with the SMRAM content.
%
In addition, the \texttt{D\_LCK} cannot be cleared once it has been set, except
by performing a complete reboot of the platform.
%
This leaves no opportunity to the system software to tamper with the SMRAM
content.

\paragraph{System Management Interrupt}

The \ac{smi} is a hardware interrupt which makes the \ac{cpu} ``enters''
\ac{smm}.
%
More precisely, when a \ac{cpu} receives a \ac{smi}, it saves its current state
(\emph{e.g.} its registers, current execution mode, etc.), either in the SMRAM
or, for most recent versions, in dedicated internal registers.
%
Once this preliminary step is done, the \ac{cpu} reconfigures itself;
%
in particular, it sets its program counter register
$\mathtt{SMBASE} + \mathrm{0x8000}$.
%
From this point, the \ac{cpu} is in \ac{smm} and starts to execute what should
be the \ac{smm} code.
%
Once the \ac{smm} code has performed the task it has been requested for, the
\texttt{rsm} instruction can be used.
%
This instruction, which can be used only in \ac{smm}, tells the \ac{cpu} to
restore its previous state.
%
This way, the execution of the pieces of software previously halted by the
\ac{smi} can resume.
%
From the system point of view, it is like if nothing has happened.

\paragraph{Flash Memory Lock-down}
%
The content of the flash memory has to be protected from arbitrary tampering,
similarly to the SMRAM protection.
%
That is, only the \ac{smm} code should be capable of overwriting the content of
the flash memory.
%
This second access control mechanism is implemented by the \ac{pch}.
%
It is configurable \emph{via} the \texttt{BIOS\_CNTL} (\ac{bios} control
register).
%
Two bits of this register are of interest: the \texttt{BIOSWE} (\ac{bios} Write
Enable) bit, and the \texttt{BLE} (\ac{bios} Lock Enable) bit.

The semantics of the \texttt{BIOSWE} and \texttt{BLE} bits is as follows.
%
When the \texttt{BIOSWE} bit is clear, the \ac{pch} only authorizes read accesses to
the Flash Memory.
%
If the \texttt{BIOSWE} bit is set by a \ac{cpu}, the behaviour of the \ac{pch}
depends on the value of the \texttt{BLE} bit.
%
If the \texttt{BLE} bit has been set by the \ac{bios} during the boot sequence,
then the \ac{pch} triggers a \ac{smi}.
%
As a consequence, the \ac{cpu} stops its current execution and enters in
\ac{smm}.
%
This prevents the system software from tampering with the content of the Flash
Memory, even if the \ac{pch} now authorizes write accesses.
%
It is the \ac{smm} code responsibility to clear the \texttt{BIOSWE} bit before
using the \texttt{rsm} instruction.
%
On the contrary, if the \texttt{BLE} bit is not set, setting the \texttt{BIOSWE}
bit will not cause a \ac{smi}.
%
Similarly to the \texttt{D\_LCK} bit of the \texttt{SMRAMC} register, the
\texttt{BLE} bit cannot be cleared without a reboot.

The Flash Memory Lock-down mechanism is often used as a communication channel
between the system software and the \ac{smm} code, in order to initiate a
\ac{bios} update.
%
The system software sets the \texttt{BIOSWE} bit in order to notify the \ac{smm} code
that a \ac{bios} update is available.

\paragraph{}
%
The combination of the SMRAM, the \ac{smi} and the Flash Memory Lock-down
explains why the \ac{smm} is often introduced as the ``most privileged execution
mode'' of a x86 \ac{cpu}.
%
In a nutshell, the \ac{smm} code can do all the things the system software does,
including tampering with memories assigned to the system software.
%
On the contrary, the system software cannot modify neither the SMRAM content nor
the \ac{smm} code stored in the flash memory, and cannot prevent the \ac{smm}
code execution.

\subsection{SMRAM Cache Poisoning Attack} % -------------------------------
\label{subsec:usecase:hse:smram}

Between 1986, when the \ac{smm} has first been introduced, and 2009, it was
believed that the \texttt{SMRAMC} register alone was sufficient to enforce the
Integrity (Definition~\ref{def:usecase:int}) of the SMRAM.
%
Loic Duflot \emph{et al.}\,\cite{duflot2009smram} and Rafal Wojtczuk \emph{et
  al.}\,\cite{wojtczuk2009smram} have independently shown that this belief was
misplaced when they disclosed the \emph{SMRAM Cache Poisoning Attack}.

\paragraph{Cache Memory}

Interacting with the \ac{dram} remains slow, in regard to the speed of a
\ac{cpu}.
%
To improve performance, Intel \acp{cpu} come with several (often three) levels
of caches, from the smaller and quicker, to the bigger and slower.
%
When a \ac{cpu} successfully reads the memory at a given address, it keeps a
copy of the result in its cache.
%
Therefore, the next time it needs to read at this address, it just has to read
its cache.
%
For cache-friendly programs, the gain in performance can be huge.
%
This gain is paid in important increase of complexity.
%
Enforcing coherence between the different levels of cache and the \ac{dram} is
not trivial.

\paragraph{Attack Path}
%
Intel x86 \acp{cpu} provide five different caching strategies (uncacheable,
write combining, write-through, write-back and write-protected).
%
In particular, the write-back strategy aims to reduce the number of write
accesses to the system memory.
%
To that end, \ac{cpu} does not pass write accesses on the system memory if it
can avoid it.
%
The SMRAM Cache Poisoning leverages the write-back strategy of the \ac{cpu}
cache to circumvent the \texttt{D\_LCK} bit protection.
%
The attack proceeds as follows:

\begin{enumerate}
\item Attackers set the cache strategy to be used for the SMRAM addresses to
  write-back.
%
\item They trigger a \ac{smi}, using the x86 hardware architecture mechanisms at
  their disposal
%
\item The \ac{smm} code is executed in SMM, leading the cache to be filled with
  copies of that code
%
\item Attackers issue a memory write access targeting the SMRAM, and because of
  the write-back cache strategy, the \ac{cpu} updates the copies within the
  cache, but does not pass the access to the Memory Controller.
%
\item Attacker trigger another \ac{smi}, and the \ac{cpu} uses the tampered copy
  of the \ac{smm} code inside its cache.
\end{enumerate}
%
This attack is a perfect illustration of an architectural attack:
%
both the Memory Controller and the \ac{cpu} cache work as expected.
%
The former prevents authorized accesses to the SMRAM, that is a subset of the
\ac{dram}, by a \ac{cpu} not in \ac{smm};
%
the former is keeping copies of successful accesses to decrease latency due to memory
accesses.
%
However, the composition of the cache and the memory controller breaks the BIOS
Integrity property.

\paragraph{Countermeasure}
%
The solution implemented by Intel to prevent further exploitation of this
vulnerability was to modify the behaviour of the cache, when the memory accesses
target the SMRAM.
%
Because the SMRAM size and location remain specific to each architecture, this
means it requires an additional step of configurations to tell the cache where
the SMRAM is.
%
As a consequence, the complexity of the \ac{hse} mechanism implemented by the
\ac{bios} at runtime, which was already involving three different hardware
components, has increased.

\paragraph{}
%
The SMRAM Cache Poisoning attack is a textbook case of architectural attacks.
%
It is interesting to notice that six years later, Christopher Domas has
disclosed another x86 vulnerability called Sinkhole\,\cite{domas2015sinkhole},
which relies on a similar approach to trick a \ac{cpu} in \ac{smm} to execute
arbitrary instructions.
%
Both leave the content of the SMRAM in \ac{dram} intact.
%
Both leverage legitimate hardware features.

\subsection{SENTER Sandman}
\label{subsec:usecase:hse:sandman}

In 2015, Xeno Kovah \emph{et al.} have shown it was possible to leverage the
Intel TXT technology to circumvent the Flash Memory Lock-down
protection\,\cite{kovah2015senter}.

\paragraph{Intel TXT}
The Intel Trusted eXecution Technology (TXT) is a recent feature of some x86
\acp{cpu}, whose aim is to reduce the \ac{tcb} of the system software, by removing
most of the \ac{bios} from it.
%
Using a new family of instructions called \texttt{SENTER}, a system software can
initiate an isolated execution environment.
%
The motivation behind TXT is to reduce the size of the architecture \ac{tcb}.
%
In a regular computing platform, the latter includes most of the hardware
components and the \ac{bios} code.
%
With TXT, the goal was to reduce it to the \ac{cpu} itself, which was acting as
a minimal loader for the system software.

\paragraph{Attack Path}
%
The \texttt{SENTER} instruction family had the undesirable side effect of
disabling \acp{smi}.
%
In the context of TXT, this might make sense, as the \ac{bios} is considerered
untrusted.
%
However, this totally contradicts the security model of the \ac{smm} code.
%
Without \ac{smi}, the \ac{bios} Availability property cannot be enforced.
%
In addition, the Flash Memory Lock-down mechanism is deprived of one of its key
hardware features.

\paragraph{Countermeasure}
%
Recent x86 \acp{cpu} do not disable \ac{smi} when using the \texttt{SENTER}
instructions.
%
This leaves the \ac{smm} code inside the TXT \ac{tcb}.
%
This is consistent with the security model of the \ac{smm} code, while the first
version of TXT was clearly misconceived with respect to the existing state of
the hardware architecture.

\subsection{Speed Racer}
\label{subsec:usecase:hse:speed}

There is at least another attack which has defeated the Flash Memory Lock-down
protection.
%
In 2015, Corey Kallenberg \emph{et al.} have shown that the scenario detailed
previously, such that setting \texttt{BIOSWE} was triggering a \ac{smi} to suspend
the execution of the system software, suffered from a race condition in the presence
of a second \ac{cpu}\,\cite{kallenberg2015racecondition}.

\paragraph{Attack Path}
%
On a typical x86 hardware architecture, all the x86 \ac{cpu} of the platform
will \emph{eventually} enter \ac{smm} when a \ac{smi} is triggered.
%
On the contrary, the \texttt{BIOSWE} is set as soon as the \texttt{BIOS\_CNTL}
register is modified.
%
If two \acp{cpu} cooperate, they can benefit from a sufficient window for action
and successfully tamper with the Flash Memory content.
%
The attack proceeds as follows:

\begin{enumerate}
\item One \ac{cpu} tries \emph{ad infinitum} to overwrite the content of the
  Flash Memory. Because the \texttt{BIOSWE} bit is initially clear, the \ac{pch}
  discards its attempts, and the Flash Memory content is correctly protected.
%
\item At the same time, another \ac{cpu} set the \texttt{BIOSWE} bit.
%
\item A \ac{smi} is triggered, but by the time it propagates to the first
  \ac{cpu}, the latter may have successfully tampered with the Flash Memory
  content.
%
\end{enumerate}

\paragraph{Countermeasure}
%
To prevent this race condition, Intel has introduced a new configuration bit to
the \texttt{BIOS\_CNTL} register: the \texttt{SMM\_BWP} (\ac{smm} \ac{bios}
Write Protection).
%
If the \texttt{SMM\_BWP} is set, the \ac{pch} discards any write access which targets
the Flash Memory \emph{unless all processors are in \ac{smm}}.

\section{Conclusion}
\label{sec:usecase:conclusion}

In this Chapter, we have detailed in depth the relevant x86 hardware mechanisms
involved in the \ac{hse} mechanism implemented by the \ac{bios} at runtime to
stay isolated from the system software.
%
In addition, we have presented three architectural attacks, to better illustrate
the threats they pose.
%
We have used the SMRAM Cache Poisoning Attack as a recurring application use
case for our contributions, because it has motivated our will to formally
specify and verify \ac{hse} mechanisms, and it is a good illustration of
architectural attacks.
