%!TEX root = ../main.tex
\chapter{Introduction}
\label{chapter:introduction}

\endquote{``\emph{All problems in computer science can be solved by another
    level of indirection.}''

  \hfill\footnotesize --- David Wheeler}

\vspace{1cm}\noindent
%
To manage complexity, computing platforms are commonly built as successions of
abstraction layers, from the hardware components to high-level software
applications.
%
Each layer leverages the interface of its predecessor to expose a higher-level,
more constrained set of functionalities for its successors.
%
This enables separation of concerns ---each layer encapsulates one dimension of
the overall complexity--- and modularity ---two layers which expose the same
interface can be seamlessly interchanged.
%
The typical computing platform can be broken down to the following layers:
%
\begin{description}
\item [Hardware Architecture]
  %
  A computer consist is made of several inter\-connected, physical hardware
  components.
  %
  Hardware components take many forms and serve as different purposes, from the
  \ac{cpu}, which executes the pieces of software which form the upper layers of
  abstraction, to the various input/output devices, which allow a user to
  interact with the computing platform.
  %
\item [Firmware/BIOS]
  %
  Hardware components often require some firm\-ware, \emph{i.e.} a dedicated
  piece of software, to operate.
  %
  Hardware manufacturers tend to embed some features in their firmware for
  several reasons.
  %
  For starters updating software is easier than updating hardware, as the latter
  often requires a recall.
  %
  Vendors can also implement additional high-level, business focus features in
  their firmware to differentiate from competitors.
  %
  For instance, Intel has started to provide out-of-band management features to
  its processors in 2008\,\cite{ruan2014me}.
  %
  In addition, a piece of firmware is responsible for the initialization of the
  platform as a whole.
  %
  Afterwards, when we refer to this specific type of firmware, we use the term
  \ac{bios}.
  %
  Notably, the \ac{uefi}\,\cite{uefi2017uefi} is a standard whose purpose is to
  describe the role and software architecture for modern \ac{bios}.
  %
\item [System Software]
  %
  The computing environment which is provided by the hardware architecture alone
  is very generic.
  %
  As a consequence, it requires a non-trivial amount of configuration.
  %
  System software leverages this environment to provide high-level interfaces
  (\emph{e.g.} system calls), so that applications can focus on business
  logic. Thus, applications often do not care about which particular hardware
  architecture they are executed on.
  %
  In addition, system software deal with the complexity implied by the
  concurrent execution of several applications.
  %
\item [Applications]
  %
  Applications leverages the high-level interface exposed by system software in
  order to provide a service to the user of the computing platform.
  %
  The previous layers only exist so that applications can be executed.
\end{description}

\begin{figure}
  \centering
  \begin{tikzpicture}
    %% HARDWARE
    \node [draw, inner sep=8pt, text width=100pt, minimum height=40pt, text
    badly centered] (Core) {CPU};%
    \node [draw, inner sep=8pt, left=5pt of Core, text width=60pt, minimum
    height=40pt, text badly centered] (Card) {Graphic Card};%
    \node [draw, inner sep=8pt, right=5pt of Core, text width=60pt, minimum
    height=40pt, text badly centered] (MC) {Memory Controller};%

    \draw [dotted] ([yshift=5pt,xshift=-5pt]Card.north west) --
    ([yshift=5pt,xshift=125pt]MC.north east);%

    %% FIRMWARE
    \node [draw, inner sep=8pt, above=10pt of Card, text width=60pt, minimum
    height=135.5pt, text badly centered, dashed] (CardFW) {};%
    \node [draw, inner sep=8pt, above=10pt of MC, text width=60pt, minimum
    height=135.5pt, text badly centered, dashed] (MCFW) {};%
    \node [draw, inner sep=8pt, above=10pt of Core, text width=100pt, minimum
    height=25pt, text badly centered] (CoreFW) {CPU Microcode};%
    \node [draw, inner sep=8pt, above=5pt of CoreFW, text width=100pt, minimum
    height=25pt, text badly centered] (BIOS) {BIOS};%

    \draw [dotted] ([yshift=71pt,xshift=-5pt]Card.north west) --
    ([yshift=71pt,xshift=125pt]MC.north east);%

    %% OS
    \node [draw, inner sep=8pt, above=10pt of BIOS, text width=100pt, minimum
    height=30pt, text badly centered] (OS) {Operating System};%

    \draw [dotted] ([yshift=111pt,xshift=-5pt]Card.north west) --
    ([yshift=111pt, xshift=125pt]MC.north east);%

    %% Applications
    \node [draw, above=10pt of OS, text width=29, minimum height=30pt, text
    badly centered] (App1) {App};%
    \node [draw, right=5pt of App1, text width=28.5, minimum height=30pt, text
    badly centered] (App2) {App};%
    \node [draw, left=5pt of App1, text width=28, minimum height=30pt, text
    badly centered] (App3) {App};%

    %% LINKS

    \draw [dashed] (Card) -- (CardFW);%
    \draw (Card) -- (Core);%
    \draw (MC) -- (Core);%
    \draw [dashed] (MC) -- (MCFW);%
    \draw (Core) -- (CoreFW);%
    \draw (CoreFW) -- (BIOS);%
    \draw (BIOS) -- (OS);%
    \draw (App1) -- (OS);%
    \draw (App2.south) |- (OS.north);%
    \draw (App3.south) |- (OS.north);%

    %% LAYERS
    \node [right=of MC] (Hardware) {\scshape Hardware};%
    \node [right=of MC, yshift=60pt] (Hardware) {\scshape Firmware};%
    \node [right=of MC, yshift=110pt] (Hardware) {\scshape System Software};%
    \node [right=of MC, yshift=150pt] (Hardware) {\scshape Applications};%
  \end{tikzpicture}

  \caption{Layers of abstractions in a hypothetical computing platform}
  \label{fig:intro:layers}
\end{figure}

Variations of these abstraction layers exist.
%
For instance, for embedded devices, it is common that the system software and
the applications form one single layer.
%
On the contrary, for mainstream computers, the system software can be formed by
an operating system only, or by the combination of one hypervisor and several
operating systems.
%
The latter case is common in the context of cloud computing, where mainstream
hypervisors (\emph{e.g.} Xen\,\cite{barham2003xen},
Hyper-V\,\cite{velte2009hyperv}) provide powerful features such as virtual
machines snapshots or migrations.
%
It is also frequent that application internals are themselves built as
abstraction layers (\emph{e.g.} applicative framework, core logic, plugins,
etc.).

Figure~\ref{fig:intro:layers} pictures the abstraction layers of an hypothetical
---yet inspired by the Intel x86 hardware architecture--- computing platform.
%
The \ac{cpu} is connected to two other hardware components, a graphic card and a
memory controller.
%
These three hardware components execute a software stack each.
%
Some features of the \ac{cpu} are implemented in the form of ``microcode''
programs\,\cite{chen2014microcode}, which determine, in part, the semantics of
instruction set.
%
The \ac{cpu} executes the \ac{bios}, an operating system (system software) and
several applications.
%
Both the graphic card and the memory controller execute their own software
stack, which may be broken down to several abstraction layers as well.

\section{Hardware-based Security Enforcement mechanisms}

From a security perspective, each layer is often more privileged than its
successors.
%
For instance, system software manages the life cycle of the applications, by
actively tampering with their execution.

As a consequence, each layer implicitly trusts its predecessors.
%
On the one hand, it is important to keep this fact in mind when we consider the
security of the computing platform.
%
Trust in lowest levels of abstraction can be misplaced: hardware implants and
backdoors are no fantasy\,\cite{yang2016a2}, the \ac{bios} has been used as an
attack vector to tamper with its execution even after a machine
restart\,\cite{embleton2013smm}, etc.
%
On the other hand, one layer may constrain the execution of its successors
execution, with respect to a targeted security policy.
%
For instance, an operating system shares hardware resources among several
applications, and therefore is able to enforce availability ---fair share of
\ac{cpu} time---, confidentiality and integrity ---exclusive partition of
physical memories--- properties.

Constraining an execution can be achieved in various ways.
%
Concerning the lowest layers of a software stack, the common approach is to rely
on features provided by the hardware architecture.
%
In a nutshell, the main idea is to reduce the hardware capabilities one software
can leverage while it is executed.
%
For instance, system software often leverages among other mechanisms a \ac{mmu}
to partition the system memory.
%
Thus, when an application is executed, it can only access a subset of the system
memory.
%
In addition, the \ac{cpu} can leverage a hardware timer to stop applications'
execution, without the need for these applications to cooperate.

\begin{definition}[Hardware-based Security Enforcement]
  We call \ac{hse} the class of security enforcement mechanisms where a trusted
  software component configure the underlying hardware architecture to constrain
  the execution of untrusted software components with respect to a targeted
  security policy.
\end{definition}

A \ac{hse} mechanism enforces its targeted security property when
%
\begin{inparaenum}[(1)]
\item the trusted software components correctly configure the hardware features
  at their disposal, and
%
\item these features are sufficient to constrain the untrusted software
  execution as expected.
\end{inparaenum}
%
Both remain challenging.

\paragraph{Software Errors.}
%
Vulnerabilities in \ac{hse} mechanism implementations by trusted software
components are often due to some misuse of hardware features.
%
Many facts can explain this state of things.
%
In the past, lower-level pieces of software, such as firmware components, may
not have been conceived and implemented with security as a primary focus.
%
The increasing complexity of hardware architectures can also be held partly
responsible.
%
While one computer can be made of dozens of components, software developers have
to read and understand as many, independent and often large documents of various
forms (\emph{e.g.} data sheets, developer manuals), and they rarely focus on
security.
%
When software developers misunderstand the documentation, as it happened for
instance for the \texttt{MOV SS} and \texttt{POP SS} x86
instructions\,\cite{movsspopss}, the impact in terms of security can be
important.

\paragraph{Hardware Errors.}
%
Over the past decades, vendors have regularly added security features to their
products.
%
Intel, for instance, has notably introduced hardware-based virtualization (VT-x,
VT-d)\,\cite{intel2014manualvt}, dynamic root of trust
(TXT)\,\cite{intel2015txt}, or applicative enclaves
(SGX)\,\cite{intel2014manualsgx,costan2016sgxexplained}.
%
It is important to notice that most of them have been compromised due to
implementation bugs\,\cite{wojtczuk2011txtbug,sang2010iommu}.
%
This is not surprising, as novel hardware features tend to be more and more
complex.
%
Hence, using advanced, novel hardware features, in a security-sensitive context,
may be counterproductive.
%
In addition to these implementation errors, the fact that hardware architecture
often comprises hundreds of features implemented by dozens of interconnected
devices complicate the conception of new hardware features.
%
Indeed, the latter should not interfere with the security properties enforced by
the features which were present before.
%
For instance, the Flash Memory (where lives the \ac{bios} code) is supposedly
protected against arbitrary write accesses from system software.
%
This protection relies on a particular hardware interrupt.
%
This did not prevent Intel to introduce TXT\,\cite{intel2015txt}, a novel
security mechanism which had the particular side effect of disabling this
hardware interrupt\,\cite{kovah2015senter}.
%
This corresponds to the class of compositional
attacks\,\cite{wing2003compositionalattack}.

\begin{definition}[Compositional Attack]
  Compositional attacks is the class of security vulnerabilities, where each
  component is working as expected in isolation, yet their composition creates
  an attack path which prevent end-to-end security enforcement.
\end{definition}

In the context of \ac{hse} mechanisms, this means it is possible for untrusted
software components to leverage one hardware components to defeat a \ac{hse}
mechanism implemented to constrain its execution.
%
Compositional attacks are due to a flaw in the specifications of the computing
platform.
%
As such, they precede implementation errors, and their countermeasures often
require a change in the hardware interface.
%
To prevent them, it is mandatory to reason about the computing platform as a
whole.

\section{Formal Verification of HSE mechanisms}
\label{sec:intro:verif}

The important impact of previously disclosed compositional attacks have
motivated our will to formally specify HSE mechanisms.
%
We believe this would benefit both hardware designers and software developers.
%
Firstly, a formal specification of HSE mechanisms can be leveraged as a
foundation for a systemic approach to verify hardware specifications.
%
For each novel hardware feature introduced, it would be necessary to check that
the previous proofs hold, meaning this feature does not introduce any
compositional attack.
%
Secondly, it provides unambiguous specifications to firmware and system software
developers, in the form of a list of requirements to comply with.
%
We believe these specifications can be a valuable addition to the existing
documentation, because they gather at one place information that is normally
scattered across many documents which sometimes suffer from lack of security
focus.

To specify a HSE mechanism, we have to model the hardware architecture and the
scale of the task represents an important challenge.
%
Compositional attacks may com from unsuspected places, with no apparent link
with the considered security mechanism.
%
For instance, the SENTER Sandman attack\,\cite{kovah2015senter} leveraged a
dedicated execution mode of x86 \acp{cpu} to disable the protection of the flash
memory wherein the \ac{bios} code is stored.
%
As a consequence, it is necessary to consider the whole computing platform.
%
At the same time, some components are individually complex:
%
the Intel Architectures Software Developer Manual\,\cite{intel2014manual} is
4842 pages long;
%
the Memory Controller Hub datasheet\,\cite{intel2009mch} is 430 long;
%
the Platform Controller Hub datasheet\,\cite{intel2012pch} is 988 pages long.
%
In addition, new hardware components and new versions of already existing
components are frequently released.
%
Also, the same
hardware component can be found in different hardware architecture to play a
similar role.
%
For instance, the Trusted Platform Module (TPM) can be found in a vast variety
of products.
%
As a consequence, the more modular our models and proofs are, the more
practicable our approach becomes.
%
Otherwise, each modification of the hardware architecture can have an important
impact on the proofs already written.

\paragraph{}
%
While we have tried to propose generic formalisms which can potentially be
applied to large ranges of problems, we have adopted the systemic approach to
apply them to the x86 hardware architecture.
%
Because of its predominant position on the personal computer market, the x86
hardware architecture has been intensively studied.
%
Our decision to explore this research field was based on our experience with
several compositional attacks which have affected x86-based computing platform
x86 hardware architecture.
%
We have implemented our proofs of concepts in the Coq proof assistant.
%
Our choice is motivated by the following reasons:
%
\begin{itemize}
\item {\scshape Gallina}, the specification of Coq, is an expressive formal
  language, that combines both a higher-order logic and Ã  powerful dependent
  type system, while {\scshape Ltac}, the proof tactic language of Coq, enables
  powerful automation features.
  %
  This suits well for specifying security properties to be enforced by HSE
  mechanisms, as they can take many forms.
\item The extraction mechanism of Coq allows for transpiling formal
  specifications written in {\scshape Gallina} to OCaml, meaning we can write
  \emph{executable specifications}.
  %
  In theory, we can leverage this feature to validate a model against a real
  implementation.
  %
  Because we focus on products which already exist, rather to intervene prior to
  their implementation, this possibility is worth taking into account.
\end{itemize}

\section{Contributions and Outline}

Our works fall within a context where the security of lower levels of
abstraction (\emph{e.g.} hardware components, firmware) grows in importance.
%
In Chapter~\ref{chapter:usecase}, we describe in more detail the x86 hardware
architecture, and a selection of representative compositional attacks which have
been disclosed over the past decade.
%
In Chapter~\ref{chapter:relatedwork}, we revisit existing works and approaches
in line with the two challenges we tackle in this thesis, that is:
%
\begin{inparaenum}[(1)]
\item formally specifying and verifying \ac{hse} mechanisms against a hardware
  model, and
%
\item modularly defining hardware models in terms of compositions of
  sub-components, with the objective of scaling to realistic ---that is, large
  and complex--- hardware architectures.
\end{inparaenum}

In Chapter~\ref{chapter:speccert}, we present a generic formalism to specify and
verify against a hardware model HSE mechanism.
%
In Chapter~\ref{chapter:speccert2}, we leverage our formal
definition to reason about HSE mechanisms which isolate software components from
each other within a software stack.
%
We have implemented SpecCert, a framework for the Coq proof assistant based on
this formalism. In addition, we have implemented {\scshape Minx86}, a minimal
x86 model, and we have verified a HSE mechanism implemented by x86 BIOSes
against {\scshape Minx86}.
%
This HSE mechanism relies on a high-privileged execution mode of x86 \acp{cpu}
called the System Management Mode\,\cite{intel2014manual}.
%
This work has been presented at the $21^{th}$ International Symposium on Formal
Methods (FM2016)\,\cite{letan2016speccert}.

In Chapter~\ref{chapter:freespec}, we present a systemic approach to modularly
specify and verify systems organized as trees of components.
%
We apply ideas from verification of computer programs with side effects to the
domain of component-based modelling. The resulting approach can be used both for
verifying the composition of hardware components and software components alike.
%
In addition, we have developed FreeSpec, a framework for the Coq proof
assistant.
%
FreeSpec provides the necessary definitions and theorems to specify components,
and automation features to guide their verification.
%
This work has been presented at the $22^{th}$ International Symposium on Formal
Methods (FM2018)\,\cite{letan2018freespec}.

Finally, we conclude this thesis in Chapter~\ref{chapter:conclusion}, where we
suggest some possible directions for future works.
