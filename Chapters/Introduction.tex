\chapter{Introduction} \label{chapter:introduction}

\endquote{``\emph{All problems in computer science can be solved by another
    level of indirection.}''

  \hfill\footnotesize --- David Wheeler}

\vspace{1cm}\noindent
%
To manage complexity, computing platforms are commonly built as successions of
abstraction layers, from the hardware components which form a computer up to
high-level software applications.
%
Each layer leverages the interface of its predecessor to expose a higher-level,
more constrained set of functionalities for its successors.
%
This enables separation of concerns ---each layer encapsulates one dimension of
the overall complexity--- and modularity ---two layers which expose the same
interface can be seamlessly interchanged.
%
The typical computing platform can be broken down to the following layers:
%
\begin{description}
\item [Hardware Architecture]
  %
  A computer is made of physical, inter-connected hardware components.
  %
  Hardware components take many form and serve as many purposes, from the
  \ac{cpu} which executes the pieces of software which form the upper layers of
  abstraction, to the various input/output devices which allow a user to
  interact with the computing platform.
  %
\item [Firmware/BIOS]
  %
  Hardware components often require a dedicated piece of software, called its
  firmware, to operate.
  %
  Updating a piece of software is easier than updating a piece of hardware, as
  the latter often requires a recall.
  %
  Vendors can also implement high-level, business focus features to act as sell
  arguments.
  %
  For instance, Intel has started to provide out-of-band management features to
  its processors in 2008.
  %
  In addition, the hardware architecture as a whole is almost always provided
  with a dedicated piece of software which in particular deals with the
  initialization of the computer.
  %
  Afterwards, when we refer to this ``global'' firmware, we use the term
  \ac{bios}, whereas firmware is used to designate a piece of software tied to a
  particular hardware component.
  %
\item [System Software]
  %
  The computing environment provided by the hardware architecture alone is very
  generic.
  %
  As a consequence, it requires a non-trivial amount of configuration.
  %
  A system software leverages this environment to provide high-level interfaces
  (\emph{e.g.} system calls), so that applications can focus on business logic,
  and in many case do not care about which particular hardware architecture they
  are executed on.
  %
  In addition, mainstream system software deal with the complexity implied by
  the concurrent execution of several applications.
  %
\item [Applications]
  %
  The previous layers only exist so that applications can be executed.
  %
  Thanks to the principle of separation of concerns, they delegate the hardware
  configuration and management to the lower layers of abstraction.
\end{description}

Variations of these abstraction layers exist.
%
For instance, for embedded devices, it is common that the system software and
the applications form one layer.
%
On the contrary, for mainstream computers, the system software can be formed by
an operating system only, or by the combination of one hypervisor and several
operating systems.
%
The latter case is common in the context of cloud computing, as modern
hypervisors bring powerful features such as virtual machines snapshots or
migrations.
%
It is also frequent that application internals are themselves built as
abstraction layers (\emph{e.g.} applicative frawework, core logic, plugins).

\section{Hardware-based Security Enforcement mechanisms}

From a security perspective, each layer is often more privileged than, and
therefore implicitly trusted by, its successors:
%
the hardware architecture executes the hardware components' firmware, the
software system and the applications, and hardware implants and backdoors are no
fantasy\,\cite{yang2016a2};
%
the \ac{bios} initiates the execution of the system software, and has been used
as an attack vector to tamper with its execution even after a machine
restart\,\cite{embleton2013smm};
%
the operating system manages the applications life cycle, and actively tamper
with their execution (\emph{e.g.} dynamic linking, system calls).
%
One layer may constrain its successors' execution, with respect to targeted
security properties.
%
For instance, an operating system shares hardware resources among several
applications, and therefore is able to enforce availability ---fair share of
\ac{cpu} time---, confidentiality and integrity ---exclusive partition of
physical memories--- properties.

Constraining one's execution can be achieved in various ways.
%
Concerning the lowest layers of a software stack, the common approach is to rely
on features provided by the hardware architecture.
%
In a nutshell, the main idea is to reduce the hardware capabilities one software
can leverage while it is executed.
%
For instance, mainstream systems software leverage, among others mechanisms, a
\ac{mmu} to partition the system memory.
%
Thus, when an application is executed, it can only access a portion of the
system memory.
%
In addition, the \ac{cpu} can leverage a hardware timer to stop applications'
execution, without the need for these applications to cooperate.

\begin{definition}[Hardware-based Security Enforcement]
  We call \ac{hse} the class of security enforcement mechanisms where a trusted
  software component configure the underlying hardware architecture to constrain
  the execution of untrusted and potentially arbitrary software components.
\end{definition}

A \ac{hse} mechanism enforces its targeted security property when the trusted
software components correctly configure the hardware features at their disposal,
and these features are sufficient to constrain the untrusted software execution
as expected.
%
Both remain challenging.

\paragraph{Software Errors.}
%
It has been repeatedly shown that vendors were not always correctly taking
advantage of important hardware features at their disposal.
%
These lacks of hardware configuration put the affected computing platforms at
risk.
%
Many security vulnerabilities disclosed over the years have been the result of a
misconfiguration of hardware features by key software
components\,\cite{bulygin2014bios}.
%
Many facts can explain this state of things.
%
In the past, lower-level pieces of software, such as firmware components, may
not have been conceived and implemented with security as a primary focus.
%
The increasing hardware architectures' complexity can also be held partly
responsible.
%
While one computer can be made of dozens of components, software developers have
to read and understand as many, independent and often large documents of various
form (\emph{e.g.} datasheets, developer manuals), and they rarely focus on
security.
%
When software developers misunderstand the documentations, as it happened for
instance for the \texttt{MOV SS} and \texttt{POP SS} x86
instructions\,\cite{movsspopss}, the impact in terms of security can be
important.

\paragraph{Hardware Errors.}
%
Over the past decades, vendors have added many security features to their
products.
%
Intel, for instance, has notably introduced hardware-based virtualization (VT-x,
VT-d), dynamic root of trust (TXT), or applicative enclaves (SGX).
%
It is important to notice that most of them have been compromised due to
implementation bugs\,\cite{wojtczuk2011txtbug,sang2010iommu}.
%
This is not surprising, as novel hardware features tend to be more and more
complex.
%
Hence, using advanced, novel hardware features, in a security-sensitive context,
may be counterproductive.
%
In addition to these implementation errors, the fact that hardware architecture
often comprise hundreds of features implemented by dozens of interconnected
devices complicates the conception of new hardware features.
%
Indeed, the latter should not interfere with the security properties enforced by
the features which were present before.
%
For instance, the SPI Flash (where lives the \ac{bios} code) is supposedly
protected against arbitrary write from system software.
%
This protection relies on a particular hardware interrupt.
%
This did not prevent Intel to introduce TXT, a novel security mechanism which
had the particular side-effect of disabling this hardware interrupt.

\begin{definition}[Architectural Attack]
  We call Architectural Attacks the class of security vulnerabilities, where
  each component is working as expected, yet their composition creates an attack
  path an untrusted software component can leverage to defeat a \ac{hse}
  mechanism implemented to constrain its execution.
\end{definition}

Architectural attacks result in a flaw in the specifications of the computing
platform.
%
As such, they precede implementation errors, and their countermeasure often
require a change in the hardware interface.
%
To prevent them, it is mandatory to reason about the computing platform as a
whole.

\section{Formal Verification of HSE mechanisms}

The important impact of previously disclosed architectural attacks have
motivated our will to formally specify HSE mechanisms.
%
We believe this would benefit both hardware designers and firmware and system
software developers.
%
Firstly, a formal specification of HSE mechanisms can be leveraged as a
foundation for a systemic approach to verify hardware specifications.
%
For each novel hardware feature introduced, it would be necessary to check that
the previous proofs hold, meaning this feature does not introduce an
architectural attack.
%
Secondly, it provides unambiguous specifications to software developers.
%
We believe these specifications can be a valuable addition to the existing
documentations, because they gather at one place information that are normally
scattered across many documents.

To specify a HSE mechanism, we have to model the hardware architecture, and the
scale of the task represents an important challenge.
%
Because architectural attacks often come from unsuspected places, it is
necessary to consider the whole computing platform; at the same time, many
components are individually complex.
%
In addition, new hardware components are frequently released, and the same
hardware component can be found in different hardware architecture to play a
similar role.
%
As a consequence, the more modular our models and proofs are, the more
practicable our approach becomes.

\paragraph{}
%
While we have tried to propose generic formalisms which can potentially be
applied to large ranges of problem, we have adopted the systemic approach to
apply them to the x86 hardware architecture.
%
Because of its predominant position on the personal computer market, the x86
hardware architecture have been intensively studied.
%
Our decision to explore this research field was based on our experience with
several architectural attacks which have affected x86-based computing platform
x86 hardware architecture.
%
We have implemented our proofs of concept in the Coq proof assistant.
%
Our choice is motivated by the following reasons:
%
\begin{itemize}
\item {\sc Gallina}, the specification of Coq, is an expressive formal language,
  that combines both a higher-order logic and Ã  powerful dependent type system,
  while {\sc Ltac}, the proof tactic language of Coq, enables powerful
  automation features.
  %
  This suits well for specifying security properties to be enforced by HSE
  mechanisms, as they can take many form.
\item The extraction mechanism of Coq allows for transpiling formal
  specifications written in {\sc Gallina} to OCaml, meaning we can write
  \emph{executable specifications}.
  %
  In theory, we can leverage this feature to validate a model against a real
  implementation.
  %
  Because we focus on already existing product, rather to intervene prior to
  their implementation, this possibility is worth taking into account.
\end{itemize}

\section{Contributions and Outline}

Our works fall within a context where the security of lower levels of
abstraction grows in importance.
%
In Chapter~\ref{chapter:usecase}, we describe in more detail the x86 hardware
architecture, and a selection of representative architectural attacks which have
been disclosed over the past decade.
%
In Chapter~\ref{chapter:relatedwork}, we revisit existing works and approaches
in line with the two challenges we tackle in this thesis, that is:
%
\begin{inparaenum}[(1)]
\item formally specifying and verifying \ac{hse} mechanisms against a hardware
  model, and
%
\item defining hardware models which can remain exploitable in presence of large
  architecture hardware.
\end{inparaenum}

In Chapter~\ref{chapter:speccert}, we present a generic formalism to specify and
verify against a hardware model HSE mechanisms whose purpose is to isolate
trusted software components execution from the rest of the software stack.
%
We have implemented SpecCert, a framework for the Coq proof assistant based on
this formalism. In addition, we have implemented {\sc Minx86}, a minimal x86
model, and we have verified a HSE mechanism implemented by x86 BIOSes.
%
This work has been presented at the $21^{th}$ International Symposium on Formal
Methods (FM2016)\,\cite{letan2016speccert}.

In Chapter~\ref{chapter:freespec}, we present a systemic approach to modularly
specify and verify large systems, organized as trees of components.
%
We apply ideas from verification of computer programs with side-effects to the
domain of component-based modelling, and the resulting approach can be used both
for verifying the composition of hardware components and software components
alike.
%
In addition, we have developed FreeSpec, a framework for the Coq proof
assistant.
%
FreeSpec provides the necessary definitions and theorems to specify components,
and automation features to guide their verification.
%
This work has been presented at the $22^{th}$ International Symposium on Formal
Methods (FM2018)\,\cite{letan2018freespec}.

Finally, we conclude this thesis in Chapter~\ref{chapter:conclusion}, where we
suggest some possible directions for future works.
