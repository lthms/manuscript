\chapter{A Formal Definition of HSE Mechanisms in Coq}
\label{appendix:speccert}

This Appendix presents an implementation of the formal definition of HSE
mechanisms detailed in Chapter~\ref{chapter:speccert}, and follows a similar
outline.
%
The main purpose of this development is to provide rigorous, machine-checked
proofs of the lemmas and theorems discussed in the Chapter.
%
We assume the reader is familiar with Coq, and we discuss several key fragments
of the development.

\section{Hardware Model}

\subsection{Definition}

A hardware model in our formalism is a tuple
$\langle H, L_S, L_H, \rightarrow \rangle$
(Definition~\ref{def:speccert:model}), with $\rightarrow$ being a predicate on
$H \times (L_S \uplus L_H) \times H$.

The three sets $H$, $L_S$ and $L_H$ are introduced as variables of our
development.
%
This means they are implicit arguments of any further definition which uses
them.

\inputminted[gobble=2,firstline=2,lastline=2]{coq}{Listings/SpecCert.v}

The disjoint union $\uplus$ is modelled through a dedicated inductive type
called \texttt{label}.

\inputminted[gobble=2,firstline=4,lastline=8]{coq}{Listings/SpecCert.v}

Because $H$, $L_S$ and $L_H$ are \emph{implicit} arguments of our development, a
hardware model can be reduced to its relation transition~$\rightarrow$.

\inputminted[gobble=2,firstline=10,lastline=12]{coq}{Listings/SpecCert.v}

A transition in our formalism is a tuple $(h, l, h')$ which satisfies the
transition relation of the model.
%
Subsets in Coq are usually modelled using so-called sigma-type:
%
\texttt{\{ x: A | P x \}} is the subset of elements of type \texttt{A} which
satisfy the predicate \texttt{P}.
%
We define \texttt{transition m}, the set of transitions of a model \texttt{m},
using a sigma-type.

\inputminted[gobble=2,firstline=29,lastline=32]{coq}{Listings/SpecCert.v}

Because {\textsc Gallina} is a strongly-typed language, manipulating a sigma-type
can be cumbersome.
%
In particular, there is no implicit coercion from \texttt{\{ x: A | P x \}} to
\texttt{A} by default.
%
The function \texttt{proj1\_sig} can be used to explicitly coerce a sigma-type
value, and we leverage the \texttt{Notation} feature of Coq, in order to ease
the coercion.

\inputminted[gobble=2,firstline=34,lastline=35]{coq}{Listings/SpecCert.v}

That is, when we write \texttt{\#x}, Coq will unwrap the sigma-type.

\subsection{Traces}

The next step is to model traces (Definition~\ref{def:speccert:trace}).
%
We first introduce \texttt{sequence}, a parameterized type which cannot be
empty.
%
This simplifies several definitions, such as \texttt{init} (which returns the
initial state of a trace).

\inputminted[gobble=2,firstline=39,lastline=46]{coq}{Listings/SpecCert.v}

Not all sequences are traces, as a trace is a sequence where, given two
consecutive transitions, the initial state of the second one is the resulting
state of the first.
%
Similarly to the \texttt{transition} type, we define \texttt{trace} with a
sigma-type.
%
To define the predicate to distinguish between valid and invalid trace, we first
define \texttt{init} and \texttt{trace} as functions on \texttt{sequence
  (transition~m)}, with the set of transitions returned by \texttt{trace} is
modelled as a predicate on \texttt{transition m}.
%
Then, we define \texttt{is\_trace}, an inductive predicate on \texttt{sequence
  (transition~m)}.

\inputminted[gobble=2,firstline=62,lastline=71]{coq}{Listings/SpecCert.v}

Finally, we use the \texttt{is\_trace} predicate to define \texttt{trace m}.

\inputminted[gobble=2,firstline=73,lastline=76]{coq}{Listings/SpecCert.v}

\subsection{Security Policies}

We have detailed how security policies can be modeled in transition systems, in
Subsection~\ref{subsec:sota:security} for the general case and in
Subsection~\ref{subsec:speccert:security} for the context of HSE mechanisms.
%
A security policies is either a predicate on sets of traces, a predicate on
traces or a predicate on transitions.
%
In this development, we keep the former (predicate on sets of traces) as the
generic definition.

\inputminted[gobble=2,firstline=90,lastline=92]{coq}{Listings/SpecCert.v}

We then express the two latter (predicate on traces, predicate on transitions)
as particular sub-cases of this generic definition.

\inputminted[gobble=2,firstline=94,lastline=99]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=101,lastline=110]{coq}{Listings/SpecCert.v}

\section{HSE Mechanisms}

We now give a formal definition of HSE mechanisms in the Coq theorem prover,
as stated in Definition~\ref{def:speccert:hse}.

\subsection{Definition and HSE Laws}

First, we introduce an helper definition to easily express predicates of the
form \( l \in L_S \Rightarrow P(l) \).

\inputminted[gobble=2,firstline=112,lastline=121]{coq}{Listings/SpecCert.v}

The \texttt{if\_software} allows for hiding the pattern matching that is
necessary to express various definitions of our theory of HSE mechanisms.
%
Then, we define a type for HSE mechanisms using the Coq \texttt{Record} syntax,
as follows.

\inputminted[gobble=2,firstline=123,lastline=139]{coq}{Listings/SpecCert.v}

By making the two laws part of the HSE mechanisms definition, we ensure that no
inconsistent HSE mechanism can be defined in Coq.

\subsection{Trace Compliance}

\inputminted[gobble=2,firstline=147,lastline=156]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=158,lastline=182]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=184,lastline=229]{coq}{Listings/SpecCert.v}

\subsection{HSE Mechanism Correctness}

\inputminted[gobble=2,firstline=231,lastline=236]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=238,lastline=260]{coq}{Listings/SpecCert.v}

\subsection{HSE Mechanism Composition}

\inputminted[gobble=2,firstline=401,lastline=407]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=409,lastline=422]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=423,lastline=427]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=428,lastline=443]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=471,lastline=511]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=513,lastline=536]{coq}{Listings/SpecCert.v}

\section{Case Study: Code Injection Policies}

\subsection{The Software Stack}

\inputminted[gobble=2,firstline=262,lastline=269]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=271,lastline=272]{coq}{Listings/SpecCert.v}

\subsection{Code Injection}

\inputminted[gobble=2,firstline=338,lastline=344]{coq}{Listings/SpecCert.v}

\subsection{Code Injection Policies}

\inputminted[gobble=2,firstline=274,lastline=281]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=346,lastline=352]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=538,lastline=544]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=546,lastline=553]{coq}{Listings/SpecCert.v}

\inputminted[gobble=2,firstline=555,lastline=583]{coq}{Listings/SpecCert.v}