%!TEX root = ../main.tex
\chapter{Intel x86 Architecture and BIOS Background}
\label{chapter:usecase}

\endquote{``\emph{You’re building your own maze, in a way, and you might just
    get lost in it.}''

  \hfill\footnotesize --- Marijn Haverbeke}

\vspace{1cm}\noindent
%
Our motivation to formally specify and verify \ac{hse} mechanisms comes from
various architectural attacks targeting the x86 hardware
architecture\,\cite{duflot2009smram,wojtczuk2009smram,kallenberg2015racecondition,domas2015sinkhole,kovah2015senter}.
%
Besides, Intel has introduced several \ac{hse} mechanisms over the past decades:
hardware-based virtualization (VT-x, VT-d)\,\cite[Volume 3, Chapter
23]{intel2014manual}, dynamic root of trust (TXT)\,\cite{intel2015txt}, or
applicative enclaves (SGX)\,\cite[Volume 3, Chapter
36]{intel2014manual}\cite{costan2016sgxexplained}.
%
From a market share perspective, x86 \acp{cpu} are widely used for laptops,
desktops and servers.
%
For these reasons, we have evaluated our approaches against the x86 hardware
architecture.
%
However, our contributions are intended to be applicable to other hardware
architectures.
%
We have chosen to focus on the \ac{hse} mechanism implemented by the BIOS at
runtime to stay isolated from the rest of the software stack, including the
system software.
%
Because the BIOS is the most privileged piece of software executed by the
hardware architecture, this \ac{hse} mechanism is of key importance.
%
Despite this fact, it has been the object of several architectural
attacks\,\cite{duflot2009smram,wojtczuk2009smram,domas2015sinkhole}, and
therefore, it illustrates perfectly our motivations.
%
However, it is important to emphasize that other mainstream architecture
(\emph{e.g.}  ARM) work on a similar basis and potentially suffer similar
issues.

The rest of this Chapter proceeds as follows.
%
We describe how a typical x86 hardware architecture is organized, and the
consequences of this organization in terms of security
(Section~\ref{sec:usecase:architecture}).
%
We then focus on the key role played by the \ac{bios}, and the security model it
requires so it can play this role (Section~\ref{sec:usecase:firmware}).
%
Once we have established the role of the \ac{bios}, we detail \ac{hse}
mechanisms it implements, and several architectural attacks which have defeated
these \ac{hse} mechanisms in the past (Section~\ref{sec:usecase:hse}).

\section{Introduction to x86 Architecture Security}
\label{sec:usecase:architecture}

Describing hardware architectures in depth is challenging, because they tend to
comprise many interconnected components of various natures.
%
The x86 hardware architecture is a perfect illustration of this, and this is
probably best illustrated by the scale of its documentation.
%
At the time of writing this thesis\,\footnote{Spring 2018.}, the \emph{Intel 64
  and IA-32 Architectures Software Developer’s Manual} is 4842 pages long.
%
Executed on the computer used to write the present thesis, the GNU/Linux
command-line application \texttt{lshw} lists about 30 hardware components, which include a hard drive, a keyboard, a trackpad, an audio controller, an
integrated graphic card. Several come with their own documentation, often
in the form of large datasheet.

\subsection{Basics of x86 Architecture}

A simplified x86 hardware architecture is pictured in
Figure~\ref{fig:usecase:x86arch}.
%
We now describe how the different hardware components are integrated together to
form a typical x86 computing platform, from the processor which executes
software components to various peripherals which allows the system to interact
with the rest of the world.

\begin{figure}
  \centering
  \begin{tikzpicture}
    \node [draw, inner sep=25pt] (MCH) {Processor};%

    \node [draw, inner sep=8pt, right=15pt of MCH, yshift=-20pt, text badly
    centered, text width=65pt] (DRAM) {DRAM Controller};%
    \node [draw, inner sep=8pt, right=15pt of MCH, yshift=20pt, text badly
    centered, text width=65pt] (Display) {Display Controller};%

    \draw (MCH.east) |- (Display.west);%
    \draw (MCH.east) |- (DRAM.west);%

    \node [draw, inner sep=8pt, left=15pt of MCH, text width=50pt, text badly
    centered] (PCIe) {PCI Express Controller};%

    \draw (PCIe) -- (MCH);%

    \node [draw, below=30pt of MCH, inner sep=40pt, text badly centered] (PCH)
    {PCH};%

    \draw (MCH) -- (PCH);%

    \node [draw, inner sep=5pt, below=10pt of PCH, text width=55pt,
    xshift=-55pt, text badly centered] (Flash) {Flash Memory};%
    \draw ([xshift=-10pt]PCH.south) |- (Flash.east);%

    \node [draw, inner sep=10pt, below=10pt of PCH, text width=25pt,
    xshift=55pt, text badly centered] (TPM) {TPM};%
    \draw ([xshift=10pt]PCH.south) |- (TPM.west);%

    \node [draw, inner sep=10pt, yshift=25pt, left=20pt of PCH, text width=65pt,
    text badly centered] (USB) {USB Controller};%

    \node [draw, inner sep=10pt, yshift=-25pt, left=20pt of PCH, text
    width=65pt, text badly centered] (PCI) {PCI Controller};%

    \draw (PCH.west) |- (USB.east);%
    \draw (PCH.west) |- (PCI.east);%

    \node [draw, inner sep=10pt, right=20pt of PCH, text badly centered, text
    width=50pt] (HD) {Hard Drive Controller};%

    \draw (PCH) -- (HD);%
  \end{tikzpicture}

  \caption{High-level view of the x86 hardware architecture}
  \label{fig:usecase:x86arch}
\end{figure}

\paragraph{Processor, Architecture and Microarchitecture.}
%
The main component of the architecture is the \emph{processor}.
%
It embeds several execution units called \emph{cores}.
%
They are responsible for executing sequences of assembly instructions which form
software components programs.
%
The concrete hardware implementation of the processor is often referred as the
Intel microarchitecture, in opposition to the Intel architecture which describes
the expected behavior and properties of a x86 system as seen by software
developers.
%
While Intel often modifies the microarchitecture, the architecture has remained
backward compatible for decades\,\cite{turley2014introx86}.
%
The microarchitecture implements many optimizations, such as
multithreading\,\cite{marr2002hypertheading}, instruction
pipelining\,\cite{fog2012microarchitecture}, out-of-order
execution\,\cite[Section 2]{fog2012microarchitecture} or predictive
branching\,\cite{milenkovic2002branchprediction}\cite[Section
3]{fog2012microarchitecture}.
%
These optimizations should not violate properties of the
architecture.
%
For instance, the predictive branching implemented by x86 \acp{cpu} increases
performance, \emph{e.g.} inside a loop.
%
In presence of a conditional jump, a core will eagerly choose one branch
---based on the past execution--- before it has executed all the computations
required to determine the correct execution path.
%
Most of the time, it chooses the correct branch.
%
In case of \emph{branch misprediction}, the erroneous computations performed by the core shall be canceled like if they have never happened.
%
We illustrate branch misprediction with the following program snippet, written with x86
assembly instructions (left) and its C equivalent (right)\,\footnote{Provided no
  optimization from the compiler nor the processor.}:
%
\begin{center}
  \begin{minipage}[t]{0.35\linewidth}
    \inputminted{asm}{Listings/predict.S}
  \end{minipage}
  \begin{minipage}[t]{0.35\linewidth}
    \inputminted{c}{Listings/predict.c}
  \end{minipage}
\end{center}
%
During the first 10 steps of the loop, when the core executes the
\texttt{jle} instruction (l. 5), it takes the same branch and jumps to the
\texttt{loop} label.
%
At the end of the last loop step, the register \texttt{rax} contains the value
\( 11 \).
%
According to the semantics of \texttt{jle}, the core should execute the
\texttt{movq~\$0,~\%rax} (l.6) next.
%
From a microarchitectural point of view, the branch prediction technology can
decide to optimize the execution of the program, by eagerly jumping to the
\texttt{loop} label and continuing the execution of the program \emph{before}
\texttt{\%rax} has been updated to \( 11 \).
%
% TODO: un meilleur snippet de code serait d’incrémenter ebx en plus de eax
%
% TODO : avant, limiter au temps d'accès cache. depuis le début de l'année 2018
% et meltdown/spectre, d'autres mécanismes ont pu être détournés de leur
% objectif de performance (branch prediction, tlb)

Intel microarchitecture blurs the frontier between hardware and software.
%
Indeed, an important part of the microarchitecture is not implemented as
hardware circuit, but rather under the form of \emph{microcode}
programs\,\cite[Section 2.14]{costan2016sgxexplained}.
%
That is, the processor is a programmable device, whose behavior ---including the
semantics of several x86 instructions it
implements\,\cite{johnson2015patentsgx}--- is partly determined by the microcode
it has loaded.
%
In practice, x86 \acp{cpu} only load microcode updates which have been signed by
Intel.
%
To the best of our knowledge, x86 microcode has never been successfully used as
an attack vector.

% GUILLAUME : Je dirais directement un CPU est aujourd'hui composé de plusieurs
% unités d'exécution indépendantes qu'on appelle des coeurs. Ces composants sont
% eux même constitués de différents blocs qui forme un pipeline d'exécution
% (fetch décode ALU, etc.) Ces coeurs peuvent être physiquement indépendants
% (i.e des unités qui possèdent leurs propres pipeline indépendant) ou bien
% virtuel. Dans ce cas (hyperthreading). Dans ce cas la micro-architecture
% partage les blocs d'un même coeur et offre l'illusion aux composants logiciels
% qu'ils peuvent s'exécuter sur différents coeurs indépendants. Chaque coeur
% virtuel possède un état qui lui est propre (compteur ordinal, etc.) mais
% partage les blocs d'exécution avec les autres coeurs virtuels d'un même coeur
% physique). Mettre quelques schéma pour illustrer ces concepts.
%
% A core basically repeats the following tasks:
%%
% \begin{enumerate}
% \item Read the content of its (internal) \emph{program counter} register, and
%   interpret it as the address of the next instruction.
%%
% \item Fetch the content of this address.
%%
% \item Decode the instruction, that is identified the desired operation to
%   perform
%%
% \item Act accordingly, by modifying its internal state, and interacting with
%   memories and features exposed by other hardware components
%%
% \item Update the content of its \emph{program counter} register according to
%   the semantics of the instruction it has executed. Most of the time, it
%   increases it to fetch the next instruction, but it can also set it to an
%   arbitrary value (\emph{e.g.} with jump instructions).
% \end{enumerate}

\paragraph{Memories and Cores \IOs.}
%
The Intel x86 instructions set contains hundreds of instructions\,\cite[Volume
2]{intel2014manual}.
%
Together, they allow software developers to modify the hardware architecture
state, from the internal processor registers to the peripherals.
%
Interactions between cores and the rest of the hardware architecture are called
\IOs, for Input/Output: a core receives data during an input and it sends data
during an output.
%
The main target of cores \IOs is the \ac{dram}.
%
\ac{dram} forms the \emph{system memory}, by exposing an array of contiguous,
addressable memory cells.
%
These memory cells contain the instructions executed by the cores, \emph{and}
the data they manipulate.
%
Therefore, a core decides the semantics of memory cell contents
depending on the context, \emph{i.e.} it can interpret the same binary sequence as an
instruction to execute then as an operand of an arithmetical operation.

Although \ac{dram} is the primary source of memory within the hardware
architecture, it is not the only one.
%
Other hardware components expose additional memory regions.
%
For instance, an x86 processor integrates a display controller which exposes a
frame buffer to the cores.
%
By writing to the frame buffer, a core changes the pictures displayed by the
computer screen.
%
In practice, the processor handles \IOs with high-speed hardware components
(\emph{e.g.} \ac{dram}, display controller, etc.).
%
In addition, it is connected to a companion chipset, called the
\ac{pch}\,\cite{turley2014introx86}, which handles slower hardware components
(\emph{e.g.}  hard drives, USB devices, PCI devices, etc.).
%
In previous iterations of the architecture, the processor was connected to a
\emph{northbrige} (low-latency), which was itself connected to a
\emph{southbridge} (slower \IOs).

Historically, x86 \acp{cpu} use two distinct memory spaces to communicate either
with the \ac{dram} or with other hardware components.
%
On the one hand, most of the x86 instructions modify the content of the system
memory.
%
For instance, operands of the \texttt{add} instruction can be addresses of the
system memory.
%
On the other hand, software developers use two dedicated instructions
---\texttt{in} and \texttt{out}--- to target the memories exposed by other
software components.
%
\IOs issued by \texttt{in} and \texttt{out} instructions are referred to as
Programmable \IOs (P-\IOs).
%
In addition to this approach, x86 \acp{cpu} are also capable of handling
\emph{memory-mapped} \IOs, where the memories exposed by the peripherals are
mapped within the system memory address space.
%
That is, the system memory is no longer limited to the
\ac{dram} only.
%
As a consequence, when a core reads from or write to the system memory, the
processor and the \ac{pch} dispatches its request to the correct hardware
component.
%
The mapping between a so-called \emph{physical address} manipulated by the
processor and its concrete memory location is called the \emph{memory map}.
%
The memory map is configurable, that is it can be changed dynamically \emph{via}
a set of configuration registers exposed by the processor and the \ac{pch}.
%
The two approaches are complementary.
%
As an example, PCI devices expose a so-called configuration space, which is a
dedicated memory region with a specific semantics (see
Figure~\ref{fig:usecase:pciconfig}).
%
The \ac{pch} exposes two registers which allows for interacting with these
configuration spaces.
%
PCI devices are identified in the hardware architecture with a tuple
\( \langle \mathrm{bus}, \mathrm{device}, \mathrm{function} \rangle \) (denoted
by \texttt{bus:device:function}).
%
A configuration register exposed by a given PCI device identified as
\texttt{bus:device:function} at the offset \( o \) of its configuration space is
addressed by the value
%
\[
  \mathtt{0x80000000}\,|\,\texttt{bios} <\!\!< 16\,|\,\texttt{device} <\!\!<
  11\,|\,\texttt{function} <\!\!< 8\,|\,\texttt{o}
\]
%
where \(\cdot\,|\,\cdot\) is the bit-wise OR operator, and
\(\cdot <\!\!< \cdot\) is the logical shift left operator.
%
First, the core updates the register \texttt{PCI\_CONFIG\_ADDRESS} with this
value.
%
Then, the \ac{pch} forwards P-\IOs targeting the register
\texttt{PCI\_CONFIG\_DATA}.
%
The PCI specification states that the offset \texttt{0x10} of the PCI
configuration spaces is dedicated to so-called \texttt{BAR}s (Base Address
Registers).
%
Using the \texttt{BAR} of a given device, it becomes possible to remap its
configuration space within the system memory address space.

\begin{figure}
  \begin{center}
    \def\svgwidth{0.8\textwidth} \resizebox{0.6\textwidth}{!}{%
      \input{Figures/PCI-config-space.pdf_tex}}
  \end{center}
  \caption{Standard registers of PCI Type 0 (Non-Bridge) Configuration Space
    Header}
  \label{fig:usecase:pciconfig}
\end{figure}

Finally, cores do not manipulate physical addresses directly.
%
Indeed, cores have their own address translation mechanisms, namely
segmentation\,\cite[Volume 3, Section 2.4]{intel2014manual} and
pagination\,\cite[Volume 3, Chapter 4]{intel2014manual}, which are configurable
by the software components.

As such, determining which hardware component will handle a core \IO targeting a
given virtual address requires to have a complete knowledge of the x86 remapping
and virtual memory mechanisms and of their exact configurations at a given time.

\paragraph{Peripherals \IOs.}
%
Cores are not the only active hardware components present inside a typical x86
hardware architecture.
%
For instance, several hardware components can also read from or write to the
\ac{dram} using a technology called \ac{dma}.
%
Hardware components can also interact with the processor by sending hardware
interrupts of various natures.
%
When a user presses a key of its keyboard, the latter sends an interrupt
(\texttt{\#IRQ1}).
%
Interrupt handlers, that is programs executed by the core when it receives
interrupts, are configurable \emph{via} a so-called \ac{idt}\,\cite[Volume 3,
Chapter 6]{intel2014manual}.
%
Each line of the \ac{idt} corresponds to a given interrupt whose semantics is
specified by Intel, as summarized in Table~\ref{tab:usecase:idt} for reference.
%
When a core received an interrupt, it saves its current context inside the
\ac{dram}, then starts executing the corresponding interrupt handler.
%
Not all x86 interrupts come from a hardware component.
%
Core use several of them, for instance to recover from errors.
%
For instance, if a core is not able to translate a virtual address into a
proper address, it raises a so-called Page Fault (denoted by \texttt{\#PF} or
\texttt{\#IRQ14}).

\begin{table}
  \centering
  \begin{tabular}{cl}
    {\scshape \#IRQ}
    & \multicolumn{1}{c}{\scshape Semantics} \\
    \hline
    \texttt{0x00}
    & Division by zero \\
    \texttt{0x01}
    & Single-step interrupt \\
    \texttt{0x02}
    & Non-Maskable Interrupt (NMI) \\
    \texttt{0x03}
    & Breaking point (used by debuggers) \\
    \texttt{0x04}
    & Stack overflow \\
    \texttt{0x05}
    & Bounds \\
    \texttt{0x06}
    & Invalid instruction opcode \\
    \texttt{0x07}
    & Coprocessor not available \\
    \texttt{0x08}
    & Double fault \\
    \texttt{0x09}
    & Coprocessor segment overrun \\
    \texttt{0x0A}
    & Invalid task state segment \\
    \texttt{0x0B}
    & Segment not present \\
    \texttt{0x0C}
    & Stack fault \\
    \texttt{0x0D}
    & General protection fault \\
    \texttt{0x0E}
    & Page fault \\
    \texttt{0x0F}
    & Reserved by Intel \\
    \texttt{0x10}
    & Math fault \\
    \texttt{0x11}
    & Alignment check \\
    \texttt{0x12}
    & Machine check \\
    \texttt{0x13}
    & SIMD floating-point exception \\
    \texttt{0x14}
    & Control protection exception \\
  \end{tabular}
  \caption{x86 Interrupt Descriptor Table semantics}
  \label{tab:usecase:idt}
\end{table}

In addition, Intel has implemented several out-of-band management technologies
for its products.
%
They allow for administering a computer \emph{via} the network, without the
need for a physical access.
%
In practice, the software components responsible for implementing the
out-of-band management features are not executed by the main processor: the network card was implementing the ASF
technology\,\cite{duflot2010network}, and
since 2008 x86 \acp{cpu} embed a so-called Management Engine\,\cite{ruan2014me,skochinsky2014intel}.
%
In 2018, the Management Engine is located inside the \ac{pch}.
%
ASF-capable network cards and the Management Engine require important
capabilities to implement their features.
%
For instance, the Management Engine can download from the Internet an executable
image, provoke the reboot of the computing platform and force the main \ac{cpu}
to execute the software components within the image it has
downloaded\,\cite{kumar2009active}.
%
It becomes harder and harder to completely disable the Management Engine on a
typical x86 computing platform.
%
The Management Engine will notably provoke the reboot of the platform if it
cannot initialize correctly.

\subsection{HSE Mechanisms Targeted Security Policies}
\label{subsec:usecase:targetedsec}

All being told, x86 computing platforms are formed of concurrent, interconnected
components.
%
They are of various natures, from physical components to sequences of
instructions.
%
They share common resources, like the \ac{dram} which can be modified by the
cores (which execute a software stack) and \ac{dma}-capable hardware components.
%
This allows for cooperation, \emph{e.g.} when a network card receives a TCP
packet, it copies its content to a pre-defined address in \ac{dram}, then
notifies the operating system by sending an interrupt to the core.
%
This also raises a significant challenge from a security perspective.

\paragraph{Principle of Least Privilege.}
%
Hardware and software components come from various places and can be of various
qualities.
%
Once integrated together, an attacker can potentially leverage any of them to threaten the security of the system.
%
In this context, the principle of least
privilege\,\cite{saltzer1975leastprivilege} applies: a given component should
only be able to leverage capabilities it needs to work according to its purpose,
where a ``capability'' refers to the right to perform a given \IO.
%
In practice, the implementation of this principle is challenging, for various
reasons.

Firstly, security checks can have an important impact over performance.
%
Partly for this reason, the hardware components have long been assumed
trustworthy.
%
A good demonstration of this fact is the Address Translation Services mechanism
introduced by the PCI standard, whose purpose is to allow PCI devices to bypass
security mechanisms designed to reduce their
privileges\,\cite{daubignard2017protip}.
%
Other examples showed it is not without consequences from a security
perspective\,\cite{nohl2014badusb,hudson2015thunderstrike,chifflier2013uefi}.
%
Secondly, the ``least privilege'' may vary from one execution to another.
%
To handle the numerous use cases of the x86 architecture, its default
configuration is very permissive, until software components such as the \ac{bios} or an
operating system modifies it to fit their needs, while implementing \ac{hse}
mechanisms.

% OLD VERSION: For instance, it has also been repeatedly shown that the various
% physical interface exposed by the computer (\emph{e.g.}
% USB\,\cite{nohl2014badusb}, Thunderbolt\,\cite{hudson2015thunderstrike},
% PCI\,\cite{chifflier2013uefi}) could be leveraged to take the control of a
% given computing platform, because peripherals connected \emph{via} these
% interfaces could perform \ac{dma}.

\paragraph{Access Control.}
%
The x86 hardware architecture provides many \ac{hse} mechanisms to determine
which \IO each component of the system can or cannot perform.
%
In other words, these \ac{hse} mechanisms enforce access control
policies\,\cite{sandhu1994access}.
%
Subjects of these policies include the software and hardware components of the
system.
%
Objects ultimately come down to the memory locations of various natures scattered
within the hardware architecture.
%
Actions comprise reading from and writing to a memory location; from a core
perspective, it is also common to distinguish between reading data and reading
instructions.

The \ac{mmu} is a good example of a hardware feature involved in a \ac{hse}
mechanism.
%
Thanks to the \ac{mmu}, an operating system can attribute ranges of \ac{dram} to
user applications it manages and isolates its code and data from these
applications.
%
The \ac{mmu} alone is not sufficient, because its scope does not cover its own
configuration.
%
That is, it is not possible to configure the \ac{mmu} in order to prevent a
software component to modify the \ac{mmu} configuration.
%
As a consequence, an additional hardware feature has to be used: the protection
rings\,\cite[Volume 3, Section 5.5]{intel2014manual}.
%
The x86 cores can operate in 4 different so-called rings, from 0 to 3, where
ring~0 is the most privileged and ring~3 the least.
%
Ring~3 imposes several restrictions on software components, including the
capability to modify the \texttt{CR3} register which identifies the base of the
page table hierarchy the \ac{mmu} uses.
%
This is why ring~3 is commonly dedicated to the execution of applications.
%
The scope of the \ac{mmu} is limited to the software component executed
by a core at a given time.
%
To impose an access control policy to hardware components as well, an operating
system can use the so-called VT-d feature, which implements an \IO-\ac{mmu} for
x86 computing platform\,\cite{abramson2006vtd}.

%
% GUILLAUME: Ce qu'il faudrait dire, c'est que le CPU et la RAM sont des
% ressources partagées par les différents composants logiciels et matériels. Du
% coup, d'un point de vue de la sécurité, comme ces composants ne se font pas
% nécessairement confiance (parsqu'ils viennent de fournisseur différent,
% parqsu'il peuvent être malveillant ou vulnérables, etc.) il est nécessaire de
% les isoler les un les autres. La plupart des mécanismes de sécurité de la
% plateforme fournisse don c un mécanisme d'isolation}
%

The complexity of the x86 \IO resolution mechanism obliges to take into account
the numerous redirection features exposed by the architecture.
%
Memory locations, \emph{e.g.} inside the \ac{dram} can have an arbitrary number
of aliases, in several layered address spaces: the \ac{dram} controller assigns
an address to each memory cell the \ac{dram} contains; the processor maps
physical addresses to \ac{dram} addresses; the \ac{mmu} maps virtual addresses
to physical addresses.
%
As a consequence, modifying the content of a memory cell may not be the only way
at the disposal of attackers to defeat a given access control policy.
%
For instance, if the access control policy refers to virtual addresses \( v \),
modifying the \ac{mmu} configuration results in modifying the content associated
with \( v \).

\paragraph{Availability.}
%
Another class of security policies targeted by \ac{hse} mechanism is
availability security policies.
%
They focus on ensuring given software components are executed over time, without
the need for cooperation from mistrusted software components.
%
For instance, a user application which contains an infinite loop should not be
able to prevent the execution of the operating system, and by extension other
user applications.
%
To that end, the x86 hardware architecture relies on hardware interrupts and
exceptions.
%
Going back to the example of user applications, an operating system can leverage
one of the numerous hardware timers (\emph{e.g.} APIC timer\,\cite[Volume 3,
Subsection 10.5.4]{intel2014manual}) at its disposal to periodically preempt a
core, \emph{i.e.} implement preemptive multitasking.

% \TODO{Beaucoup de confusion dans ce paragraphe. 1) si tu parles de information
% flow et que tu dis que tu ne peux pas traiter la noninterference, tu vas te
% faire allumer... 2) la non-interference ne traite généralement pas des canaux
% auxilliaires mais seulement des flux directe et indirecte qui résulte d'une
% écriture explicite dans un conteneur d'informatin ou canal public et 3) je ne
% comprends pas ce que tu veux dire avec la citation du manuel Intel}:
%
%\begin{quote}
%  The Intel architecture aims to provide protection against software
%  side-channel attacks at the cache line granularity.
%
%  \hfill\small \emph{Intel Software Guard Extensions, Developer Guide}
%\end{quote}
%
%Because computer programs rarely fit inside a cache line, preventing
% side-channel attacks requires additional software-based security enforcement
% mechanisms.

% \subsection{Security Challenges and Attack Paths}
%
% \paragraph{Privilege Escalation.}
%%
%
% \paragraph{Malicious Hardware Components.}
%%
% Historically, peripherals have been part of the \ac{tcb} of every x86 \ac{hse}
% mechanisms, with important consequences on the computing platform security.
%%
% \TODO{Tu n'as pas défini avant la TCB, il me semble.}
%%
% For instance, it has also been repeatedly shown that the various physical
% interface exposed by the computer (\emph{e.g.} USB\,\cite{nohl2014badusb},
% Thunderbolt\,\cite{hudson2015thunderstrike}, PCI\,\cite{chifflier2013uefi})
% could be leveraged to take the control of a given computing platform, because
% peripherals connected \emph{via} these interfaces could perform \ac{dma}.
%%
% In 2010, Loic Duflot \emph{et al.} have shown it was possible to take control
% of certain network card.
%%
% They exploit some vulnerability in the network card firmware, which process
% network packets, to that end\,\cite{duflot2010network}.
%%
% This attack path did not require a physical access to the target.
%
% In that respect, the current situation of x86 systems has improved.
%%
% Modern \acp{cpu} provide a feature called \IO MMU\thomasrk{ref!}, which allows
% for configuring the memory ranges each peripheral can access to.
%%
% A well-configured \IO MMU drastically limits the impact of a rogue
% peripherals.
%%
% However, it is worth mentioning that, since 2008, Intel embeds the Management
% Engine, a processor \emph{inside} the \ac{pch}\thomasrk{ref}.
%%
% The Management Engine executes a complete software stack, and is capable of
% interacting with the \ac{dram} as well as other hardware components.
%%
% Intel leverages the Management Engine to provide out-of-band management
% solution, which means it can interact with the rest of the world without the
% cooperation of the main \ac{cpu}.
%%
% Although the Management Engine supposedly operates in a transparent manner
% from the \ac{cpu} perspective, we emphasize that a Management Engine
% vulnerability, a scenario which is not without precedent, potentially defeats
% any security measures implemented at the \ac{cpu} level.
%
% \paragraph{Microarchitecture}
%%
% Intel microarchitectural design is increasingly considered from a security
% perspective.
%%
% A deep knowledge of a core internals can be leveraged to perform side channel
% attacks\,\thomasrk{ref}.
%%
% For instance, time variations in memory accesses induced by the x86 cache have
% been leveraged to \emph{e.g.} retrieve secrets\thomasrk{ref} or defeat
% software components isolation\thomasrk{ref}.
%%
% Since the disclosure of Spectre\thomasrk{ref} and Meltdown in January
% 2018\thomasrk{ref}, many other microarchitectural features have been subverted
% in side-channels attacks\thomasrk{ref spectre variants}.

\section{BIOS Overview}
\label{sec:usecase:firmware}

The \ac{bios} plays a significant role in Intel x86 computing platform.
%
It is the first piece of software executed by the \ac{cpu}, which initializes
the hardware components and initiates the execution of the software stack during
the boot sequence (\ref{subsec:usecase:firm:boot}).
%
At runtime, it remains active to perform various tasks, including and not
limited to platform-specific events, device emulation, or \ac{bios} updates
management (\ref{subsec:usecase:firm:runtime}).
%
As such, it can only operate properly if certain security requirements are met
(\ref{subsec:usecase:firm:sec}), and implements several \ac{hse} mechanisms to
that end (\ref{subsec:usecase:hse:smm}).

\subsection{During the boot sequence}
\label{subsec:usecase:firm:boot}

The \ac{bios} program is stored inside a flash memory, a small memory connected
to the \ac{pch} through the Serial Peripheral Interface (SPI) bus on modern x86
computing platform.
%
When the \ac{cpu} is powered up, it is programed to fetch the code stored at a
hard-coded address within the flash memory.
%
The first task of the \ac{bios} is to initialize the hardware
architecture\,\cite{salihun2006bios}.
%
Then, the \ac{bios} searches for a system software component to load into
memory.
%
Historically, ``legacy'' \acp{bios} were looking for a Master Boot Record (MBR)
at the beginning of mass storage devices (\emph{e.g.} hard drive, USB stick).
%
The MBR, whose size is limited to 512 bytes, contains a small program to
initiate a loader for a system software component.
%
Modern \acp{bios} implement the \ac{uefi}\,\cite{zimmer2007uefi,uefi2017specs},
whose purpose is to standardize the boot sequence process in order to favor
interoperability of \ac{bios} implementations.
%
The boot sequence is divided into several phases, and the \ac{bios} is packaged
into several software components accordingly.
%
In particular, \ac{uefi}-compliant \ac{bios} can load so-called \ac{uefi}
applications of arbitrary size, leading modern hypervisors and operating systems
to be packaged as \ac{uefi} applications.

Because the \ac{bios} is the first software component executed by the hardware
architecture, and is responsible for initiating the execution of following
software components (\emph{e.g.} an operating system), it is commonly designated
as the root of trust\,\cite{rutkowska2015intel} for the software stack.
%
As such, the integrity of the \ac{bios} code is primordial, and several
strategies have been proposed to detect \ac{bios} code corruption during the
boot sequence, with the two most predominant being Secure Boot and Trusted Boot.
%
The \ac{uefi} standard defines a security mechanism called Secure
Boot\,\cite{rosenbaum2012secboot}.
%
When Secure Boot is enabled, \ac{uefi}-compliant \acp{bios} should only execute
applications which provide an acceptable cryptographic signature, with respects
to a key hierarchy configurable by the computing platform owner.
%
The \ac{tcg} has standardized a hardware component called the \ac{tpm}, which is
the foundation of the Trusted Boot.
%
Each component of the boot sequence should measure any software
component it initiates prior to starting its execution, and to entrust these
measurements to the \ac{tpm}.
%
If one of the software components executed during the boot sequence has been
corrupted, the difference is captured by the \ac{tpm}, because its measurements
are different than expected.
%
The measurements entrusted to the \ac{tpm} can be leveraged at the end of the
boot sequence in at least two ways.
%
The \ac{tpm} can cryptographically sign the measurements during a protocol
called remote attestation\,\cite{coker2011remoteattestation} which allows a
third party to verify that a given computing platform executes the code it is
supposed to.
%
Another popular approach is to entrust to the \ac{tpm} the encryption key which
protects sensitive information that a corrupted \ac{bios} should not be allowed to
access.
%
In this scenario, the access to the encryption key is correlated to the
measurements received by the \ac{tpm}.
%
Secure Boot and Trusted Boot can uncover \ac{bios} corruptions prior to the
execution of the illegitimate code.
%
However, they both rely on a root of trust which is neither measured nor
verified against a cryptographic signature.
%
Recent efforts have been expended to overcome this limitation.
%
For instance, in 2013 HP has introduced a security mechanism called
SureStart\,\cite{hp2016surestart} whose purpose is to move the root of trust
within another hardware component.
%
More recently, the NIST has published the Special Communication 800-193
---\emph{Platform Firmware Resiliency
  Guidelines}\,\cite{regenscheid2018nist800193}--- on the subject.

\subsection{At runtime}
\label{subsec:usecase:firm:runtime}

The boot sequence ends once a system software component has been selected and
loaded into memory by the \ac{bios}.

\paragraph{Software Interfaces.}
At runtime, the \ac{bios} provides various software interfaces to the system
software component.
%
For instance, the \ac{acpi} tables\,\cite{uefi2017acpi,duflot2010acpi} is a
standardized interface to configure various vendor-specific aspects of
the hardware platform, such as power management or thermal management.
%
Similarly, legacy \acp{bios} expose facilities to system software
components, in the form of so-called \ac{bios} Interrupt.
%
For instance, the interrupt \texttt{0x10} is dedicated to video services
(\emph{e.g.} setting the video mode, setting the cursor shape and position,
etc.).
%
Nowadays, \ac{uefi}-capable \acp{bios} expose so-called \emph{Runtime Services}
to system software component\cite[Chapter 5]{zimmer2017uefi} under the form of a
function pointers table.

In either case, these interfaces act as an intermediary layer between a system
software component and the hardware architecture.
%
In doing so, they reduce the coupling between the software and hardware
components.
%
Sometimes, their use is optional, and \acp{bios} only provide them as a facility.
%
Other are mandatory gates towards certain computing platform features, because
they are related to critical features of the platform and the hardware vendors
do not want to rely on a (potentially vulnerable or malicious) system software
component.
%
For instance, the \ac{bios} takes care of its own software updates, so that the latter can validate the validity of the new
version prior to applying it.

\paragraph{Proactive Features.}
%
In addition to supporting the execution of the rest of the software stack
through its interfaces, the \ac{bios} carries out several hardware-specific
tasks which are not publicly documented.
%
This includes and is not limited to handling hardware errors, checking thermal
zones, adjusting \acp{cpu} speed.
%
The execution of the \ac{bios} in this context should be transparent to
the rest of the software stack.
%
Some \acp{bios} also emulate complete hardware devices to the system software
component.
%
As such, the \ac{bios} remains the most privilege software component of the
software stack, even after the end of the boot sequence.

\subsection{Security Model}
\label{subsec:usecase:firm:sec}

The hardware architecture’s manufacturer provides the \ac{bios}.
%
In most cases, it is a proprietary software, and the computer owner has little
control over it.
%
The rest of the software stack is considered mistrusted, and the one goal of the
\ac{bios} is to keep the computer in a working state.
%
To that end, the \ac{bios} relies on several \ac{hse} mechanisms to enforce its
isolation from the rest of the software stack.

To the best of our knowledge, the security policy targeted by the \ac{bios} as
runtime is always discussed through the prism of the \ac{hse} mechanism used to
enforced this policy.
%
That is, documentation such as the Intel manual, the processor datasheet or the
\ac{pch} datasheet ---in practice involved in the \ac{hse} mechanisms
implemented by the \ac{bios}--- focus on \emph{how} implementing the security
policy rather than specifying \emph{what} this policy is\thomasrk{Is it really
  true?}.
%
Another useful source of information on this matter is the various research
projects which discuss these mechanisms, for instance to demonstrate a
security
vulnerability\,\cite{duflot2009smram,wojtczuk2009smram,bulygin2014summary}.
%
From the information we gathered, we believe the isolation required by the
\ac{bios} can be divided into three complementary security policies.

\begin{description}
\item [Volatile Memory Access Control]
  %
  The \ac{bios} is assigned a volatile memory region to support its execution at
  runtime.
  %
  The rest of the software stack shall not be authorized either to read from
  or to write to this memory region.
  % \item [Secure Channel]
  %
  The rest of the software stack cannot prevent the \ac{bios} to read from or
  write to its assigned volatile memory region.
  Neither can it tamper with the
  result of read accesses issued by the \ac{bios} and targeting its assigned
  volatile memory region.
\end{description}
%
Volatile memory is an absolute requirement in order to execute a software
component, and the \ac{bios} is no exception in this regard.
%
It contains both the sequences of instructions which form the program of the
software component, and the data it manipulates.
%
If a system component is able to modify either the code or the data manipulated
by the \ac{bios}, it can actively interfere with its execution.
%
Besides, and as discussed previously, our statement takes into account the fact
that the x86 \IOs resolution is highly configurable, by introducing a notion of
secure channel \thomasrk{ref} between the software component and its assigned
volatile memory.

\begin{description}
\item [Availability]
  %
  The rest of the software stack is not authorized to prevent the execution of
  the \ac{bios} at runtime.
  %
\end{description}

Because of the nature of the tasks carried out by the \ac{bios}, vendors do not
want to rely on the rest of the software stack.
%
In practice, this means the scheduling between the execution of the \ac{bios}
and the rest of the software stack cannot be cooperative.
%
Therefore, the
\ac{bios} needs to be able to preempt the execution of the rest of the software
stack.

\begin{description}
\item [Non-volatile Memory Access Control]
  %
  The \ac{bios} is assigned a non-volatile memory region (in practice, a portion
  of the flash memory) to store its code and data.
  %
  The rest of the software stack shall not be authorized to modify the content
  of this memory.
\end{description}

Limiting the set of authorized software components to modify the content of the
flash memory to the \ac{bios} alone allows for preserving the isolation of the
\ac{bios} across reboots.
%
Without a proper lockdown on the flash memory, a malicious system software
component could simply modify the \ac{bios} code, then provoke its execution by
rebooting the platform.

\subsection{HSE Mechanisms Implemented by the BIOS}
\label{subsec:usecase:hse:smm}

The isolation of the \ac{bios} at runtime, as detailed in the previous
subsection, directly involves three different hardware components: the
processor, the \ac{dram} and the \ac{pch}.

\paragraph{System Management Mode.}
%
To handle several software components with different levels of privilege, Intel
\acp{cpu} provide several execution modes.
%
An execution mode can be assimilated to a set of hardware capabilities.
%
For instance, in a given execution mode, a \ac{cpu} may refuse to execute
certain assembly instructions, and the software component executed at the time
will not be able to leverage the side effects involved in the execution of these
instructions.
%
Contrary to common belief, x86 execution modes are not organized in a linear
hierarchy, but are rather a matrix of complementary hardware features:
protection rings, paging configuration, virtualization technologies, etc.
%
As for the \ac{bios}, Intel provides the so-called \ac{smm}\,\cite[Volume 3,
Chapter 34]{intel2014manual}, introduced in the Intel manual as follows:

% GUILLAUME: \TODO{ ref, ref and ref...}  NOTE: On a déjà évoqué plusieurs fois
% /avant/ ces technos, donc si ref il doit y avoir (et je crois qu'elles y
% sont), alors elles sont déjà présentes avant.

\begin{quote}
  \ac{smm} is a special purpose operating mode provided for handling systemwide
  functions like power management, system hardware control, or proprietary
  OEM-designed code.
  %
  It is intended for use only by system firmware, not by application software or
  general-purpose system software.
  %
  The main benefit of \ac{smm} is that it offers a distinct and easily isolated
  processor environment that operates transparently to the operating system or
  executive and software applications.

  \hfill \small \emph{Intel 64 and IA-32 Architectures Software Developer’s
    Manual}
\end{quote}

The \ac{smm} is the foundation of the \ac{bios} execution at runtime, but it is
not sufficient.

\paragraph{System Management RAM.}
%
The SMRAM is the name given by Intel to a memory region located inside the
\ac{dram}, and dedicated to the \ac{smm}.
%
The exact location and size of the SMRAM are architecture dependent.
%
To locate it, the \ac{cpu} uses a dedicated register named \texttt{SMBASE}.
%
The \ac{bios} should configure it during the boot sequence.
%
As its name suggests, the \texttt{SMBASE} value should point to the base of the
SMRAM.
%
As for the end of the SMRAM, the hardware architecture does not expose it
explicitly, and the \ac{bios} needs to refer to the processor datasheet in order
to find it.

At the beginning of the boot sequence, the SMRAM is left unprotected, meaning
arbitrary memory accesses targeting the SMRAM are authorized.
%
This design allows the \ac{bios} to initialize the SMRAM content.
%
Once the \ac{smm} code ---the \ac{bios} code intended to be executed at runtime
in \ac{smm}--- has been correctly loaded into the SMRAM, and prior to giving the
\ac{cpu} control flow to a system software component, the \ac{bios} has to lock
the SMRAM.
%
% \TODO{expliquer ce que veut dire invisible -> la mémoire n'est plus mappé dans
% la plage d'adresse et soit le processeur accède à une autre mémoire soit il y
% a une exception (je suppose)}
A locked SMRAM can only be accessed by a \ac{cpu} in \ac{smm}, and is
inaccessible to a \ac{cpu} not in \ac{smm}.
%
More precisely, the physical addresses dedicated to the SMRAM from the \ac{bios}
perspective are used by the rest of the software stack to access the VGA
controller memory.
%
The \texttt{SMRAMC} register exposed by the processor controls this access control mechanism, \emph{via} its \texttt{D\_LCK} bit.
%
The \ac{bios} locks the SMRAM by setting the \texttt{D\_LCK} bit.
%
A processor with the \texttt{D\_LCK} bit set will prevent a \ac{cpu} not in
\ac{smm} to access the SMRAM content.
%
In addition, the only way to clear the \texttt{D\_LCK} is by performing a complete reboot of the platform.
%
This leaves no opportunity for the system software to tamper with the SMRAM
content, because the \ac{bios} will lock it again prior to executing another software component.

\paragraph{System Management Interrupt.}

The \ac{smi} is a hardware interrupt which makes the \ac{cpu} ``enters''
\ac{smm}.
%
More precisely, when a \ac{cpu} receives a \ac{smi}, it saves its current state
(\emph{e.g.} its registers, current execution mode, etc.) in the SMRAM.
%
Then, the \ac{cpu} reconfigures itself;
%
in particular, it sets its program counter register to the value
$\mathtt{SMBASE} + \mathrm{0x8000}$.
%
From this point, the \ac{cpu} is in \ac{smm} and starts to execute what should
be the \ac{smm} code.
%
Once the \ac{smm} code has performed the task it has been requested for, the
\texttt{rsm} instruction can be used.
%
This instruction, specific to the \ac{smm}, tells the \ac{cpu} to
restore its previous state.
%
This way, the execution of the software component previously halted by the
\ac{smi} can resume.
%
From the system point of view, it is almost like if nothing has happened.
%
It remains possible to detect \ac{smm} context switches.
%
The most straightforward way is to rely on the Model-Specific Register
\texttt{0x34} (\texttt{MSR\_SMI\_COUNT}), as the \ac{cpu} increments it every time it handles a \ac{smi}\,\cite[Volume 4, Chapter 2]{intel2014manual}.
%
An operating system can also spin in a loop to take regular timestamps.
%
Variations in the timestamps interval are likely to be explained by a \ac{smm}
context switch.

Finally, the \ac{pch} exposes a register called \texttt{APM\_CNT} that a system
software component can write to in order to make the \ac{pch} triggers a
\ac{smi}\,\cite{intel2012pch}.

\paragraph{Flash Memory Lock-down.}
%
The content of the flash memory has to be protected from arbitrary tampering,
similarly to the SMRAM protection.
%
That is, only the \ac{smm} code should be able to overwrite the content of the
flash memory.
%
This second access control mechanism is implemented by the \ac{pch}.
%
It is configurable \emph{via} the \texttt{BIOS\_CNTL} control register.
%
Two bits of this register are of interest: the \texttt{BIOSWE} (\ac{bios} Write
Enable) bit, and the \texttt{BLE} (\ac{bios} Lock Enable) bit.

The semantics of the \texttt{BIOSWE} and \texttt{BLE} bits is as follows.
%
When the \texttt{BIOSWE} bit is clear, the \ac{pch} only authorizes read
accesses to the flash memory.
%
If a core sets the \texttt{BIOSWE} bit, the behavior of the \ac{pch}
depends on the value of the \texttt{BLE} bit.
%
If the \texttt{BLE} bit has been set by the \ac{bios} during the boot sequence,
then the \ac{pch} triggers a \ac{smi}.
%
As a consequence, the \ac{cpu} stops its current execution and enters in
\ac{smm}.
%
This prevents the system software from tampering with the content of the Flash
Memory, even if the \ac{pch} now authorizes write accesses.
%
It is the \ac{smm} code responsibility to clear the \texttt{BIOSWE} bit before
using the \texttt{rsm} instruction.
%
On the contrary, if the \texttt{BLE} bit is not set, setting the \texttt{BIOSWE}
bit will not cause a \ac{smi}.
%
Similarly to the \texttt{D\_LCK} bit of the \texttt{SMRAMC} register, the
\texttt{BLE} bit cannot be cleared without a reboot.

% GUILLAUME: Parfois tu mets Flash Memory en majuscul, parfois non. Je pense
% qu'il ne faut pas de majuscule, harmonise à tout le document.

The system software component and the \ac{bios} often use the flash memory lockdown mechanism as a communication channel.
%
The system software sets the \texttt{BIOSWE} bit in order to notify the \ac{smm}
code that a \ac{bios} update is available.

\paragraph{}
%
The combination of the SMRAM, the \ac{smi} and the Flash Memory Lock-down
explains why the \ac{smm} is often referred to as the x86 ``most privileged execution
mode.''
%
In a nutshell, the \ac{smm} code can leverage the same hardware capabilities
than system software, including tampering with memories assigned to the system
software.
%
On the contrary, the system software cannot modify either the SMRAM content or
the \ac{smm} code stored in the flash memory, and cannot prevent the \ac{smm}
code execution, \emph{i.e} intercept or mask \acp{smi}.



\section{BIOS HSE Mechanism and Architectural Attacks}
\label{sec:usecase:hse}

To stay isolated from the rest of the software stack at runtime, the \ac{bios}
implements a \ac{hse} mechanism whose key hardware feature is the \ac{smm}, a
dedicated execution mode of x86 \acp{cpu} (\ref{subsec:usecase:hse:smm}).
%
The \ac{smm} provides the necessary features to enforce its isolation from the
rest of the software stack.
%
Despite the key importance of \ac{smm}, several architectural attacks have been
disclosed over the past decade.
%
In this section, we detail three attacks which have defeated the three security
policies targeted by the \ac{bios}.
%
The SMRAM Cache Poisoning Attack allowed for
circumventing the SMRAM access control mechanism
(\ref{subsec:usecase:hse:smram}).
%
The so-called SENTER Sandman attack prevented
the execution of the \ac{bios} and led to modifying the content of the flash
memory (\ref{subsec:usecase:hse:sandman}).
%
The Speed Racer attack resulted into an authorized modification of the flash
memory as well (\ref{subsec:usecase:hse:speed}).

\subsection{SMRAM Cache Poisoning Attack} % -------------------------------
\label{subsec:usecase:hse:smram}

Between 1986, when the \ac{smm} has first been introduced, and 2009, it was
believed that the \texttt{SMRAMC} register alone was sufficient to enforce SMRAM
access control.
%
Loic Duflot \emph{et al.}\,\cite{duflot2009smram} and Rafal Wojtczuk \emph{et
  al.}\,\cite{wojtczuk2009smram} independently showed that this belief was
misplaced when they disclosed the SMRAM Cache Poisoning Attack.

\paragraph{Cache Memory.}
%
Interacting with the \ac{dram} remains slow, in regard to the speed of a
\ac{cpu}.
%
To improve performance, Intel \acp{cpu} come with several levels of caches, from
the smaller and quicker, to the bigger and slower.
%
For instance, Intel Core i7, i5 and i3 processors have three levels of cache
%
More precisely, each core is assigned two levels of cache called L1 and L2.
%
The L1 cache has the particularity to be divided into a cache of instructions
(used when the core read from memory instructions to execute) and a cache of
data.
%
The cores of the processor share the L3 cache.
%
As a reference, the Figure~\ref{fig:usecase:l1-l3caches}.
%
Caches are mostly transparent to the software components.
%
For instance, the processor alone enforces the cache coherence, with
the notable exception of multiprocessor (not multicore) systems, for which
``maintenance of cache consistency may, in rare circumstances, require
intervention by system software.''
%
Intel has developed a dedicated protocol called MESIF to that
end\,\cite{thomadakis2011nehalem}.

\begin{figure}
  \begin{center}
    \begin{tikzpicture}
      \node [draw, inner sep=10pt, rectangle, text width=100pt, text badly
      centered] (l3-1) {L3 slice};%
      \node [draw, inner sep=10pt, rectangle, text width=100pt, text badly
      centered, right=25pt of l3-1] (l3-2) {L3 slice};%
      \node [draw, inner sep=10pt, rectangle, text width=100pt, text badly
      centered, below=10pt of l3-2] (l3-3) {L3 slice};%
      \node [draw, inner sep=10pt, rectangle, text width=100pt, text badly
      centered, left=25pt of l3-3] (l3-4) {L3 slice};%
      \node [draw, dashed, inner sep=10pt, fit=(l3-1) (l3-2) (l3-3) (l3-4)] (l3)
      {};%

      \draw (l3-1) -- (l3-2);%
      \draw (l3-2) -- (l3-3);%
      \draw (l3-3) -- (l3-4);%
      \draw (l3-4) -- (l3-1);%

      % core 1
      \node [draw, text width=100pt, inner sep=10pt, text badly centered,
      above=of l3-1] (l2-1) {Cache L2};%
      \draw (l3-1) -- (l2-1);%

      \node [above=20pt of l2-1] (l1-1) {};%
      \node [draw, right=0pt of l1-1.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-1-i) {Cache L1 {\small (Instruction)}};%
      \node [draw, left=0pt of l1-1.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-1-d) {Cache L1 {\small (Data)}};%
      \node [draw, text width=100pt, text badly centered, inner sep=10pt,
      minimum height=40pt, above=20pt of l1-1] (unit-1) {Execution Unit};%

      \draw (unit-1.south) -| (l1-1-d.north);%
      \draw (unit-1.south) -| (l1-1-i.north);%
      \draw (l1-1-i.south) |- (l2-1.north);%
      \draw (l1-1-d.south) |- (l2-1.north);%

      \node [draw, dashed, inner sep=10pt, fit=(unit-1) (l2-1)] (c-1) {};%

      % core 2
      \node [draw, text width=100pt, inner sep=10pt, text badly centered,
      above=of l3-2] (l2-2) {Cache L2};%
      \draw (l3-2) -- (l2-2);%

      \node [above=20pt of l2-2] (l1-2) {};%
      \node [draw, right=0pt of l1-2.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-2-i) {Cache L1 {\small (Instruction)}};%
      \node [draw, left=0pt of l1-2.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-2-d) {Cache L1 {\small (Data)}};%
      \node [draw, text width=100pt, text badly centered, inner sep=10pt,
      minimum height=40pt, above=20pt of l1-2] (unit-2) {Execution Unit};%

      \draw (unit-2.south) -| (l1-2-d.north);%
      \draw (unit-2.south) -| (l1-2-i.north);%
      \draw (l1-2-i.south) |- (l2-2.north);%
      \draw (l1-2-d.south) |- (l2-2.north);%

      \node [draw, dashed, inner sep=10pt, fit=(unit-2) (l2-2)] (c-2) {};%

      % core 3
      \node [draw, text width=100pt, inner sep=10pt, text badly centered,
      below=of l3-3] (l2-3) {Cache L2};%
      \draw (l3-3) -- (l2-3);%

      \node [below=20pt of l2-3] (l1-3) {};%
      \node [draw, right=0pt of l1-3.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-3-i) {Cache L1 {\small (Instruction)}};%
      \node [draw, left=0pt of l1-3.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-3-d) {Cache L1 {\small (Data)}};%
      \node [draw, text width=100pt, text badly centered, inner sep=10pt,
      minimum height=40pt, below=20pt of l1-3] (unit-3) {Execution Unit};%

      \draw (unit-3.north) -| (l1-3-d.south);%
      \draw (unit-3.north) -| (l1-3-i.south);%
      \draw (l1-3-i.north) |- (l2-3.south);%
      \draw (l1-3-d.north) |- (l2-3.south);%

      \node [draw, dashed, inner sep=10pt, fit=(unit-3) (l2-3)] (c-3) {};%

      % core 3
      \node [draw, text width=100pt, inner sep=10pt, text badly centered,
      below=of l3-4] (l2-4) {Cache L2};%
      \draw (l3-4) -- (l2-4);%

      \node [below=20pt of l2-4] (l1-4) {};%
      \node [draw, right=0pt of l1-4.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-4-i) {Cache L1 {\small (Instruction)}};%
      \node [draw, left=0pt of l1-4.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-4-d) {Cache L1 {\small (Data)}};%
      \node [draw, text width=100pt, text badly centered, inner sep=10pt,
      minimum height=40pt, below=20pt of l1-4] (unit-4) {Execution Unit};%

      \draw (unit-4.north) -| (l1-4-d.south);%
      \draw (unit-4.north) -| (l1-4-i.south);%
      \draw (l1-4-i.north) |- (l2-4.south);%
      \draw (l1-4-d.north) |- (l2-4.south);%

      \node [draw, dashed, inner sep=10pt, fit=(unit-4) (l2-4)] (c-4) {};%
    \end{tikzpicture}
  \end{center}
  \caption{Typical caches organization of a x86 processor}
  \label{fig:usecase:l1-l3caches}
\end{figure}

When a \ac{cpu} successfully reads the memory at a given address, it keeps a
copy of the result in its cache.
%
Therefore, the next time it needs to read some data at this address, these data
are retrieved from the cache.
%
Regarding write accesses, Intel x86 \acp{cpu} provide five different caching
strategies (uncacheable, write combining, write-through, write-back and
write-protected)\,\cite[Volume 3, Chapter~11]{intel2014manual}.
%
Fine-grained cache strategy configuration is achieved through several hardware
mechanisms, including (but not limited to):
%
\begin{itemize}
\item The \texttt{CR0} register has a flag called \texttt{CD}, which enables
  caching once set.
%
\item The \ac{cpu} has several registers called Memory Type Range Registers
  (MTRR), to specify a cache strategy for pre-defined memory regions.
  %
  Each MTRR
\item The Page Table Attribute (PAT) allows for configuring a cache strategy at
  a memory page granularity.
\end{itemize}
%
The most commonly used strategy is write-back strategy.
%
It is summarized in Figure~\ref{fig:usecase:writeback}.
%
The purpose of the write-back strategy is to reduce the number of write accesses
forwarded to the system memory.
%
To that end, each cache block has a ``dirty bit'' which is set by the cache when
its value is updated by a write access.
%
In case of cache eviction, the cache verifies the value of the ``dirty bit'', so
it can update the underlying memory cell if necessary.
%
Therefore, as long as the cache block is not evicted, the \ac{cpu} does not
issue write access to the underlying memory.
%
The write-back strategy is not suitable for memories of hardware components
mapped into the \ac{cpu} address space.
%
For instance, caching write accesses to a framebuffer does not make sense.
%
This is why Intel provides four complementary strategies.
%
The uncacheable strategy disables the cache for the given address, while write
combining, write-through, write-back and write-protected are similar strategies
such that write accesses are directly forwarded to the underlying memory.

For cache-friendly programs, the gain in performance can be huge.
%
For instance, for a Pentium M Intel have stated that access to L1 cache takes
3 \ac{cpu} cycles, access to the L2 cache takes 12 cycles and access to
the DRAM takes 240 cycles\,\cite{drepper2007memory}.

\begin{figure}
  \centering
  \begin{tikzpicture}
    \node [draw, circle] (EP) {};%

    \node [draw, below=of EP] (Sel) {Select a cache block};%
    \draw [-latex] (EP) -- (Sel);%

    \node [draw, signal, signal to=east and west, below=of Sel] (CH) {Cache
      hit?};%
    \draw [-latex] (Sel) -- (CH);

    \node [below=of CH] (CHbranch) {};%
    \draw (CH) to node [right] {[Yes]} (CHbranch.center);%
    \node [left=70pt of CH] (nCHbranch) {};%
    \draw [below] (CH) to node {[No]} (nCHbranch.center);

    \node [draw, signal, signal to=east and west, below=of nCHbranch.center]
    (Dirty) {Cache block dirty?};%
    \draw [-latex] (nCHbranch.center) -- (Dirty);%

    \node [draw, below=of Dirty, text width=70pt, text badly centered] (WB)
    {Write the content of the cache block back to the DRAM};%
    \draw [-latex] (Dirty) to node [right] {[Yes]} (WB);%

    \node [draw, below=of WB, text width=80pt, text badly centered] (Rf) {Read
      data from lower memory and fill the cache block};%
    \draw [-latex] (WB) -- (Rf);%

    \node [draw, below=of WB, text width=80pt, text badly centered] (Rf) {Read
      data from lower memory and fill the cache block};%
    \draw [-latex] (WB) -- (Rf);%

    \node [draw, below=of Rf, text width=80pt, text badly centered] (NotDirty)
    {Mark the cache block as ``not dirty''};%
    \draw [-latex] (Rf) -- (NotDirty);%

    \draw (Dirty) to node [below] {[No]} ([xshift=-90pt]Dirty.center);%
    \draw ([xshift=-90pt]Dirty.center) -- ([xshift=-90pt]Rf.center);%
    \draw [-latex] ([xshift=-90pt]Rf.center) -- (Rf);%
    \draw [-latex] (Rf) -- (NotDirty);%

    \node [below=260pt of CHbranch.center] (Join) {};%
    \node [draw, signal, signal to=east and west, below=5pt of Join] (RxW) {Read
      or Write?};%
    \draw [-latex] (CHbranch.center) -- (RxW);%
    \draw (NotDirty) -| (Join.center);%

    \node [draw, text badly centered, text width=70pt, right=50pt of RxW] (R)
    {Return data};%
    \draw [-latex] (RxW) to node [below] {[Read]} (R);%
    \node [draw, text badly centered, text width=70pt, left=50pt of RxW] (W)
    {Write new value in cache block};%
    \draw [-latex] (RxW) to node [below] {[Write]} (W);%

    \node [draw, text badly centered, text width=70pt, below=of W] (MakeDirty)
    {Mark cache block as dirty};%
    \draw [-latex] (W) -- (MakeDirty);

    \node [draw, fill=black, below=100pt of RxW, circle] (End) {}; \draw
    [-latex] (MakeDirty.south) |- (End.west); \draw [-latex] (R.south) |-
    (End.east);
  \end{tikzpicture}

  \caption{The Write-Back cache strategy}
  \label{fig:usecase:writeback}
\end{figure}

\paragraph{Attack Path.}
%
The SMRAM Cache Poisoning leverages the write-back strategy of the \ac{cpu}
cache to circumvent the \texttt{D\_LCK} bit protection.
%
The attack proceeds as follows:

\begin{enumerate}
\item Attackers set the cache strategy to be used for the SMRAM addresses to
  write-back.
  %
  This can be done by a malicious system software component, or even by a
  malicious application under certain circumstances (for instance, if an
  operating system exposes a software interface to manage the cache from the
  userland).

%
\item They write to the \texttt{APM\_CNT} register in order to provoke the
  triggering of a \ac{smi}.
%
\item The \ac{smm} code is executed in SMM, leading the cache to be filled with
  copies of that code
%
\item Attackers issue a memory write access targeting the SMRAM, and because of
  the write-back cache strategy, the \ac{cpu} updates the copies within the
  cache, but does not pass the access to the Memory Controller.
%
\item Attacker trigger another \ac{smi}, and the \ac{cpu} uses the tampered copy
  of the \ac{smm} code inside its cache.
\end{enumerate}
%
This attack is a perfect illustration of an architectural attack:
%
both the Memory Controller and the \ac{cpu} cache work as expected.
%
The former prevents authorized accesses to the SMRAM, that is a subset of the
\ac{dram}, by a \ac{cpu} not in \ac{smm};
%
the former is keeping copies of successful accesses to decrease latency due to
memory accesses.
%
However, the composition of the cache and the memory controller breaks the BIOS
Integrity property.

\paragraph{Countermeasure.}
%
The solution implemented by Intel to prevent further exploitation of this
vulnerability was to modify the behavior of the cache, when the memory accesses
target the SMRAM.
%
Because the SMRAM size and location remain specific to each architecture, this
means it requires an additional step of configurations to tell the cache the
physical addresses that belong to the SMRAM.

\paragraph{}
%
The SMRAM Cache Poisoning attack is a textbook case of architectural attacks.
%
It is interesting to notice that six years later, Christopher Domas has
disclosed another x86 vulnerability called Sinkhole\,\cite{domas2015sinkhole},
which relies on a similar approach to trick a \ac{cpu} in \ac{smm} to execute
arbitrary instructions.
%
Both leave the content of the SMRAM in \ac{dram} intact.
%
Both leverage legitimate hardware features.

\subsection{SENTER Sandman}
\label{subsec:usecase:hse:sandman}

In 2015, Xeno Kovah \emph{et al.} showed it was possible to leverage the Intel TXT
technology to circumvent the flash memory lockdown
protection\,\cite{kovah2015senter}.

\paragraph{Intel TXT.}
%
The Intel Trusted eXecution Technology (TXT)\cite{intel2015txt} is a recent
feature of some x86 \acp{cpu}, whose purpose is to attest the integrity of the
system software component program without the need to trust the \ac{bios}.
%
As such, it addresses the main limitation of both the Secure Boot and Trusted
Boot approaches, previously detailed in
Subsection~\ref{subsec:usecase:firm:boot}.
%
Similarly to the Trusted Boot approach, TXT entrusts measurement of the system
software component program to the \ac{tpm}.
%
These measurements can be leveraged to conditionally seal an encryption key or
be part of an attestation protocol, as they would have been with in the context
of a Trusted Boot.
%
However, contrary to the Trusted Boot approach, the component responsible for
measuring the program is the processor itself.
%
This makes a big difference regarding the trust we can place in the
measurements.
%
On the one hand, if the root of trust ---which is part of the \ac{bios}--- has
been corrupted or if the \ac{bios} suffers from an exploitable vulnerability, the authenticity of the
measurements is no longer guaranteed.
%
In such a case, neither the system software component nor a third party involved
in an attestation protocol has a reliable solution to detect the attack.
%
On the other hand, only an error within the implementation of the TXT
instructions can lead to a similar scenario\,\cite{wojtczuk2011txtbug}.

\paragraph{Attack Path.}
%
The flash memory lockdown mechanism was based under the assumption that
unlocking the flash memory would force the execution of the \ac{bios}, so that
the latter could lock it again.
%
To that end, the \ac{pch} triggers a \ac{smi} at the same time as it unlocks
the flash memory.
%
This mechanism was introduced at a time when software components could not
ignore \ac{smi}.
%
It turned out this assumption was no longer true with TXT.
%
Indeed, with the first version of TXT, the processor was disabling \ac{smi}
handling.
%
The reasoning behind this design choice was to protect the system software
component from a corrupted \ac{bios} executed in \ac{smm}.
% GUILLAUME: \TODO{La description de l'attaque est trop succinte. Il faut
% répeter que sans SMI, d'après le mécanisme de lock down, cela veut dire que la
% flash est inscriptible mais qu'on ne passe pas en SMM du coup n'importe quel
% logiciel peut modifier le contenu de la flash. C'est un manuscript de
% thèse. Il en faut pas faire (trop) de digression mais il faut être (très)
% pédagogique. Tu n'est pas à une page près!}

\paragraph{Countermeasure.}
%
Recent x86 \acp{cpu} do not disable \ac{smi} when using the \texttt{SENTER}
instructions.
%
This means the system software component continues to rely on the \ac{bios} code
stored in the SMRAM.
%
In practice, even the first version of TXT was not changing that fact.
%
Indeed, the \ac{bios} plays a key role in making sure the computing platform
remains in a working state.
%
As a consequence, Intel was advising system software developers to enable back
\ac{smi} in the TXT Software Development Guide as ``most systems will not
function properly if \acp{smi} are disabled for any length of
time''\,\cite{intel2015txt}.

\subsection{Speed Racer}
\label{subsec:usecase:hse:speed}

Another attack has defeated the flash memory lockdown
protection.
%
In 2015, Corey Kallenberg \emph{et al.} showed that the scenario detailed
previously, such that setting \texttt{BIOSWE} was triggering a \ac{smi} to
suspend the execution of the system software, suffered from a race condition if
two cores cooperate\,\cite{kallenberg2015racecondition}.

\paragraph{Attack Path.}
%
On a typical x86 hardware architecture, all the x86 cores of the platform will
\emph{eventually} enter \ac{smm} when a \ac{smi} is triggered.
%
On the contrary, the \texttt{BIOSWE} is set as soon as the \texttt{BIOS\_CNTL}
register is modified.
%
If two cores cooperate, they can benefit from a sufficient window for action and
successfully tamper with the Flash Memory content.
%
The attack proceeds as follows:

\begin{enumerate}
\item One core tries \emph{ad infinitum} to overwrite the content of the Flash
  Memory.
  %
  Because the \texttt{BIOSWE} bit is initially clear, the \ac{pch} discards its
  attempts, and the Flash Memory content is correctly protected.
%
\item At the same time, another core set the \texttt{BIOSWE} bit.
%
\item A \ac{smi} is triggered, but by the time it propagates to the first core,
  it may have successfully modified the flash memory content.
%
\end{enumerate}

\paragraph{Countermeasure.}
%
To prevent this race condition, Intel has introduced a new configuration bit to
the \texttt{BIOS\_CNTL} register: the \texttt{SMM\_BWP} (\ac{smm} \ac{bios}
Write Protection).
%
If the \texttt{SMM\_BWP} is set, the \ac{pch} discards any write access which
targets the Flash Memory \emph{unless all processors are in \ac{smm}}.

\section{Conclusion}
\label{sec:usecase:conclusion}

In this Chapter, we have detailed the relevant x86 hardware mechanisms involved
in the \ac{hse} mechanism implemented by the \ac{bios} at runtime to stay
isolated from the system software.
%
In addition, we have presented three architectural attacks, to better illustrate
the threats they pose.
%
The rest of this manuscript will use the SMRAM Cache Poisoning Attack as a
recurring application use case for our contributions, because it has motivated
our will to formally specify and verify \ac{hse} mechanisms, and it is a good
illustration of architectural attacks.
