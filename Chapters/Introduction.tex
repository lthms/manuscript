\chapter{Introduction} \label{chapter:introduction}

\endquote{``\emph{All problems in computer science can be solved by another
    level of indirection.}''

  \hfill\footnotesize --- David Wheeler}

\vspace{1cm}\noindent To manage complexity, computing platforms are commonly
built as successions of abstraction layers, from the hardware components which
form a computer up to high-level software applications.
%
Each layer leverages the interface of its predecessor to expose a higher-level,
more constrained set of functionalities for its successors.
%
This enables separation of concerns ---each layer encapsulates one dimension of
the overall complexity--- and modularity ---two layers which expose the same
interface can be seamlessly interchanged---.
%
The typical computing platform can be broken down to the following layers:
%
\begin{description}
\item [Hardware Architecture]
  %
  A computer is made of physical, inter-connected hardware components.
  %
  Hardware components take many form and serve as many purposes, from the
  CPU\,\footnote{\emph{Central Processor Unit}.} which executes the pieces of
  software which form the upper layers of abstraction, to the various
  input/output devices which allow a user to interact with the computing
  platform.
  %
\item [Firmware/BIOS]
  %
  Hardware components often require a dedicated piece of software, called its
  firmware, to function.
  %
  Updating a piece of software is easier than updating a piece of hardware, as
  the latter often requires a recall.
  %
  Vendors can also implement high-level, business focus features to act as sell
  arguments.
  %
  For instance, Intel has started to provide out-of-band management features to
  its processors in 2008.
  %
  In addition, the hardware architecture as a whole is almost always provided
  with a dedicated piece of software which in particular deals with its
  initialization of the computer.
  %
  Afterwards, when we refer to this ``global'' firmware, we use the term
  BIOS\,\footnote{\emph{Basic Input/Output System}.}, whereas firmware is used
  to designate a piece of software tied to a particular hardware component.
\item [System Software]
  %
  The computing environment provided by the hardware architecture alone is very
  generic.
  %
  As a consequence, it requires a non-trivial amount of configuration.
  %
  A system software leverages this environment to provide high-level interfaces
  (\emph{e.g.} system calls), so that applications can focus on business logic,
  and in many case do not care about which particular hardware architecture they
  are executed on.
  %
  In addition, mainstream system software deal with the complexity implied by
  the concurrent execution of several applications.
\item [Applications]
  %
  The previous layers only exist so that application can be executed.
  %
  Thanks to the principle of separation of concerns, they delegate the hardware
  configuration and management to the lower layers of abstraction.
\end{description}

Variations of these abstraction layers exist.
%
For instance, for embedded devices, it is common that the system software and
the applications form one layer.
%
On the contrary, for mainstream computers, the system software can be formed by
an operating system only, or by the combination of one hypervisor and several
operating systems.
%
The latter case is common in the context of cloud computing, as modern
hypervisors bring powerful features such as virtual machines snapshots or
migrations.
%
It is also frequent that application internals are themselves built as
abstraction layers (\emph{e.g.} applicative frawework, core logic, plugins).

\section{Hardware-based Security Enforcement mechanisms}

From this perspective, each layer is often more privileged than, and therefore
implicitly trusted by, its successors.
%
The hardware architecture executes the hardware components' firmware, the
software system and the applications.
%
Hardware implants and backdoors are no fantasy.
%
The BIOS initiates the execution of the system software, and has been used as an
attack vector to tamper with its execution even after a machine restart.
%
The operating system manages the applications life cycle, and actively temper
with their execution (\emph{e.g.} dynamic linking, system calls, etc.).
%
From a security perspective, one layer may constrain its successors' execution,
with respect to targeted security properties.
%
For instance, an operating system shares hardware resources among several
applications, and therefore is able to enforce availability ---fair share of CPU
time---, confidentiality and integrity ---exclusive partition of physical
memories--- properties.

Constraining one's execution can be achieved in various ways.
%
Concerning the lowest layers of a software stack, the common approach is to rely
on features provided by the hardware architecture.
%
In a nutshell, the main idea is to reduce the hardware capabilities one software
can leverage while it is executed.
%
For instance, mainstream operating systems leverage, among others mechanisms, a
\emph{Memory Management Unit} (MMU) to partition the system memory.
%
Thus, when an application is executed, it can only access a portion of the
system memory.
%
In addition, the CPU can leverage a hardware timer to stop applications'
execution, without the need for these applications to cooperate.

We call this class of security enforcement mechanisms, where a trusted software
component configure the underlying hardware architecture to constrain the
execution of untrusted and potentially arbitrary software components,
\emph{Hardware-based Security Enforcement} (HSE).
%
A HSE mechanism enforces its targeted security property when both the hardware
features are correctly implemented and the software components correctly
configure them.

Both remain challenging.

Over the past decades, vendors have added many security features to their
products.
%
Intel, for instance, have notably introduced hardware-based virtualization
(VT-x, VT-d), dynamic root of trust (TXT), or applicative enclaves (SGX).
%
Most of them have been compromised thanks to implementation bugs.
%
This is not surprising, as novel hardware features tend to be more and more
complex.
%
At the same time, it has been repeatedly shown that vendors were not always
correctly taking advantage of important hardware features at their disposal.
%
These lacks of hardware configuration put the affected computing platforms at
risk.
%
Many security vulnerabilities disclosed over the years have been the result of a
misconfiguration of hardware features by key software components.

In addition to these implementation errors, the fact that hardware architecture
often comprise hundreds of features implemented by dozens of interconnected
devices paves the road for a class of security vulnerabilities we call
\emph{architectural attacks}, where each component is working as expected, yet
their composition creates an attack path.
%
For instance, the integrity feature of the SPI Flash (where lives the hardware
architecture firmware) was based on a particular hardware interrupt; from this
perspective, the Intel TXT feature had the undesirable side-effect of disabling
this hardware interrupt.
%
Architectural attacks differ from implementation errors, because it concerns the
specifications of the computing platform.

\section{Towards Formal Verification}

In this thesis, our initial objective is to formally specify HSE mechanisms,
which implies defining both the targeted security property and the required
configuration steps trusted software components have to perform.
%
The expected result is an unambiguous, security-focused specification which can
be leveraged by software developers.
%
It would be an advantageous complement to the existing hardware specifications,
as the latter are often made of many independent, large documents (\emph{e.g.}
datasheets, developer manuals).

This initial specification effort shall serve as a premise for further
verification work for both the hardware architecture and the trusted software
components, and our long term objective is to develop verification approaches
guided by HSE mechanisms specifications.
%
We want to be able to prove that a given HSE mechanism is correct, meaning if
both the hardware components and the trusted software components correctly
implements their specifications, then the targeted security property is indeed
enforced.
%
Because the source of architectural attacks is the great number of concurrent
hardware features, this second objective obliges us to consider the hardware
architecture as a whole.
%
Several facts encourage us to particularly care about modularity of both
specifications and proofs:
%
the scale of the task for one hardware architecture in particular;
%
the frequent releases of new versions of key hardware components;
%
the presence of the same hardware components in several different hardware
architecture families.

In the context of this thesis, our approach has been to propose generic
formalisms dedicated to tackle a particular class of problem, then to apply
these proposals to examples coming from real life vulnerabilities of the x86
hardware architecture.
%
Because of its predominant position on the personal computer market, x86-based
products have been intensively studied from a security standpoint.
%
To write our proofs of concepts, we have decided to leverage the Coq proof
assistant framework.
%
Our choice is motivated by the following reasons:
%
\begin{itemize}
\item {\sc Gallina}, the specification of Coq, is an expressive formal language,
  that combines both a higher-order logic and Ã  powerful dependent type system,
  while {\sc Ltac}, the proof tactic language of Coq, enables powerful
  automation features.
\item The extraction mechanism of Coq allows for transpiling formal
  specifications written in {\sc Gallina} to {\sc Ocaml}, meaning we can write
  \emph{executable specifications}. We can leverage this feature in many ways,
  \emph{e.g.} to validate a hardware component model against a real
  implementation, or to write a formal specifications of trusted software
  components to be turned into concrete implementations once verified.
\item \thomasrk[inline]{EAL7 France? Maybe a bit premature...}
\end{itemize}

\section{Contributions}

This thesis proceeds as follows.
%
We describe in more detail x86-based computing platforms, along with HSE
mechanisms commonly used in this context and several architectural attacks
disclosed over the past decade (Chapter\,\ref{chapter:usecase}).
%
In particular, we introduce the SMRAM Cache Poisoning, to act afterwards as a
running example for our contributions.
%
Then, we detail how this thesis is in line with an ongoing effort to build more
reliable hardware components, including from a security standpoint
(Chapter\,\ref{chapter:relatedwork}).

Once we have established the research context of this thesis, we detail our
contributions.
%
We first introduce a formalism to specify a HSE mechanism against hardware model
(Chapter ???).
%
Then, we detail our effort to implement this formalism in Coq, including a
generic-purpose framework and a proof of concept based on the SMRAM Cache
Poisoning attack (Chapter ???).
%
\thomasrk[inline]{End of chapter to be written.}
