%!TEX root = ../main-mini.tex
\chapter{Introduction}
\label{chapter:introduction}

\endquote{``\emph{All problems in computer science can be solved by another
    level of indirection.}''

  \hfill\footnotesize --- David Wheeler}

\vspace{1cm}\noindent
%
\TODO{Attention, software, hardware et firmware sont normalement indénombrable
  en anglais. Il faut que tu identifies les manières idiomatique d'utiliser ces
  termes.}
%
To manage complexity, computing platforms are commonly built as successions of
abstraction layers, from the hardware components to high-level software
applications.
%
Each layer leverages the interface of its predecessor to expose a higher-level,
more constrained set of functionalities for its successors.
%
This enables separation of concerns ---each layer encapsulates one dimension of
the overall complexity--- and modularity ---two layers which expose the same
interface can be seamlessly interchanged.
%
The typical computing platform can be broken down to the following layers:
%
\begin{description}
\item [Hardware Architecture]
  %
  A computer consist is made of several inter\-connected, physical hardware
  components.
  %
  Hardware components take many forms and serve as different purposes, from the
  \ac{cpu}, which executes the pieces of software which form the upper layers of
  abstraction, to the various input/output devices, which allow a user to
  interact with the computing platform.
  %
\item [Firmware/BIOS]
  %
  Hardware components often require some firm\-ware, \emph{i.e.} a dedicated
  piece of software, to operate.
  %
  Hardware manufacturers tend to embed some features in their firmware for
  several reasons.
  %
  For starters updating software is easier than updating hardware, as the latter
  often requires a recall.
  %
  Vendors can also implement additional high-level, business focus features in
  their firmware to differentiate from competitors.
  %
  For instance, Intel has started to provide out-of-band management features to
  its processors in 2008\,\cite{ruan2014me}.
  %
  In addition, some firmware is responsible for the initialization of the
  platform as a whole.
  %
  Afterwards, when we refer to this specific type of firmware, we use the term
  \ac{bios}.
  %
  \TODO{Dire qu'aujourd'hui la plupart des BIOS respecte le standard UEFI.}
  %
\item [System Software]
  %
  The computing environment which is provided by the hardware architecture alone
  is very generic.
  %
  As a consequence, it requires a non-trivial amount of configuration.
  %
  System software leverages this environment to provide high-level interfaces
  (\emph{e.g.} system calls), so that applications can focus on business
  logic. Thus, applications often do not care about which particular hardware
  architecture they are executed on.
  %
  In addition, system software deal with the complexity implied by the
  concurrent execution of several applications.
  %
\item [Applications]
  %
  Applications leverages the high-level interface exposed by system software in
  order to provide a service to the user of the computing platform.
  %
  The previous layers only exist so that applications can be executed.
\end{description}

Variations of these abstraction layers exist.
%
For instance, for embedded devices, it is common that the system software and
the applications form one single layer.
%
On the contrary, for mainstream computers, the system software can be formed by
an operating system only, or by the combination of one hypervisor and several
operating systems.
%
The latter case is common in the context of cloud computing, as modern
hypervisors (\emph{e.g.} Xen, Hyper-V) bring powerful features such as virtual
machines snapshots or migrations. \TODO{ajouter des références. De quels
  hyperviseurs veux tu parler?  c'est un peu flou}
%
It is also frequent that application internals are themselves built as
abstraction layers (\emph{e.g.} applicative framework, core logic, plugins,
etc.).

\TODO{Rajouter une jolie figure pour illustrer cet empilement de couches et y
  faire référence dans le texte}

\section{Hardware-based Security Enforcement mechanisms}

From a security perspective, each layer is often more privileged than its
successors.
%
For instance, system software manages the life cycle of the applications, by
actively tampering with their execution.

As a consequence, each layer implicitly trusts its predecessors.
%
On the one hand, it is important to keep this fact in mind when we consider the
security of the computing platform.
%
Trust in lowest levels of abstraction can be misplaced: hardware implants and
backdoors are no fantasy\,\cite{yang2016a2}, the \ac{bios} has been used as an
attack vector to tamper with its execution even after a machine
restart\,\cite{embleton2013smm}, etc.
%
On the other hand, one layer may constrain the execution of its successors
execution, with respect to a targeted security policy.
%
For instance, an operating system shares hardware resources among several
applications, and therefore is able to enforce availability ---fair share of
\ac{cpu} time---, confidentiality and integrity ---exclusive partition of
physical memories--- properties.

Constraining an execution can be achieved in various ways.
%
Concerning the lowest layers of a software stack, the common approach is to rely
on features provided by the hardware architecture.
%
In a nutshell, the main idea is to reduce the hardware capabilities one software
can leverage while it is executed.
%
For instance, system software often leverages among other mechanisms a \ac{mmu}
to partition the system memory.
%
Thus, when an application is executed, it can only access a subset of the system
memory.
%
In addition, the \ac{cpu} can leverage a hardware timer to stop applications'
execution, without the need for these applications to cooperate.

\begin{definition}[Hardware-based Security Enforcement]
  We call \ac{hse} the class of security enforcement mechanisms where a trusted
  software component configure the underlying hardware architecture to constrain
  the execution of untrusted software components with respect to a targeted
  security policy.
\end{definition}

A \ac{hse} mechanism enforces its targeted security property when
%
\begin{inparaenum}[(1)]
\item the trusted software components correctly configure the hardware features
  at their disposal, and
%
\item these features are sufficient to constrain the untrusted software
  execution as expected.
\end{inparaenum}
%
Both remain challenging.

\paragraph{Software Errors.}
%
Many facts can explain this state of things.
%
In the past, lower-level pieces of software, such as firmware components, may
not have been conceived and implemented with security as a primary focus.
%
The increasing complexity of hardware architectures can also be held partly
responsible.s
%
While one computer can be made of dozens of components, software developers have
to read and understand as many, independent and often large documents of various
forms (\emph{e.g.} data sheets, developer manuals), and they rarely focus on
security.
%
When software developers misunderstand the documentation, as it happened for
instance for the \texttt{MOV SS} and \texttt{POP SS} x86
instructions\,\cite{movsspopss}, the impact in terms of security can be
important.

\paragraph{Hardware Errors.}
%
Over the past decades, vendors have regularly added security features to their
products.
%
Intel, for instance, has notably introduced hardware-based virtualization (VT-x,
VT-d)\,\cite{intel2014manualvt}, dynamic root of trust
(TXT)\,\cite{intel2015txt}, or applicative enclaves
(SGX)\,\cite{intel2014manualsgx,costan2016sgxexplained}.
%
It is important to notice that most of them have been compromised due to
implementation bugs\,\cite{wojtczuk2011txtbug,sang2010iommu}.
%
This is not surprising, as novel hardware features tend to be more and more
complex.
%
Hence, using advanced, novel hardware features, in a security-sensitive context,
may be counterproductive.
%
In addition to these implementation errors, the fact that hardware architecture
often comprises hundreds of features implemented by dozens of interconnected
devices complicate the conception of new hardware features.
%
Indeed, the latter should not interfere with the security properties enforced by
the features which were present before.
%
For instance, the Flash Memory (where lives the \ac{bios} code) is supposedly
protected against arbitrary write accesses from system software.
%
This protection relies on a particular hardware interrupt.
%
This did not prevent Intel to introduce TXT, a novel security mechanism which
had the particular side effect of disabling this hardware interrupt.

\begin{definition}[Architectural Attack]
  We call Architectural Attacks the class of security vulnerabilities, where
  each component is working as expected, yet their composition creates an attack
  path untrusted software components can leverage to defeat a \ac{hse} mechanism
  implemented to constrain its execution.
\end{definition}

Architectural attacks result in a flaw in the specifications of the computing
platform.
%
As such, they precede implementation errors, and their countermeasures often
require a change in the hardware interface.
%
To prevent them, it is mandatory to reason about the computing platform as a
whole.

\section{Formal Verification of HSE mechanisms}
\label{sec:intro:verif}

The important impact of previously disclosed architectural attacks have
motivated our will to formally specify HSE mechanisms.
%
We believe this would benefit both hardware designers and firmware and system
software developers.
%
Firstly, a formal specification of HSE mechanisms can be leveraged as a
foundation for a systemic approach to verify hardware specifications.
%
For each novel hardware feature introduced, it would be necessary to check that
the previous proofs hold, meaning this feature does not introduce an
architectural attack.
%
Secondly, it provides unambiguous specifications to software developers.
%
We believe these specifications can be a valuable addition to the existing
documentation, because they gather at one place information that is normally
scattered across many documents.

To specify a HSE mechanism, we have to model the hardware architecture, and the
scale of the task represents an important challenge.
%
Because architectural attacks often come from unsuspected places, it is
necessary to consider the whole computing platform; at the same time, many
components are individually complex.
%
In addition, new hardware components are frequently released, and the same
hardware component can be found in different hardware architecture to play a
similar role.
%
As a consequence, the more modular our models and proofs are, the more
practicable our approach becomes.

\paragraph{}
%
While we have tried to propose generic formalisms which can potentially be
applied to large ranges of problems, we have adopted the systemic approach to
apply them to the x86 hardware architecture.
%
Because of its predominant position on the personal computer market, the x86
hardware architecture has been intensively studied.
%
Our decision to explore this research field was based on our experience with
several architectural attacks which have affected x86-based computing platform
x86 hardware architecture.
%
We have implemented our proofs of concepts in the Coq proof assistant.
%
Our choice is motivated by the following reasons:
%
\begin{itemize}
\item {\scshape Gallina}, the specification of Coq, is an expressive formal language,
  that combines both a higher-order logic and à powerful dependent type system,
  while {\scshape Ltac}, the proof tactic language of Coq, enables powerful
  automation features.
  %
  This suits well for specifying security properties to be enforced by HSE
  mechanisms, as they can take many forms.
\item The extraction mechanism of Coq allows for transpiling formal
  specifications written in {\scshape Gallina} to OCaml, meaning we can write
  \emph{executable specifications}.
  %
  In theory, we can leverage this feature to validate a model against a real
  implementation.
  %
  Because we focus on products which already exist, rather to intervene prior to
  their implementation, this possibility is worth taking into account.
\end{itemize}

\section{Notations}

As far as possible, we have tried to remain consistent while writing this
thesis.

\paragraph{Conventions}
%
We often define sets of values, and interfaces in particular, in terms of
functions to construct these values.
%
These functions are called ``constructors,'' and they have mutually exclusive
images, i.e. it is not possible to construct the same value with two different
constructors.
%
Functions are written in bold.
%
In addition, constructors begin with a capital letter.

\paragraph{Named Tuples}
%
We adopt a notation similar to Haskell record types to manipulate ``named''
tuples, that is tuples where each component is a field identified by a name.

\[
  \begin{array}{rccll}
    A & \triangleq & \{ & \func{field_1}: & T_1 \\
      &            & ;  & \func{field_2}: & T_2 \\
      &            & \} &
  \end{array}
\]

For $a \in A$, we write $a.\func{field_1}$ for selecting the value of the
\func{field_1} field. We write $a \{ \func{field_1} \leftarrow t \}$ for
updating the value of the field \func{field_1}. As a consequence,
%
\[
  a \{ \func{field_1} \leftarrow t \}.\func{field_1} = t
\]

\section{Contributions and Outline}

Our works fall within a context where the security of lower levels of
abstraction grows in importance.
%
In Chapter~\ref{chapter:usecase}, we describe in more detail the x86 hardware
architecture, and a selection of representative architectural attacks which have
been disclosed over the past decade.
%
In Chapter~\ref{chapter:relatedwork}, we revisit existing works and approaches
in line with the two challenges we tackle in this thesis, that is:
%
\begin{inparaenum}[(1)]
\item formally specifying and verifying \ac{hse} mechanisms against a hardware
  model, and
%
\item defining hardware models which can remain exploitable in presence of large
  architecture hardware.
\end{inparaenum}

In Chapter~\ref{chapter:speccert}, we present a generic formalism to specify and
verify against a hardware model HSE mechanism whose purpose is to isolate
trusted software components execution from the rest of the software stack.
%
We have implemented SpecCert, a framework for the Coq proof assistant based on
this formalism. In addition, we have implemented {\scshape Minx86}, a minimal
x86 model, and we have verified the HSE mechanism implemented by x86 BIOSes.
%
This work has been presented at the $21^{th}$ International Symposium on Formal
Methods (FM2016)\,\cite{letan2016speccert}.

In Chapter~\ref{chapter:freespec}, we present a systemic approach to specify and
verify large systems, organized as trees of components, in a modular way.
%
We apply ideas from verification of computer programs with side effects to the
domain of component-based modelling, and the resulting approach can be used both
for verifying the composition of hardware components and software components
alike.
%
In addition, we have developed FreeSpec, a framework for the Coq proof
assistant.
%
FreeSpec provides the necessary definitions and theorems to specify components,
and automation features to guide their verification.
%
This work has been presented at the $22^{th}$ International Symposium on Formal
Methods (FM2018)\,\cite{letan2018freespec}.

Finally, we conclude this thesis in Chapter~\ref{chapter:conclusion}, where we
suggest some possible directions for future works.
