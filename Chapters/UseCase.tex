\chapter{Intel x86 Hardware and BIOS Background}
\label{chapter:usecase}

Our motivation to formally specify and verify architectural attacks comes from
our experience with the x86 hardware architecture.
%
Over the past decade, the security of the lower levels of abstraction (hardware,
firmware, system software) has grown in importance, and several critical
vulnerabilities which fall in our definition of architectural attacks have been
disclosed.
%
While our contributions are intended to be applicable to other hardware
architectures, for purposes of evaluating our work, we have adopted the systemic
approach to apply them to a x86 real example.
%
We have chosen to focus on the HSE mechanism implemented by the BIOS at runtime
to stay isolated from the rest of the software stack, including the system
software.
%
Because the BIOS is the most privileged piece of software executed by the
hardware architecture, this HSE mechanism is of key importance.
%
Despite this fact, it has been defeated several times, and therefore, it
illustrates perfectly our motivations.
%
However, it is important to emphasize that other mainstream architectures
(\emph{e.g.}  ARM) work on similar basis and suffer similar issues.

The rest of this Chapter proceeds as follows.
%
We describe how a typical x86 hardware architecture is organized, and the
consequences of this organization in terms of security
(Section~\ref{sec:usecase:architecture}).
%
We then focus on the key role played by the \ac{bios}
(Section~\ref{sec:usecase:firmware}).
%
Once the role of the \ac{bios} has been established, we detail HSE mechanisms it
implements, and several architectural attacks which have defeated these HSE
mechanisms in the past (Section~\ref{sec:usecase:hse}).

\section{Hardware Architecture Overview}
\label{sec:usecase:architecture}

Describing hardware architectures in depth is challenging, because they tend to
be made of many inter-connected components of various nature.
%
From this perspective, the x86 hardware architecture is a textbook case, and
this is probably best illustrated by the scale of its documentation.
%
At the time of writing this thesis\,\footnote{Spring 2018.}, the \emph{Intel 64
  and IA-32 Architectures Software Developerâ€™s Manual} is 4842 pages long.
%
Executed on the computer used to write the present thesis, the GNU/Linux
command-line application \texttt{lshw} lists about 30 hardware components, which
come with their own documentations, often in the form of large datasheets.

A x86 computing platform is built upon two key components: \acp{cpu} and memory
(\ref{subsec:usecase:cpumem}).
%
The \ac{cpu} communicates with peripherals to interact with the outside world
(\emph{e.g.} another computing platform, a user) (\ref{subsec:usecase:perif}).

\subsection{Processors and Memory}
\label{subsec:usecase:cpumem}

A computer platform goal is to execute programs to perform arbitrary tasks.
%
To that end, it relies on one or more \acp{cpu}.
%
A \ac{cpu} takes so-called ``instructions'' as input, and manipulates its
internal states and data stored in a memory, as output
%
A program is a sequence of instructions, often stored in the same memory as the
data it manipulates.
%
Overall, a \ac{cpu} basically repeats the following task, over and over:

\begin{enumerate}
\item Read the content of its (internal) \emph{program counter} register, and
  interpret it as the address of the next instruction.
%
\item Fetch the content of this address from memory.
%
\item Decode the instruction, that is identified the desired operation to
  perform
%
\item Act accordingly, by modifying its internal state, and interacting with the
  memory.
%
\item Update the content of its \emph{program counter} register according to the
  semantics of the instruction it has executed. Most of the time, it increases
  it to fetch the next instruction, but it can also set it to an arbitrary value
  (\emph{e.g.} with jump instructions).
\end{enumerate}

From the \ac{cpu} perspective, the memory is abstracted into a contiguous array
of storage cells, identified by an address.
%
A \ac{cpu} can interact with the memory by reading at or writing to a given
address.
%
In reality, a hardware architecture contains several memories of various nature.
%
The \ac{dram} remains the most important, and is often called the \emph{system
  memory}, but it is not the only memory present in a hardware architecture.
%
Peripherals expose memories too; the latter are used as communication channels
between them and the \acp{cpu}.
%
That is, to ``receives a message'' from a peripheral, a \ac{cpu} reads the
content of the memory it exposed, while it can ``send a message'' by writing to
the same memory.

% Interacting with the \ac{dram} remains slow, in regard to the speed of a
% \ac{cpu}
%%
% To improve performance, Intel \acp{cpu} come with several (often three) levels
% of caches, from the smaller and quicker, to the bigger and slower.
%%
% For cache-friendly programs, the gain in performance can be huge.
%%
% This gain is paid in important increase of complexity.
%%
% Enforcing coherence between the different levels of cache and the \ac{dram} is
% not trivial.

\paragraph{}
%
Historically, x86 \acp{cpu} were using two distinct memory spaces to communicate
either with the \ac{dram} or with the peripherals, \emph{via} two families of
instructions.
%
Nowadays, the memories exposed by the peripherals are mapped within the same
address space, and accessed with the same instructions.
%
That is, when a \ac{cpu} read at or write to an address, the access is
transparently dispatched either to the \ac{dram} or to a peripheral.
%
The first component to intervene in the decision process is the Memory
Controller (formally known as the \emph{northbridge}, and now integrated to the
\ac{cpu} Die).
%
The Memory Controller is connected to the \ac{dram} and to peripherals which
require small latency, such as a graphic card or a ethernet controller.
%
If a given memory access does not target one of its peripherals or the
\ac{dram}, the Memory Controller forwards the memory access to the Platform
Controller Hub (PCH) (formally known as the \emph{southbridge}).
%
The PCH acts as a proxy for the remaining peripherals.

\paragraph{}
%
One important property of x86 hardware architecture is that the memory map,
which is the correspondence between the addresses used by the \ac{cpu} and the
storage cells scattered among the hardware architecture, is dynamically
configurable.
%
As such, determining which hardware component will receive a given memory access
is far from being trivial.

\subsection{Active Peripherals}
\label{subsec:usecase:perif}

It is worth mentioning that, since 2008, Intel embeds the Management Engine, a
processor \emph{inside} the memory controller.
%
The Management Engine executes a complete software stack, is capable of
interacting to the \ac{dram} as well as other hardware components.
%
Intel leverages the Management Engine to provide out-of-band management
solution, which means it can interact with the rest of the world without the
cooperation of the main \ac{cpu}.
%
Although the Management Engine supposedly operates in a transparent manner from
the \ac{cpu} perspective, we emphasize that a Management Engine vulnerability, a
scenario which is not without precedent, potentially defeats any security
measures implemented at the \ac{cpu} level.

The security threat posed by the Management Engine is not an isolated case.
%
On the contrary, x86 hardware architectures contain several \emph{active}
peripherals.
%
We say a peripheral is active if it can autonomously read at and write to the
system memory, using a feature called \ac{dma}.
%
This feature brings an important performance improvement, but it also opens an
important surface of attacks.

Historically, peripherals have been part of the \ac{tcb} of every x86 HSE
mechanisms, with important consequences on the computing platform security.
%
For instance, Loic Duflot \emph{et al.} have been able to take control of a
network card, because the piece of software responsible for processing network
packets was vulnerable\,\cite{duflot2010network}.
%
Because the network card can perform \ac{dma}, they were able to tamper with the
system software code and data.
%
It has also been repeatedly shown that the various physical interface exposed by
the computer (\emph{e.g.} USB\,\cite{nohl2014badusb},
Thunderbolt\,\cite{hudson2015thunderstrike}, PCI\,\cite{chifflier2013uefi})
could be leveraged to achieve similar goals.

In that respect, the current situation has improved.
%
Modern x86 \acp{cpu} provide a feature called I/O MMU, which allows for
configuring the memory ranges each peripheral can access to.
%
In addition, Intel tends to take rogue peripherals into account when it
conceives new security features.
%
A good example is the \ac{sgx} technology, whose \ac{tcb} is limited to the
\ac{cpu} and its Memory Controller\,\cite{costan2016sgxexplained}.

\subsection{Security Properties}

From a security perspective, the attack surface on x86 computing platform is
large.
%
The different software components which form the software stack are executed by
the same \acp{cpu}, the instructions which form their programs are stored within
the same memories, which they also manipulate concurrently \emph{via} a
configurable memory map.
%
In addition, active peripherals can also access the main memory concurrently.
with the \ac{cpu}, and they tend to be part of the \ac{tcb}.
%
As a consequence, most of the HSE mechanisms implemented in x86 computing
platforms aim to enforce isolation properties, to prevent untrusted software
components to tamper with the execution of trusted ones.
%
These isolation properties can take three forms.

\begin{definition}[Integrity]
  The trusted software component is assigned a portion of the memory map.
  %
  Untrusted software components cannot tamper with the result of read accesses
  targeting this portion and performed by the trusted software component,
\end{definition}

\begin{definition}[Confidentiality]
  The trusted software component is assigned a portion of the memory map.
  %
  It can hide its secrete inside this portion, and untrusted software components
  cannot get these secretes from the result of a read access.
\end{definition}

Integrity and confidentiality properties have to be considered from an
information flow perspective.
%
The content of specific storage cells inside the hardware architecture is less
relevant than the logical view exposed to the \acp{cpu}.

\begin{definition}[Availability]
  An untrusted software component cannot prevent the execution of a trusted
  software component
\end{definition}

On the contrary, there are complete classes of security properties which are not
covered by HSE mechanisms.
%
The most famous is probably non-interference properties, notably defeated
\emph{via} side-channel attacks (\emph{e.g.} cache-timing attacks). Indeed,
Intel documentations clearly state:

\begin{quote}
  The Intel architecture aims to provide protection against software
  side-channel attacks at the cache line granularity.

  \hfill\small \emph{Intel Software Guard Extensions, Developer Guide}
\end{quote}

Because computer programs rarely fit inside a cache line, preventing
side-channel attacks therefore additional software-based security enforcement
mechanisms.

\section{BIOS Overview}
\label{sec:usecase:firmware}

The \ac{bios} plays a significant role in Intel x86 computing platform.
%
It is the first piece of software executed by the \ac{cpu}, and initiates both
the hardware architecture and the system software execution during the boot
sequence (\ref{subsec:usecase:firm:boot}).
%
At runtime, it remains active to perform various tasks, including and not
limited to platform-specific events, device emulation, \ac{bios} update
management (\ref{subsec:usecase:firm:runtime})
%
As such, it is a natural part of the rest of the software stack \ac{tcb}.
%
It is kept isolated from the rest of the software stack thanks to several HSE
mechanisms, whose correctness is essential for the overall security of the
platform (\ref{subsec:usecase:firm:hse}).

\subsection{During the boot sequence}
\label{subsec:usecase:firm:boot}

The \ac{bios} program is stored inside a flash memory, a small memory connected
to the PCH through the Serial Peripheral Interface (SPI) bus on modern x86
computing platform.
%
When the \ac{cpu} is power up, it is programmed to fetch the code stored at a
hard-coded address within the flash memory.
%
The first task of the \ac{bios} is to initiate the hardware architecture,
starting with the \ac{dram}.
%
Once the hardware components of the computing platform have been initiated, the
\ac{bios} searches for a system software to load into memory.
%
Historically, ``legacy'' \acp{bios} were looking for a Master Boot Record (MBR)
at the beginning of mass storage devices (\emph{e.g.} hard drive, USB stick).
%
The MBR, whose size is limited to 512 bytes, contains a small program to
initiate a loader for the system software.
%
Modern \acp{bios} implement the \ac{uefi}, whose purpose is to standardize the
boot sequence process in order to favour interoperability of \ac{bios}
implementations.
%
In particular, UEFI-compliant \ac{bios} can load so-called UEFI applications of
arbitrary size, leading modern operating systems to be packaged as UEFI
applications.

The \ac{uefi} standard includes several interesting security mechanisms.
%
For instance, it defines a protocol called the Secure Boot, which can be
leveraged to improve the security of the boot sequence.
%
If Secure Boot is enable, the UEFI-compliant \ac{bios} will only execute
applications which provide an acceptable cryptographic signature, with respects
to a key hierarchy configurable by the computing platform owner.
%
Ironically, the \ac{uefi} standard makes it easier to write portable piece of
software which can be executed prior to any system software.
%
As a consequence, it increases the attack surface of the computing platform, in
case of bad \ac{bios} configuration (\emph{e.g.} Secure Boot is disabled).

\subsection{At runtime}
\label{subsec:usecase:firm:runtime}

Once a system software has been selected and loaded into memory (ideally,
without any tampering from the \ac{bios}), the boot sequence ends, and the
runtime begins.
%
At runtime, the system software is in charge of the \ac{cpu} control flow,
meaning it decides which piece of software is executed at a given time.
%
However, the \ac{bios} remains active.

Firstly, it provides a software interface to the system software.
%
Some of these \emph{runtime services}, as they are called by the \ac{uefi}
standard, can be leveraged by the system software as an intermediary layer to
interact with the hardware architecture.
%
In doing so, it reduces the coupling between the system software and the
hardware components.
%
Other runtime services are mandatory gates towards certain computing platform
features.
%
For instance, software update for the \ac{bios} code are performed by the
\ac{bios} itself, so that the latter can validate the validity of the update.

Secondly, the \ac{bios} often needs to operate independently of the system
software.
%
For instance, it manages platform-specific events whose internals are not
publicly documented.
%
Some \acp{bios} also emulate complete hardware devices, in a transparent manner
from the system software perspective.
%
The \ac{bios} autonomy from the system software has important consequences in
terms of security.
%
Software vulnerabilities affecting the \ac{bios} can potentially by used by an
attacker to take complete control over the software stack executed by the
\ac{cpu}.

\subsection{Security Properties and HSE Mechanisms}
\label{subsec:usecase:firm:hse}

The \ac{bios} isolation at runtime is enforced thanks to the \ac{smm} of x86
\ac{cpu}.
%
Intel describes it as follows (the emphasis is ours, and does not exist in the
original document):

\begin{quote}
  \ac{smm} is a special-purpose operating mode provided for handling system-wide
  functions like power management, system hardware control, or proprietary
  OEM-designed code.
  %
  It is intended for use only by system firmware, not b applications software or
  general-purpose systems software.
  %
  \textbf{The main benefit of \ac{smm} is that it offers a distinct and easily
    isolated processor environment that operates transparently to the operating
    system or executive and software applications.}
\end{quote}

To handle several level of privileges, Intel \ac{cpu} provides several execution
modes.
%
An execution mode can be roughly assimilated to a set of hardware capabilities.
%
Hence, in a given execution mode, a \ac{cpu} may refuse to execute certain
assembly instructions.
%
As a consequence, the software component executed will not be able to leverage
the side-effects involved by the execution of these instructions, \emph{e.g.}
access to specific hardware registers (like the one related to paging).
%
The execution modes are not ''linear''.
%
On the contrary, they can be seen as a composition of several hardware features:
ring levels, virtualization technology, and finally \ac{smm}.
%
This means you can be in ring~0, while in hypervisor mode, while in \ac{smm},
for instance.

\paragraph{System Management Mode}
%
The main objective of the \ac{smm}, as stated by the Intel Developer Manual, is
to provide an `isolated processor environment'', dedicated to ``system
firmware'', and that should ``operate transparently to the operating system''.
%
To provide these features, \ac{smm} relies on two things: the SMRAM and the
\ac{smi}.

The SMRAM is a special memory region within the DRAM, dedicated to the \ac{smm}.
%
It is supposed to contain the \ac{bios} code, and its private data;
%
as a consequence, it should not be accessible to a \ac{cpu} which is not in
\ac{smm}.
%
The exact location and size of the SMRAM is architecture dependent.
%
To locate it, the \ac{cpu} has a register named \texttt{SMBASE}, to be
configured by the \ac{bios} during the boot sequence.
%
As its name implies, the \texttt{SMBASE} value should point to the base of the
SMRAM.
%
It is then up to the \ac{bios} developer to appropriately write its so-called
\ac{smm} code (that is, the code supposedly executed in \ac{smm} at runtime)
knowing the limitation of the SMRAM of the targeted architecture.

The \ac{smi} is a hardware interrupt which makes the \ac{cpu} enters \ac{smm}.
%
More precisely, when a \ac{cpu} receives a \ac{smi}, it saves its current state
(\emph{e.g.} registers, execution mode, etc.), either in the SMRAM or, for most
recent versions, in dedicated register of the \ac{cpu}.
%
Once this preliminary step is done, the \ac{cpu} reconfigures itself;
%
in particular, it sets its program counter register, that is, the register which
indicates from which address to fetch the next instruction it shall execute, to
$\texttt{SMBASE} + 0x8000$\thomasrk{Ã€ vÃ©rifier.}.
%
From this point, the \ac{cpu} is in \ac{smm} and starts to execute what should
be the \ac{smm} code.
%
Once the \ac{smm} code has performed the task it has been requested for, the
\texttt{rsm} instruction can be used.
%
The instruction, which can be used only in \ac{smm}, tells the \ac{cpu} to
restore its previous state.
%
This way, the execution of the pieces of software previously halted by the
\ac{smi} can resume.
%
From the system point of view, it is like if nothing has happened.

\section{Examples of x86 Architectural Attacks}
\label{sec:usecase:hse}

The combination of the SMRAM and the \ac{smi} explains why the \ac{smm} is often
introduced as the ``most privileged execution mode'' of a x86 \ac{cpu}.
%
In a nutshell, the \ac{smm} code can do all the thing the system software does,
including arbitrary memory locations which belongs to that system software, but
the system software cannot modify the SMRAM content.
%
In addition, the \ac{smi} is not a maskable interrupt, so the system software
cannot prevent the execution of the \ac{smm} code.
%
In other words, both the integrity of the SMRAM and the availability of the
\ac{smi} are the foundation of the \ac{smm} security.
%
Because they have been both defeated at repeated occasions, this makes the
\ac{smm} particularly interesting to illustrate the concept of architectural
attacks.

\paragraph{SMRAM Cache Poisoning Attack}
%
From the beginning, the integrity of the SMRAM has been enforced by the Memory
Controller of the x86 architecture, whether it is a dedicated hardware component
(northbridge), or more recently a part of the \ac{cpu}.
%
The Memory Controller main purpose it to act as a proxy for the \ac{cpu} memory
accesses.
%
It receives the \ac{cpu} memory accesses, and dispatches them among the
different hardware components which expose memory.

The Memory Controller exposes a configuration register called the
\texttt{SMRAMC}, whose purpose is to configure the access control configuration
of the SMRAM.
%
At the beginning of the boot sequence, the SMRAM is said to be opened, which
means it can be access by the \ac{cpu} whether it is in \ac{smm} or not.
%
This allows the \ac{bios} to load the \ac{smm} code inside the SMRAM, as the
\ac{cpu} is not itself in \ac{smm} at the beginning of the boot sequence.
%
Once the loading is done, the \ac{bios} can ``close'' the SMRAM, meaning only a
\ac{cpu} in \ac{smm} can access to the SMRAM.
%
It can also lock the SMRAMC, to prevent further piece of software (say, a
malicious or exploited system software) to open the SMRAM in order to tamper
with its content.

Between 1986\thomasrk{Verify the date}, when the \ac{smm} has first been
introduced, and 2009, it was believed that the \texttt{SMRAMC} register enough
was sufficient to ensure the integrity of the SMRAM.
%
Loic Duflot \emph{et al.}\,\cite{duflot2009smram} and Rafal Wojtczuk \emph{et
  al.}\,\cite{wojtczuk2009smram} have independently shown this belief was
misplaced, thanks to the so-called \emph{SMRAM Cache Poisoning Attack}.
%
In addition to the evocative name, Figure~\ref{todofig} highlights the
vulnerability concept.
%
To increase performance, the \ac{cpu} uses a cache of its memory accesses.
%
That is, when it reads memory, it stores the result of this access within a
cache.
%
Then, when it has to read at the same location again, it gets the result from
the cache directly, whose access time is way lower than regular DRAM.
%
A similar scheme applies to write accesses.

As a consequence, regarding a \ac{cpu} configuration, copies of the SMRAM
content may be found in the cache.
%
These copies were not protected by the Memory Controller, meaning the system
software could tamper with them, even while not in \ac{smm}.
%
This attack is a perfect illustration of an architectural attack:
%
both the Memory Controller and the Cache work as expected.
%
The first one prevent an authorized access by a \ac{cpu} not in \ac{smm};
%
The second one keeps copies of successful accesses to decrease latency due to
memory accesses.
%
However, once put together, they paves the road toward a successful tampering of
the SMRAM by a system software.

The solution implemented by Intel to prevent further exploitation of this
vulnerability was to modify the behavior of the Cache, when the memory accesses
target the SMRAM;
%
and because the SMRAM size and location remain specific to each architecture,
this means it requires an additional step of configuration to tell the cache
where the SMRAM is.

What is interesting about the SMRAM Cache Poisoning is that another x86
vulnerability\,\cite{domas2015sinkhole} has been since disclosed.
%
It also allows to trick a \ac{cpu} in \ac{smm} to execute arbitrary
instructions, but leaves the content of the SMRAM in DRAM untouched.
%
In this case, it leverages the fact that the configuration registers of the
\ac{apic}, a component of the \ac{cpu}, can be mapped in memory.
%
An attacker can use them to mask the real content of the SMRAM, even to a
\ac{cpu} in \ac{smm}.
%
Again, the complexity implied by the composition of several hardware components
can be used in a harmful way.


\paragraph{}
%
The isolation provided by the \ac{smm} is not an end in itself.
%
In fact, it has become the basis upon which other HSE mechanisms have been
implemented.
%
One good example is the HSE mechanism responsible for the SPI Flash access
control.
%
In this example, the trusted software component is the \ac{smm} code.
%
The rest of the software stack, including the system software, is considered
untrusted.
%
The targeted security property is the integrity of the SPI Flash.
%
More precisely, only the \ac{smm} code should be capable of overwriting the
content of the SPI Flash, which contains the \ac{bios} code.
%
To enforce this security property, the HSE mechanism relies on the
\texttt{FNCTL} \thomasrk{Trouver le bon nom et mettre une ref.} register,
exposed by the Platform Controller Hub.
%
Once configured correctly, the SPI Flash is considered ``locked'', meaning it is
not possible even for the \ac{smm} code to issue a successful write access which
targets its content.
%
The SPI Flash can be unlocked, but when the system software tries, the PCH fires
a \ac{smi}.
%
As a consequence, the \ac{cpu} saves its current state, and starts executing the
\ac{smm} code.

What comes next depends on the \ac{smm} code, and how it is implemented.
%
It is executed in a situation where the SPI Flash is unlocked, so it can
perform, if it makes sense, the write access intended by the system software on
its behalf.
%
On typical workflow is for the system software to load the \ac{bios} update in
memory, and for the \ac{smm} code to verify whether this update is correctly
signed by the vendor.
%
In any case, it is the responsibility of the \ac{smm} code to lock again the SPI
Flash before it uses the \texttt{rsm} instruction to leave \ac{smm}.
%
Similarly to the \texttt{SMRAMC} register and the isolation it promises, the
\texttt{FNCTL} register has been defeated at least twice.

\paragraph{SENTER Sandman}
%
In 2015, Xeno Kovah \emph{et al.} have shown it was possible to leverage the
Intel TXT technology to circumvent the SPI Flash write
protection\,\cite{kovah2015senter}.
%
By default, a system software has to trust the \ac{bios}.
%
Nowadays, most \ac{bios} implementations are made of millions of lines of code,
which are provided by many different industrial partners of the vendor.
%
As a consequence, the attack surface is consequent.
%
Intel TXT is a recent feature of some x86 \ac{cpu}, whose aim is to reduce the
\ac{tcb} of a system software, by removing most of the \ac{bios} from it.
%
With Intel TXT, a hypervisor can start its execution in an isolated execution
environment.
%
From this perspective, it was coherent for TXT to mask incoming \ac{smi}, this
indeed reduce the size of the \ac{tcb}, by excluding the \ac{smm} code.
%
Unfortunately, in this case, it has the important consequence of leaving the SPI
Flash content unprotected.

\paragraph{Speed Racer}
%
There is at least another attack that defeated the \texttt{FNCTL} register
purpose.
%
In 2015, Corey Kallenberg \emph{et al.} have shown that the scenario detailed
previously, where unlocking the SPI Flash fires a \ac{smi} which forces the
\ac{cpu} to execute the \ac{smm} code, suffers from a race condition in presence
of a second \ac{cpu}\,\cite{kallenberg2015racecondition}.
%
When a \ac{smi} is fired, all the x86 \ac{cpu} of the platform will eventually
enter in \ac{smm}.
%
On the contrary, the SPI Flash is unlocked as soon as the \texttt{FNCTL}
register is modified.
%
To prevent this race condition, Intel has added a new feature to its PCH, and
exposed by the \texttt{FNCTL} register.
%
Once activated, this new feature ensures the SPI Flash stays locked as long as
one \ac{cpu} is not in \ac{smm}.

\section{Conclusion}
\label{sec:usecase:conclusion}

Due to the complexity of computing platform, in particular from a hardware point
of view, implementing a correct HSE mechanism is challenging.
%
We chose to focus on HSE mechanisms implemented by the firmware, because it has
been well studied and there are several illustrative example of architectural
attacks.
%
In particular, in this chapter, we explained how three of them work.
