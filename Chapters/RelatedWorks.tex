\chapter{Related Works}
\label{chapter:relatedwork}

Hardware-based Security Enforcement (HSE) mechanisms are fundamental to enforce
primordial security properties such as isolation between layers of abstraction.
%
Because of the complexity of modern computing platforms, HSE mechanism
implementations are subject to architectural attacks, where one attacker is able
to exploit the legitimate use of one hardware component in order to circumvent
the protection normally implemented by another.
%
The important impact of previously disclosed architectural attacks have
motivated our will to formally specify HSE mechanisms, with two objectives in
mind:
%
\begin{inparaenum}[(1)]
\item providing unambiguous, security-focused specification to firmware and
  system software developers, and
%
\item verifying these specifications actually provides the targeted security
  properties.
\end{inparaenum}
%
These objectives are in line with an ongoing effort to strengthen the lower
layers of abstraction.
%
In 2011, Nachiketh Potlapally\,\cite{potlapally2011hardwaresecurity}, who
was working at Intel at the time, lists the same challenges we have detailed in
Chapter\,\ref{chapter:usecase}, and suggests that formal methods for security
validation is one of the possible solutions to these challenges.
%
In 2016, Stephen Chong \emph{et al.} cite ``Hardware Architectures'' and
``Operating Systems'' as areas of interest regarding the use of formal methods
for security\,\cite{chong2016report}.

The main characteristic of HSE mechanisms is that they are the result of both
hardware and software components, in presence of a larger system with untrusted
actors.
%
However, hardware and software components are not of the same nature.
%
Hardware components are physical devices which accept inputs and computes
outputs.
%
Software components are piece of data scattered into memory spaces, whose
semantics are determined by the processor unit that executes them.
%
While both hardware and software components are been subject to formal
verification in the past, these verification works tend to rely on different
representations.
%
Florian Lugou \emph{et al.} explain this in depth while they introduce SMASHUP,
a toolchain for unified verification of Hardware-software
co-designs\,\cite{lugou2017smashup}.
%
It is the main reason why we focus on the specification level in the context of
this thesis.
%
Refine our potential conclusions up to a concrete implementation is necessary in
the long term.
%
Fortunately, it is also a very active fields, with impressive flagship projects
such as DeepSpec\,\cite{appel2017deepspec}.

The rest of this Chapter proceeds as follows.
%
\thomasrk[inline]{Todo again: annonce du plan}
%We first describe the research works whose purpose is to verify system software
%built upon HSE mechanisms (Section\,\ref{sec:relatedwork:software}).
%%
%Then, we focus on research work dedicated to verify that a given piece of
%hardware correctly enforces security properties
%(Section\,\ref{sec:relatedwork:hardware}).
%%
%These projects have in common to model one particular component, and to abstract
%away the rest of the system.
%%
%``Connecting'' these specifications and verification results remains
%challenging.
%%
%Therefore, we finally describe research works focused on modular verification of
%complex systems made of several inter-connected components
%(Section\,\ref{sec:relatedwork:modular}).

\section{Hoare Logic} % =======================================================

When it comes to formally specify a given system, and latter verify it, the most
common approach is to define system states, events, and a semantics of events as
state-transformers, defined in terms of pre and post conditions.
%
On the one hand, the pre condition determines whether a given event can occur
when the system is in a given state.
%
On the other hand, the post condition specifies the consequences of that event,
once occurred, on the system state.
%
This approach has been originally introduced by Robert W. Floyd and Tony Hoare
in the late 60s to reason rigorously about the correctness of computer programs,
is often referred to as the Floyd-Hoare Logic or the Hoare Logic.

%Hoare Logic can be implemented in many ways.
%%
%One possible representation is a \ac{lts}.
%%
%In order to illustrate how Hoare Logic can be used in order to specify one
%system, security properties and to verify the system enforce the targeted
%security properties, we will use it.
%%
%It is important to remember it is not the unique possible representation, nor
%the most popular.
%
%\begin{definition}[Labelled Transition System]
%  A \ac{lts} is a tuple $(\mathcal{H}, \mathcal{L}, (\rightarrow))$, where
%  $\mathcal{H}$ is the set of states the system can take, $\mathcal{L}$ is the
%  set of labelled transitions which can cause the system state to change, and
%  $(\rightarrow) \subseteq \mathcal{H} \times \mathcal{L} \times \mathcal{H}$ is
%  the set of state-transformations.
%\end{definition}
%
%\begin{notation}[State-Transformation]
%  Let $h \in \mathcal{H}$, $h' \in \mathcal{H}$ and $l \in \mathcal{L}$, we
%  write $h \in \xrightarrow{l} h'$ for $(h, l, h') \in (\rightarrow)$.
%\end{notation}
%
%It is possible to define $(\rightarrow)$ in terms of pre and postcondition.
%%
%In this context, a pre condition $P$ will be of the form
%$P \subseteq \mathcal{H} \times \mathcal{L}$, whereas a post condition $Q$ will
%be of the form $\mathcal{H} \times \mathcal{L} \times \mathcal{H}$.
%
%\begin{notation}[Predicate]
%  When we define a predicate $P$ over members of the set $\mathcal{A}$ as a
%  subset of $\mathcal{A}$, that is $P \subseteq \mathcal{A}$, we write $P(x)$
%  for $x \in P$.
%\end{notation}
%
%We define $(\rightarrow)$ as follows:
%\[ h \xrightarrow{l} h' \triangleq P(h, l) \wedge Q(h, l, h') \]
%%
%In order to define $P$ and $Q$, it is a common practice to rely on a proof tree
%notation.
%%
%Using this notation, we can easily define $(\rightarrow)$ in terms of pre and
%post condition, one label at a time.
%
%\begin{prooftree}
%  \AxiomC{$P(h, l)$} \AxiomC{$Q(h, l, h')$} \BinaryInfC{$h \xrightarrow{l} h'$}
%\end{prooftree}
%
%\begin{example}[Airlock-like Doors]
%  A airlock-like doors system is made of two doors and a intermediary
%  chamber. The user requests the opening of one door, enters inside the chamber,
%  waits for the first door to close, then requests the opening of the second
%  door.
%  %
%  We can formally specify a airlock-like doors system, as ones used by some
%  jewellery stores and banks, by defining a dedicated LTS.
%
%  Let $\mathcal{D} \triangleq \{\,\mathtt{open}, \mathtt{close}\,\}$ be the set
%  of states of one door, then we can define
%  $\mathcal{H} \triangleq \mathcal{D} \times \mathcal{D}$ the set of states of
%  the system.
%  %
%  We consider four events which imply a state-transformation: opening the first
%  door, closing the first door, opening the second door, closing the second
%  door.
%  %
%  Hence, we define
%  $\mathcal{L} \triangleq \{\,\mathtt{opening_1}, \mathtt{opening_2},
%  \mathtt{closing_1}, \mathtt{closing_2}\,\}$.
%
%  The set of state-transformations $(\rightarrow)$ specifies the functional
%  behaviour of the system.
%  %
%  We define it with in terms of pre and post condition.
%
%  \begin{minipage}[c]{0.5\linewidth}
%    \begin{prooftree}
%      \AxiomC{$d_1 = \mathtt{close} \wedge d_2 = \mathtt{close}$}
%      \AxiomC{$d_1' = \mathtt{open}$}
%      \BinaryInfC{$(d_1, d_2) \xrightarrow{\mathtt{opening}_1} (d_1', d_2)$}
%    \end{prooftree}
%
%    \begin{prooftree}
%      \AxiomC{$d_1 = \mathtt{close} \wedge d_2 = \mathtt{close}$}
%      \AxiomC{$d_2' = \mathtt{open}$}
%      \BinaryInfC{$(d_1, d_2) \xrightarrow{\mathtt{opening}_1} (d_1, d_2')$}
%    \end{prooftree}
%  \end{minipage}
%  \begin{minipage}[c]{0.5\linewidth}
%    \begin{prooftree}
%      \AxiomC{$d_1 = \mathtt{open}$} \AxiomC{$d_1' = \mathtt{close}$}
%      \BinaryInfC{$(d_1, d_2) \xrightarrow{\mathtt{closing}_1} (d_1', d_2)$}
%    \end{prooftree}
%
%    \begin{prooftree}
%      \AxiomC{$d_2 = \mathtt{open}$} \AxiomC{$d_2' = \mathtt{close}$}
%      \BinaryInfC{$(d_1, d_2) \xrightarrow{\mathtt{closing}_2} (d_1, d_2')$}
%    \end{prooftree}
%  \end{minipage}
%\end{example}

Hoare Logic is an effective formalism to reason about system's executions,
modelled as sequences of state-transformations.
%
These sequences, also called traces, can be formally specified as follows:
%
%\begin{definition}[Trace]
%  Let $h \rightarrow^{*} h'$ a trace which modelled a system's execution from an
%  initial state $h \in \mathcal{H}$ to $h' \in \mathcal{H}$.
%  %
%  This trace is either the result of
%  %
%  \begin{itemize}
%  \item[--] One state-transformation from $h$ to $h'$, induced by an labelled
%    transition $l$
%  %
%  \item[--] One trace from $h$ to $h''$, and an additional state-transformation
%    from $h$ to $h'$, induced by a labelled transition $l$
%  \end{itemize}
%
%  \begin{minipage}[c]{0.5\linewidth}
%    \begin{prooftree}
%      \AxiomC{$h \xrightarrow{l} h'$} \RightLabel{\texttt{1-step}}
%      \UnaryInfC{$h \rightarrow^{*} h'$}
%    \end{prooftree}
%  \end{minipage}
%  \begin{minipage}[c]{0.5\linewidth}
%    \begin{prooftree}
%      \AxiomC{$h \rightarrow^{*} h'$} \AxiomC{$h' \xrightarrow{l} h''$}
%      \RightLabel{\texttt{n-step}} \BinaryInfC{$h \rightarrow^{*} h''$}
%    \end{prooftree}
%  \end{minipage}
%\end{definition}
%
These traces can be used to defined various kind of properties of the studied
systems.
%
In the context of this thesis, we focus on security properties.
%
From this perspective, we can use Hoare Logic to model \emph{enforceable
  security properties}, as defined by Fred
B. Schneider\,\cite{schneider2000enforceable}.
%
Enforceable security properties are defined with predicates on sets of
executions, that is traces.
%
The most common scheme, to that regards, is to distinguish between secure state
and insecure state, secure transition and insecure transition, and to verify
that, for a given trace, the system never is an insecure state, and no insecure
transition ever occurres.

\begin{itemize}
\item[--] Mostly reasoning about trace
  properties\,\cite{schneider2000enforceable}: definition of safe states, safe
  transitions, safe traces and verification that pre/post condition imply safety
\item[--] Many tools are possible, from proof assistant to model checking, but
  the main concept remains unchanged (only the easiness to express/verify one
  property or another)
\item[--] XOM\,\cite{lie2003xom} and VirtCert are particularly good example of
  that
\item[--] Moat\,\cite{sinha2015moat} is interesting, because it uses a notion of
  policy (how to sign SGX enclave code)
\item[--] RockSalt\,\cite{morrisett2012rocksalt} does not work in a very
  different way, when it speaks about safe state, and sequences of instruction
\end{itemize}

\section{Modular Hoare Logic} % ===============================================

\begin{itemize}
\item[--] Abstract away routines with verified pre/post condition
\item[--] Construct more and more complex routines with this technic
\item[--] This is what Frama-C is doing
\item[--] But also projects like Pip (MMU)\,\cite{jomaa2016mmu}, or Ynot
\end{itemize}

\section{Interface Automata} % ================================================

\begin{itemize}
\item[--] In previous section, routine impact on state is ''more imporant'' than
  its result
\item[--] Same state, no matter how deep we go
\item[--] How to deal with ``outer'', distant environment?
\item[--] Coq.io makes hypothesis on outer environment result, but how to verify
  these hypothesis?
\item[--] Interface Automata provide an interesting formalism
\item[--] Alloy\,\cite{jackson2012alloy} is a very good example of what we want
  to achieve
\end{itemize}

%\section{Verified Software Component} % ========================================
%\label{sec:relatedwork:software}
%
%Verification of Systems Software is a longstanding, active research fields.
%%
%Even if our end goal is not to prove the correctness of one software component
%implementation, it is interesting to study how they represent the hardware
%architecture.
%%
%By formally specifying HSE mechanisms and verifying they correctly enforce a
%targeted security properties, our objective is to change the nature of proof of
%implementation correctness.
%%
%Rather than proving a given implementation enforce a security property, it
%should be shown that it complies to a verified HSE mechanism specification which
%targets this security property.
%
%\subsection{Verified Systems Software} % ---------------------------------------
%
%\begin{compactitem}
%\item[--] In this section, we list three different projects, which adopt three
%  different approach.
%\item[--] Our goal is not to be exhaustive, but rather to give insightful
%  examples.
%\end{compactitem}
%
%\paragraph{VirtCert}
%%
%\begin{compactitem}
%\item[--] Executable specification of a hardware-based hypervisor.
%%
%\item[--] Focus on x86 virtualisation technology features, with a simple memory
%  model.
%\item[--] Iterative works, focus on several security properties:
%  \begin{compactitem}
%  \item Isolation
%  \item Liveness properties
%  \item Constant time cryptography
%  \end{compactitem}
%\item[--] Note: Pip by another team of Inria is similar
%\end{compactitem}
%
%\paragraph{sel4}
%%
%\begin{compactitem}
%\item[--] ``First operating-system kernel with an end-to-end proof of
%  implementation correctness and security enforcement''
%\end{compactitem}
%
%\paragraph{CertiKOS}
%%
%\begin{compactitem}
%\item[--] Implemented in Coq the proof assistant
%\item[--] Target is CompCert AST for proof correspondance
%\item[--] Part of the DeepSpec project, whose purpose is to connect system of
%  proofs, from high level specifications to concrete implementations
%\item[--] Hardware model is relatively simple, but has been completed by XX in
%  order to take interrupt into account
%\end{compactitem}
%
%\subsection{Generic Software Specification Correctness}
%
%\paragraph{RockSalt}\,\cite{morrisett2012rocksalt}
%%
%\begin{compactitem}
%\item[--] Implementing SFI at a software level, that is verifying at load time
%  that a given arbitrary application is correctly sandboxed
%\item[--] Four step contribution
%  \begin{compactenum}
%  \item Modelling of the x86 ISA, model validation
%  \item Definition of software rules/guidelines
%  \item Proof that these rules enforces SFI
%  \item Extraction of the verified verifier
%  \end{compactenum}
%\end{compactitem}
%
%\paragraph{Moat}\,\cite{sinha2015moat}
%%
%\begin{compactitem}
%\item[--] The goal is to verify SGX1 specification, which partly includes
%  specifying software guidelines
%\item[--] Once again, the hardware model is pretty simple, but this can be
%  justified by the fact that the SGX trusted computing base is supposedly very
%  small (CPU only)
%\end{compactitem}
%
%\section{Hardware Component Verification} % ====================================
%\label{sec:relatedwork:hardware}
%
%\begin{compactitem}
%\item[--] In the previous section, the hardware model are often very simplified.
%\item[--] In the previous Chapter, we have explained in depth why such approach
%  is not enough.
%\item[--] These simplified hardware model are actually as many hypotheses to
%  latter verify.
%\item[--] To the best of our knowledge, there is no comprehensive formal
%  model/specification in terms of hardware components.
%\end{compactitem}
%
%\subsection{Formal Specification of CPU Architectures}
%
%\begin{compactitem}
%\item[--] The CPU is the main hardware component of a hardware architecture,
%  because it executes the main software stack
%\item[--] It should not be forgotten that it is not the only ``important'', or
%  ``privileged'' component.
%\end{compactitem}
%
%\paragraph{Intel}
%%
%\begin{compactitem}
%\item[--] Core Execution Cluster\,\cite{kaivola2009formalintel}
%\item[--] SGX\,\cite{leslie2015sgx}
%\item[--] The work seems unrelated, in terms of model, that is Intel is not
%  building a single, unified model for its architecture
%\end{compactitem}
%
%\paragraph{ARM}
%%
%\begin{compactitem}
%\item[--] Executable specification for ARM ISA
%\item[--] Several research projects for several versions of ARM
%  \begin{compactitem}
%  \item[--] v7\,\cite{fox2010armv7}
%  \item[--] v8\,\cite{reid2016armv8}
%  \end{compactitem}
%\end{compactitem}
%
%\paragraph{LEON3}
%%
%\begin{compactitem}
%\item[--] Formal Methods 2016
%\end{compactitem}
%
%\paragraph{XOM}
%%
%\begin{compactitem}
%\item[--] Security-focused architecture
%\item[--] Contrary to HSE mechanisms, the CPU alone implements a security policy
%\item[--] XOM\,\cite{lie2003xom}
%\item[--] Model checking, simplified ``rest of the system''
%\end{compactitem}
%
%\subsection{Verified Hardware Components}
%
%\begin{compactitem}
%\item[--] Cite Kami arguments here about use of formal methods in hardware
%  industry in general.
%\end{compactitem}
%
%\begin{compactitem}
%\item[--] Coquet\,\cite{braibant2011coquet}, is too much ``low-level''
%\item[--] Use Kami\,\cite{choi2017kami} as a transition for the next section
%\end{compactitem}
%
%\section{Formal Verification of Inter-connected Components} % ==================
%\label{sec:relatedwork:modular}
%
%\begin{compactitem}
%\item[--] Regarding the scale of our self-assigned task, modular verification is
%  a ``must-have'' (probably use the wording of the FreeSpec for introducing
%  here)
%\end{compactitem}
%
%\subsection{Interface Automata}
%
%\begin{compactitem}
%\item[--] Compared to regular automata, interface automata produce a result for
%  each (labeled) transition
%\item[--] The notion of contracts exist in this field
%\item[--] TODO: organize the papers
%\end{compactitem}
%
%\subsection{Program With Effects}
%
%\begin{compactitem}
%\item[--] This is reminiscent to the problematic language of large program with
%  effects
%\item[--] Alloy\,\cite{jackson2012alloy} is a very good example of what we want
%  to achieve
%\item[--] Frama-C and co. allows for modular reasoning, but there is still no
%  mature solution for reasoning for ``external effects'' (from the application
%  point of view), \emph{e.g.} system calls
%\item[--] Ynot suffers the same properties and limitation
%\item[--] Guillaume Claret allows for reasoning about program behaviour
%  according to certain hypothesis about the ``outer environment'', but not to
%  verify the latter
%\end{compactitem}
