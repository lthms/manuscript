%!TEX root = ../main.tex
\chapter{Intel x86 Architecture and BIOS Background}
\label{chapter:usecase}

\endquote{``\emph{You’re building your own maze, in a way, and you might just
    get lost in it.}''

  \hfill\footnotesize --- Marijn Haverbeke}

% PC: commentaire inutile: c'est un peu le but d'un labyrinthe, em même temps
% Thomas: pas faux !

\vspace{1cm}\noindent From a market share perspective, x86 \acp{cpu} are widely
used for laptops, desktops and servers.
%
Besides, Intel has introduced several \ac{hse} mechanisms over the past decades:
hardware-based virtualization (VT-x, VT-d)\,\cite[Volume 3, Chapter
23]{intel2014manual}, dynamic root of trust (TXT)\,\cite{intel2015txt}, or
applicative enclaves (SGX)\,\cite[Volume 3, Chapter
36]{intel2014manual}\cite{costan2016sgxexplained}.
%
Our motivation to formally specify and verify \ac{hse} mechanisms comes from
various compositional attacks targeting the x86 hardware
architecture\,\cite{duflot2009smram,wojtczuk2009smram,kallenberg2015racecondition,domas2015sinkhole,kovah2015senter}.
%
For these reasons, we have evaluated our approaches against the x86 hardware
architecture, with a focus on the \ac{hse} mechanism implemented by the BIOS at
runtime to stay isolated from the rest of the software stack.
%
Because the BIOS is the most privileged piece of software executed by the
hardware architecture, this \ac{hse} mechanism is of key importance.
%
Despite this fact, it has been the object of several compositional
attacks\,\cite{duflot2009smram,wojtczuk2009smram,domas2015sinkhole}, and
therefore, it illustrates perfectly our motivations.
%
However, it is important to emphasize that other mainstream architectures
(\emph{e.g.}  ARM) work on a similar basis and potentially suffer similar
issues, and our contributions are intended to be applicable to other hardware
architectures.
%

The rest of this Chapter proceeds as follows.
%
We describe how a typical x86 hardware architecture is organized, and the
consequences of this organization in terms of security
(Section~\ref{sec:usecase:architecture}).
%
We then focus on the key role played by the \ac{bios}, and its requirements in
term of security (Section~\ref{sec:usecase:firmware}).
%
Once we have established the role of the \ac{bios}, we detail the \ac{hse}
mechanisms it implements, and several compositional attacks which have defeated
these \ac{hse} mechanisms in the past (Section~\ref{sec:usecase:hse}).

\section{Introduction to x86 Architecture Security}
\label{sec:usecase:architecture}

Describing hardware architectures in depth is challenging, because they tend to
comprise an increasing number of interconnected components of various natures.
%
The x86 hardware architecture is a perfect illustration of this, and this \TODO{répétition de "this"} is
probably best illustrated by the scale of its documentation.
%
At the time of writing this thesis\,\footnote{Spring 2018.}, the \emph{Intel 64
  and IA-32 Architectures Software Developer’s Manual} is 4842 pages long.
%
A typical computing platform is made of dozens of hardware components, including
\emph{e.g.} hard drives, a keyboard, a trackpad, an audio controller, and a
graphic card.
%
Several come with their own documentation, often in the form of large datasheet.

\TODO{et? Quel est le lien avec la suite? Il manque ici une transition, annoncant notamment le plan de la section. D'ailleurs, il manque un fil conducteur à cette section.}

\subsection{Basics of x86 Architecture}

A simplified x86 hardware architecture is pictured in
Figure~\ref{fig:usecase:x86arch}. \TODO{Il faudrait préciser que cette figure correspond à une architecture x86 récente (je ne sais plus à partir de quelle nom de code, il faudrait retrouver). Il faudrait en profiter pour souligner que l'architecture x86 a évolué sensiblement depuis sa création et que même aujourd'hui, on peut trouver dans un parc existants des machines avec des architectures sensiblement différentes}
%
We now describe how the different hardware components are integrated together to
form a typical x86 computing platform, from the processor which executes
software components to various peripherals which allows the system to interact
with the rest of the world.

\begin{figure}
  \centering
  \begin{tikzpicture}
    \node [draw, inner sep=25pt] (MCH) {Processor};%

    \node [draw, inner sep=8pt, right=15pt of MCH, yshift=-20pt, text badly
    centered, text width=65pt] (DRAM) {DRAM Controller};%
    \node [draw, inner sep=8pt, right=15pt of MCH, yshift=20pt, text badly
    centered, text width=65pt] (Display) {Display Controller};%

    \draw (MCH.east) |- (Display.west);%
    \draw (MCH.east) |- (DRAM.west);%

    \node [draw, inner sep=8pt, left=15pt of MCH, text width=50pt, text badly
    centered] (PCIe) {PCI Express Controller};%

    \draw (PCIe) -- (MCH);%

    \node [draw, below=30pt of MCH, inner sep=40pt, text badly centered] (PCH)
    {PCH};%

    \draw (MCH) -- (PCH);%

    \node [draw, inner sep=5pt, below=10pt of PCH, text width=55pt,
    xshift=-55pt, text badly centered] (Flash) {Flash Memory};%
    \draw ([xshift=-10pt]PCH.south) |- (Flash.east);%

    \node [draw, inner sep=10pt, below=10pt of PCH, text width=25pt,
    xshift=55pt, text badly centered] (TPM) {TPM};%
    \draw ([xshift=10pt]PCH.south) |- (TPM.west);%

    \node [draw, inner sep=10pt, yshift=25pt, left=20pt of PCH, text width=65pt,
    text badly centered] (USB) {USB Controller};%

    \node [draw, inner sep=10pt, yshift=-25pt, left=20pt of PCH, text
    width=65pt, text badly centered] (PCI) {PCI Controller};%

    \draw (PCH.west) |- (USB.east);%
    \draw (PCH.west) |- (PCI.east);%

    \node [draw, inner sep=10pt, right=20pt of PCH, text badly centered, text
    width=50pt] (HD) {Hard Drive Controller};%

    \draw (PCH) -- (HD);%
  \end{tikzpicture}

  \caption{High-level view of the x86 hardware architecture}
  \label{fig:usecase:x86arch}
\end{figure}

\paragraph{Processor, Architecture and Microarchitecture.}
%
The main component of the architecture is the \emph{processor}.
%
It embeds several execution units called \emph{cores}.
%
They are responsible for executing sequences of assembly instructions which form
software component programs.
%
The concrete hardware implementation of the processor is often referred as the
Intel microarchitecture, in opposition to the Intel architecture which describes
the expected behavior and properties of a x86 system as seen by software
developers.
%
While Intel often modifies the microarchitecture, the architecture has remained
backward compatible for decades\,\cite{turley2014introx86}.
%
The microarchitecture implements many optimizations, such as
multithreading\,\cite{marr2002hypertheading}, instruction
pipelining\,\cite{fog2012microarchitecture}, out-of-order
execution\,\cite[Section 2]{fog2012microarchitecture} or predictive
branching\,\cite{milenkovic2002branchprediction}\cite[Section
3]{fog2012microarchitecture}.
%
% These optimizations should not violate properties of the architecture.
% %
% For instance, the predictive branching implemented by x86 \acp{cpu} increases
% performance, \emph{e.g.} inside a loop.
% %
% In presence of a conditional jump, a core will eagerly choose one branch
% ---based on the past execution--- before it has executed all the computations
% required to determine the correct execution path.
% %
% Most of the time, it chooses the correct branch.
% %
% In case of \emph{branch misprediction}, the erroneous computations performed
% by the core shall be canceled like if they have never happened.
% %
% \PC{quel est l'objectif de l'explication du \textit{branch misprediction} et
% l'exemple qui suivent ?  Cela me semble un peu hors contexte, on se demande
% pourquoi ce point est détaillé (et pas les autres)
%
% A supprimer ?}  We illustrate branch misprediction with the following program
% snippet, written with x86 assembly instructions (left) and its C equivalent
% (right)\,\footnote{Provided no optimization from the compiler nor the
% processor.}:
% %
% \begin{center}
%   \begin{minipage}[t]{0.35\linewidth}
%     \inputminted{asm}{Listings/predict.S}
%   \end{minipage}
%   \begin{minipage}[t]{0.35\linewidth}
%     \inputminted{c}{Listings/predict.c}
%   \end{minipage}
% \end{center}
% %
% During the first 10 steps of the loop, when the core executes the \texttt{jle}
% instruction (l. 5), it takes the same branch and jumps to the \texttt{loop}
% label.
% %
% At the end of the last loop step, the register \texttt{rax} contains the value
% \( 11 \).
% %
% According to the semantics of \texttt{jle}, the core should execute the
% \texttt{movq~\$0,~\%rax} (l.6) next.
% %
% From a microarchitectural point of view, the branch prediction technology can
% decide to optimize the execution of the program, by eagerly jumping to the
% \texttt{loop} label and continuing the execution of the program \emph{before}
% \texttt{\%rax} has been updated to \( 11 \).
%
% TODO: un meilleur snippet de code serait d’incrémenter ebx en plus de eax
%
% TODO : avant, limiter au temps d'accès cache. depuis le début de l'année 2018
% et meltdown/spectre, d'autres mécanismes ont pu être détournés de leur
% objectif de performance (branch prediction, tlb)

Intel microarchitecture blurs the frontier between hardware and software.
%
Indeed, an important part of the microarchitecture is not implemented as
hardware circuit, but rather under the form of \emph{microcode}
programs\,\cite[Section 2.14]{costan2016sgxexplained}.
%
That is, the processor is a programmable device, whose behavior ---including the
semantics of several x86 instructions it
implements\,\cite{johnson2015patentsgx}--- is partly determined by the microcode
it has loaded.
%
In practice, x86 \acp{cpu} only load microcode updates which have been signed by
Intel.
%
To the best of our knowledge, x86 microcode has never been successfully used as
an attack vector.

% GUILLAUME : Je dirais directement un CPU est aujourd'hui composé de plusieurs
% unités d'exécution indépendantes qu'on appelle des coeurs. Ces composants sont
% eux même constitués de différents blocs qui forme un pipeline d'exécution
% (fetch décode ALU, etc.) Ces coeurs peuvent être physiquement indépendants
% (i.e des unités qui possèdent leurs propres pipeline indépendant) ou bien
% virtuel. Dans ce cas (hyperthreading). Dans ce cas la micro-architecture
% partage les blocs d'un même coeur et offre l'illusion aux composants logiciels
% qu'ils peuvent s'exécuter sur différents coeurs indépendants. Chaque coeur
% virtuel possède un état qui lui est propre (compteur ordinal, etc.) mais
% partage les blocs d'exécution avec les autres coeurs virtuels d'un même coeur
% physique). Mettre quelques schéma pour illustrer ces concepts.
%
% A core basically repeats the following tasks:
%%
% \begin{enumerate}
% \item Read the content of its (internal) \emph{program counter} register, and
%   interpret it as the address of the next instruction.
%%
% \item Fetch the content of this address.
%%
% \item Decode the instruction, that is identified the desired operation to
%   perform
%%
% \item Act accordingly, by modifying its internal state, and interacting with
%   memories and features exposed by other hardware components
%%
% \item Update the content of its \emph{program counter} register according to
%   the semantics of the instruction it has executed. Most of the time, it
%   increases it to fetch the next instruction, but it can also set it to an
%   arbitrary value (\emph{e.g.} with jump instructions).
% \end{enumerate}

\paragraph{Memories and Cores \IOs.}
%
Besides cores, \emph{memories} are the most important components of a computing
platform.
%
Cores interact with these memories during so-called \IOs, for Input/Output: a
core receives data during an input and it sends data during an output.
%
The x86 architecture integrates several sources of memories, along with several
mechanisms cores can use to interact with these memories.

The main target of cores \IOs is the \ac{dram}.
%
\ac{dram} contains the instructions executed by the cores, \emph{and} the data
they manipulate.
%
A core decides the semantics of a given memory cell depending on the context,
and the same binary sequence can be first decoded as an instruction, then
interpreted as an operand of an arithmetical operation.
%
In addition, other hardware components also provide additional memory regions
cores can read from or write to.
%
Contrary to \ac{dram}, \IOs targeting these memories often carry a semantics
specific to each peripheral.
%
For instance, an x86 processor integrates a display controller which exposes a
frame buffer to the cores.
%
By writing to the frame buffer, a core changes the pictures displayed by the
computer screen.

In practice, the processor handles \IOs with high-speed hardware components
(\emph{e.g.} \ac{dram}, display controller, etc.).
%
In addition, it is connected to a companion chipset, called the
\ac{pch}\,\cite{turley2014introx86}, which handles slower hardware components
(\emph{e.g.}  hard drives, USB devices, PCI devices, etc.)\,\footnote{In
  previous iterations of the architecture, the processor was connected to a
  \emph{northbrige} (low-latency), which was itself connected to a
  \emph{southbridge} (slower \IOs).}.

\paragraph{Address Spaces.}
%
\acp{cpu} interact with memories \emph{via} two distinct memory address spaces,
characterized by a set of addresses and a set of instructions.
%
The most important address space is the \emph{system memory}, and most of the
x86 instructions (\emph{e.g.} \texttt{mov} variants, arithmetic operations such
as \texttt{sub} and \texttt{add}) are designed to manipulate it.
%
Addresses of the system memory are often refer to as physical addresses, and the
majority of the system memory is made of \ac{dram}.
%
Besides, cores use another address space characterized by two dedicated
instructions ---\texttt{in} and \texttt{out}--- to target the memories exposed
by other software components \TODO{software components? tu ne voulais pas dire plutôt hardware components?}.
%
\IOs issued by \texttt{in} and \texttt{out} instructions are referred to as
Port-Mapped \IOs (PMIO), and the addresses of this address space are called
\emph{ports}.

Although they are historically used to target different memory regions, nowadays
these two address spaces overlap, as peripheral memories and registers can be
exposed to the cores \emph{via} the system memory thanks to \emph{memory-mapped}
\IOs.
%
That is, \emph{it is possible to read from or write the same memory location
  using two different address spaces}.
%
% PC: “a memory mapping” plutôt ? La “memory map” c'est l'ensemble de tous les
% mappings.
%
% Thomas: justement, c’est bien dans ce sens que je l'utilise. J'ai mis les
% termes au pluriel pour que ce soit plus clair, c'est mieux ?
%
The mapping between addresses of the system memory and their concrete memory
locations within the hardware architecture is called the \emph{memory map}.
%
The memory map is configurable, that is it can be changed dynamically \emph{via}
configuration registers exposed by the processor and the \ac{pch}.
%
For instance, PCI  \TODO{c'est la première fois que tu utilises PCI. Tu dois rapidement expliquer cette acronyme} devices expose a so-called configuration space, which is a
dedicated memory region with a specific semantics summarized in
Figure~\ref{fig:usecase:pciconfig}.
%
Registers of the PCI configuration space, such as device and vendor IDs, can be
accessed \emph{via} PMIO.
%
Indeed, the \ac{pch} exposes two ``ports'' to that end.
%
First, software components modify the content of the
\texttt{PCI\_CONFIG\_ADDRESS} port, to tell the \ac{pch} which PCI configuration
register they want to interact with.
%
Then, they read from and write to the \texttt{PCI\_CONFIG\_DATA} port, and the
\ac{pch} dispatches these \IO to the targeted register.
%
The PCI specification states that the offset \texttt{0x10} of the PCI
configuration spaces is dedicated to so-called \texttt{BAR}s (Base Address
Registers).
%
The purposte of the \texttt{BAR}s is to configure a memory-mapped mechanism, so
that it becomes possible to interact with the PCI configuration space of a given
peripherals \emph{via} the system memory.
%
As a consequence, when a core reads from or write to the system memory in a
range specified by a BAR, the processor and the \ac{pch} \TODO{pourquoi "the processor and the PCH" et pas "the PCH" seulement?} dispatches its \IOs to
the PCI configuration space.

\begin{figure}
  \begin{center}
    \def\svgwidth{0.8\textwidth} \resizebox{0.6\textwidth}{!}{%
      \input{Figures/PCI-config-space.pdf_tex}}
  \end{center}
  \caption{Standard registers of PCI Type 0 (Non-Bridge) Configuration Space
    Header}
  \label{fig:usecase:pciconfig}
\end{figure}

Finally, software components often do not manipulate addresses of the system memory
directly.
%
Indeed, cores have their own address translation mechanisms, namely
segmentation\,\cite[Volume 3, Section 2.4]{intel2014manual} and
pagination\,\cite[Volume 3, Chapter 4]{intel2014manual} (potentially extended
with its virtualization technology\,\cite[Volume 3, Section
28.2]{intel2014manual},), which are configurable by the software components.

As such, determining which hardware component will handle a core \IO targeting a
given virtual address requires to have a complete knowledge of the x86 remapping
and virtual memory mechanisms and of their exact configurations at a given time.

\paragraph{Peripherals \IOs.}
%
Cores are not the only active hardware components present inside a typical x86
hardware architecture.
%
For instance, several hardware components can also read from or write to the
\ac{dram} using a technology called \ac{dma}.
%
Hardware components can also interact with the processor by sending hardware
interrupts of various natures.
%
When a user presses a key of its keyboard, the latter sends an interrupt
request.
%
Interrupt handlers, that is programs executed by the core when it receives
interrupts, are configurable \emph{via} a so-called \ac{idt}\,\cite[Volume 3,
Chapter 6]{intel2014manual}.
%
Each line of the \ac{idt} corresponds to a given interrupt whose semantics is
specified by Intel, as summarized in Table~\ref{tab:usecase:idt}.
%
When a core handles an interrupt, it saves its current context inside the
\ac{dram}, then starts executing the corresponding interrupt handler.
%
Not all x86 interrupts come from a hardware component.
%
Cores use several of them, for instance to recover from errors.
%
For example, if a core is not able to translate a virtual address into a proper
address, it raises a so-called Page Fault (denoted by \texttt{\#PF} \TODO{tu vas utiliser cette notation plus tard? si ce n'est pas le cas vire cette parenthèse}).

\begin{table}
  \centering
  \begin{tabular}{cl}
    {\scshape \#IRQ}
    & \multicolumn{1}{c}{\scshape Semantics} \\
    \hline
    \texttt{0x00}
    & Division by zero \\
    \texttt{0x01}
    & Single-step interrupt \\
    \texttt{0x02}
    & Non-Maskable Interrupt (NMI) \\
    \texttt{0x03}
    & Breaking point (used by debuggers) \\
    \texttt{0x04}
    & Stack overflow \\
    \texttt{0x05}
    & Bounds \\
    \texttt{0x06}
    & Invalid instruction opcode \\
    \texttt{0x07}
    & Coprocessor not available \\
    \texttt{0x08}
    & Double fault \\
    \texttt{0x09}
    & Coprocessor segment overrun \\
    \texttt{0x0A}
    & Invalid task state segment \\
    \texttt{0x0B}
    & Segment not present \\
    \texttt{0x0C}
    & Stack fault \\
    \texttt{0x0D}
    & General protection fault \\
    \texttt{0x0E}
    & Page fault \\
    \texttt{0x0F}
    & Reserved by Intel \\
    \texttt{0x10}
    & Math fault \\
    \texttt{0x11}
    & Alignment check \\
    \texttt{0x12}
    & Machine check \\
    \texttt{0x13}
    & SIMD floating-point exception \\
    \texttt{0x14}
    & Control protection exception \\
  \end{tabular}
  \caption{x86 Interrupt Descriptor Table semantics}
  \label{tab:usecase:idt}
\end{table}

\paragraph{Autonomous Subsystem.}
%
Intel has implemented several out-of-band management technologies for its
products.
%
They allow for administering a computer \emph{via} the network, without the need
for a physical access.
%
In practice, the software components responsible for implementing the
out-of-band management features are not executed by the main processor: the
network card was implementing \TODO{pourquoi "was implementing"? l'usage de ce temps est bizarre. en outre, cette techno n'est plus présente dans les cartes actuelles?} the ASF technology\,\cite{duflot2010network}, and
since 2008 x86 \acp{cpu} \TODO{Qu'est ce que veux dire précisemment CPU? Tu as défini avant plusieurs termes (processor, core, PCH) mais pas celui là. En outre tu indique que le ME est intégré au CPU. Je pense qu'il faut dire que le CPU est le packaging vendu par Intel, et qu'un client peut acheter séparemment, comprenant le processeur, le controleur mémoire (généralement un controleur video) et le PCH} embed a so-called Management
Engine\,\cite{ruan2014me,skochinsky2014intel}.
%
In 2018, the Management Engine is located inside the \ac{pch}.
%
ASF-capable network cards and the Management Engine require important
capabilities to implement their features.
%
For instance, the Management Engine can download from the Internet an executable
image, provoke the reboot of the computing platform and force the main \ac{cpu}
to execute the software components within the image it has
downloaded\,\cite{kumar2009active}.
%
It becomes harder and harder to completely disable the Management Engine on a
typical x86 computing platform \TODO{ref!}.
%
The Management Engine will notably provoke the reboot of the platform if it
cannot initialize correctly.

\subsection{HSE Mechanisms Targeted Security Policies}
\label{subsec:usecase:targetedsec}
\TODO{Le titre est difficile à comprendre. En outre, je ne vois pas bien où tu veux en venir avec cette sous-section. Quelle est son utilité? On ne sais pas si tu veux parler des politique ou des mécanismes permettant d'assurer ces politiques, c'est un peu mélangé. La thèse est essentiellement focalisée sur le BIOS. Or la plupart des exemples cités ici concernent plutot l'OS. Le lecteur est un peu perdu...}

As previously stated, x86 computing platforms are formed of concurrent,
interconnected components \TODO{que veut dire "concurrent components"? Interconnected, je vois. On parle de programme concurrents, mais pour des composants matériels, qui sont en outre interconnecté, je ne vois pas trop... }.
%
Such components share common resources, like the \ac{dram} which can be both modified by the
cores and \ac{dma}-capable hardware components.
%
This allows for cooperation, \emph{e.g.} when a network card receives a TCP
packet, it copies its content to a pre-defined address in \ac{dram} and then
notifies the operating system by sending an interrupt to the core.
%
This also raises a significant challenge from a security perspective.

\paragraph{Principle of Least Privilege.}
%
Hardware and software components come from various places and can be of various
qualities.
%
Once integrated together, an attacker can potentially leverage any of them to
threaten the security of the system.
%
In this context, the principle of least
privilege\,\cite{saltzer1975leastprivilege} applies: a given component should
only be able to leverage capabilities it needs to work according to its purpose,
where a ``capability'' refers to the right to perform a given \IO.
%
In practice, the implementation of this principle is challenging, for various
reasons.

Firstly, security checks can have an important impact over performance.
%
Partly for this reason, the hardware components have long been assumed
trustworthy.
%
A good demonstration of this fact is the Address Translation Services mechanism
introduced by the PCI standard, whose purpose is to allow PCI devices to bypass
security mechanisms designed to reduce their
privileges\,\cite{daubignard2017protip}.
%
Other examples showed blind trust in foreign hardware components
(\emph{e.g.} USB devices) is not without consequences from a security
perspective\,\cite{nohl2014badusb,hudson2015thunderstrike,chifflier2013uefi}.
%
Secondly, the ``least privilege'' may vary from one execution to another. \TODO{Cette dernière phrase n'est pas claire. Il faudrait préciser ton idée.}
%
To handle the numerous use cases of the x86 architecture, its default
configuration is very permissive, until software components such as the
\ac{bios} or an operating system modifies it to fit their needs, by
implementing \ac{hse} mechanisms.

% OLD VERSION: For instance, it has also been repeatedly shown that the various
% physical interface exposed by the computer (\emph{e.g.}
% USB\,\cite{nohl2014badusb}, Thunderbolt\,\cite{hudson2015thunderstrike},
% PCI\,\cite{chifflier2013uefi}) could be leveraged to take the control of a
% given computing platform, because peripherals connected \emph{via} these
% interfaces could perform \ac{dma}.

\paragraph{Access Control.}
%
The x86 hardware architecture provides many \ac{hse} mechanisms \TODO{Il faudrait mettre ici une liste importante d'exemples avec des ref} to determine
which \IO each component of the system can or cannot perform.
%
In other words, these \ac{hse} mechanisms enforce access control
policies\,\cite{sandhu1994access}.
%
Subjects of these policies include the software and hardware components of the
system.
%
Objects ultimately come down to the memory locations of various natures
scattered within the hardware architecture.
%
Actions comprise reading from and writing to a memory location. From a core
perspective, it is also common to distinguish between reading data and reading
instructions.

The \ac{mmu} is a good example of a hardware feature involved in a \ac{hse}
mechanism.
%
Thanks to the \ac{mmu}, an operating system can attribute ranges of \ac{dram} to
user applications it manages and isolates its code and data from these
applications.
%
The \ac{mmu} alone is not sufficient, because its scope does not cover its own
configuration.
%
That is, it is not possible to configure the \ac{mmu} in order to prevent a
software component to modify the \ac{mmu} configuration.
%
As a consequence, an additional hardware feature has to be used: the protection
rings\,\cite[Volume 3, Section 5.5]{intel2014manual}.
%
The x86 cores can operate in 4 different so-called rings, from 0 to 3, where
ring~0 is the most privileged and ring~3 the least.
%
Ring~3 imposes several restrictions on software components, including the
capability to modify the \texttt{CR3} register which identifies the base of the
page table hierarchy used byt the \ac{mmu}.
%
This is why ring~3 is commonly dedicated to the execution of applications.
%
Finally, the scope of the \ac{mmu} is limited to the software component executed
by a core at a given time.
%
To impose an access control policy to hardware components as well, an operating
system can use the so-called VT-d feature, which implements an \IO-\ac{mmu} for
x86 computing platform\,\cite{abramson2006vtd}.

%
% GUILLAUME: Ce qu'il faudrait dire, c'est que le CPU et la RAM sont des
% ressources partagées par les différents composants logiciels et matériels. Du
% coup, d'un point de vue de la sécurité, comme ces composants ne se font pas
% nécessairement confiance (parsqu'ils viennent de fournisseur différent,
% parqsu'il peuvent être malveillant ou vulnérables, etc.) il est nécessaire de
% les isoler les un les autres. La plupart des mécanismes de sécurité de la
% plateforme fournisse don c un mécanisme d'isolation}
%

The complexity of the x86 \IO resolution mechanism obliges to take into account
the numerous redirection features exposed by the architecture.
%
Memory locations can have an arbitrary number
of aliases, in several layered address spaces: the \ac{dram} controller assigns
an address to each memory cell the \ac{dram} contains; the processor maps
physical addresses to \ac{dram} addresses; the \ac{mmu} maps virtual addresses
to physical addresses.
%
As a consequence, modifying the content of a memory cell may not be the only way
at the disposal of attackers to defeat a given access control policy.
%
For instance, if the access control policy refers to virtual addresses \( v \),
modifying the \ac{mmu} configuration results in modifying the content associated
with \( v \).

\paragraph{Availability.}
%
Another class of security policies targeted by \ac{hse} mechanism is
availability security policies.
%
They focus on ensuring given software components are executed over time, without
the need for cooperation from mistrusted software components.
%
For instance, a user application which contains an infinite loop should not be
able to prevent the execution of the operating system, and by extension other
user applications.
%
To that end, the x86 hardware architecture relies on hardware interrupts and
exceptions.
%
Going back to the example of user applications, an operating system can leverage
one of the numerous hardware timers (\emph{e.g.} APIC timer\,\cite[Volume 3,
Subsection 10.5.4]{intel2014manual}) at its disposal to periodically preempt a
core, \emph{i.e.} implement preemptive multitasking.

% \TODO{Beaucoup de confusion dans ce paragraphe. 1) si tu parles de information
% flow et que tu dis que tu ne peux pas traiter la noninterference, tu vas te
% faire allumer... 2) la non-interference ne traite généralement pas des canaux
% auxilliaires mais seulement des flux directe et indirecte qui résulte d'une
% écriture explicite dans un conteneur d'informatin ou canal public et 3) je ne
% comprends pas ce que tu veux dire avec la citation du manuel Intel}:
%
%\begin{quote}
%  The Intel architecture aims to provide protection against software
%  side-channel attacks at the cache line granularity.
%
%  \hfill\small \emph{Intel Software Guard Extensions, Developer Guide}
%\end{quote}
%
%Because computer programs rarely fit inside a cache line, preventing
% side-channel attacks requires additional software-based security enforcement
% mechanisms.

% \subsection{Security Challenges and Attack Paths}
%
% \paragraph{Privilege Escalation.}
%%
%
% \paragraph{Malicious Hardware Components.}
%%
% Historically, peripherals have been part of the \ac{tcb} of every x86 \ac{hse}
% mechanisms, with important consequences on the computing platform security.
%%
% \TODO{Tu n'as pas défini avant la TCB, il me semble.}
%%
% For instance, it has also been repeatedly shown that the various physical
% interface exposed by the computer (\emph{e.g.} USB\,\cite{nohl2014badusb},
% Thunderbolt\,\cite{hudson2015thunderstrike}, PCI\,\cite{chifflier2013uefi})
% could be leveraged to take the control of a given computing platform, because
% peripherals connected \emph{via} these interfaces could perform \ac{dma}.
%%
% In 2010, Loic Duflot \emph{et al.} have shown it was possible to take control
% of certain network card.
%%
% They exploit some vulnerability in the network card firmware, which process
% network packets, to that end\,\cite{duflot2010network}.
%%
% This attack path did not require a physical access to the target.
%
% In that respect, the current situation of x86 systems has improved.
%%
% Modern \acp{cpu} provide a feature called \IO MMU\thomasrk{ref!}, which allows
% for configuring the memory ranges each peripheral can access to.
%%
% A well-configured \IO MMU drastically limits the impact of a rogue
% peripherals.
%%
% However, it is worth mentioning that, since 2008, Intel embeds the Management
% Engine, a processor \emph{inside} the \ac{pch}\thomasrk{ref}.
%%
% The Management Engine executes a complete software stack, and is capable of
% interacting with the \ac{dram} as well as other hardware components.
%%
% Intel leverages the Management Engine to provide out-of-band management
% solution, which means it can interact with the rest of the world without the
% cooperation of the main \ac{cpu}.
%%
% Although the Management Engine supposedly operates in a transparent manner
% from the \ac{cpu} perspective, we emphasize that a Management Engine
% vulnerability, a scenario which is not without precedent, potentially defeats
% any security measures implemented at the \ac{cpu} level.
%
% \paragraph{Microarchitecture}
%%
% Intel microarchitectural design is increasingly considered from a security
% perspective.
%%
% A deep knowledge of a core internals can be leveraged to perform side channel
% attacks\,\thomasrk{ref}.
%%
% For instance, time variations in memory accesses induced by the x86 cache have
% been leveraged to \emph{e.g.} retrieve secrets\thomasrk{ref} or defeat
% software components isolation\thomasrk{ref}.
%%
% Since the disclosure of Spectre\thomasrk{ref} and Meltdown in January
% 2018\thomasrk{ref}, many other microarchitectural features have been subverted
% in side-channels attacks\thomasrk{ref spectre variants}.

\section{BIOS Overview}
\label{sec:usecase:firmware}

The \ac{bios} plays a significant role in Intel x86 computing platform.
%
It is the first piece of software executed by the \ac{cpu}, which initializes
the hardware components and initiates the execution of the software stack during
the boot sequence (\ref{subsec:usecase:firm:boot}).
%
At runtime, it remains active to perform various tasks, including and not
limited to platform-specific events, device emulation, or \ac{bios} updates
management (\ref{subsec:usecase:firm:runtime}).
%
As such, it can only operate properly if certain security requirements are met
(\ref{subsec:usecase:firm:sec}), and implements several \ac{hse} mechanisms to
that end (\ref{subsec:usecase:hse:smm}).

\subsection{During the boot sequence}
\label{subsec:usecase:firm:boot}

The \ac{bios} program is stored inside a small flash memory connected
to the \ac{pch} through the Serial Peripheral Interface (SPI) bus on modern x86
computing platform.
%
When the \ac{cpu} is powered up, it is programmed  \TODO{Comment? Par qui? un code en mémoire morte? Programmed laisse à penser que c'est du soft qui est exécuté} to fetch the code stored at a
hard-coded address within the flash memory.
%
The first task of the \ac{bios} is to initialize the hardware
architecture\,\cite{salihun2006bios}.
%
Then, the \ac{bios} searches for a system software component to load into
memory.
%
Historically, ``legacy'' \acp{bios} were looking for a Master Boot Record (MBR)
at the beginning of mass storage devices (\emph{e.g.} hard drive, USB stick).
%
The MBR, whose size is limited to 512 bytes, contains a small program to
initiate a loader for a system software component.
%
Modern \acp{bios} implement the \ac{uefi}\,\cite{zimmer2007uefi,uefi2017specs}
standard, whose purpose is to standardize the boot sequence process in order to
favor interoperability of \ac{bios} implementations.
%
The boot sequence is divided into several phases, and the \ac{bios} is packaged
into several software components accordingly.
%
In particular, \ac{uefi}-compliant \ac{bios} can load so-called \ac{uefi}
applications of arbitrary size, leading modern hypervisors and operating systems
to be packaged as \ac{uefi} applications\,\cite{2011efistub}.

Because the \ac{bios} is the first software component executed by the hardware
architecture, and is responsible for initiating the execution of following
software components (\emph{e.g.} an operating system), it is commonly designated
as the root of trust\,\cite{rutkowska2015intel} for the software stack.
%
As such, the integrity of the \ac{bios} code is primordial, and several
strategies have been proposed to detect \ac{bios} code corruption during the
boot sequence, with the two most predominant being Secure Boot \TODO{ref} and Trusted Boot\TODO{ref}.

\TODO{En quoi Secure Boot et Trusted Boot permettent de détecter des corruptions du BIOS?}
\TODO{Cette sous-section n'est pas censé parler de sécurité (si j'ai bien compris le plan çà vient en 2.2.3) mais finalement tu t'attardes beaucoup à décrire des méanismes de sécurité. Ce n'est peut-être pas le bon endroit }
%
The \ac{uefi} standard defines a security mechanism called Secure
Boot\,\cite{rosenbaum2012secboot}.
%
When Secure Boot is enabled, \ac{uefi}-compliant \acp{bios} should only execute
applications which provide valid cryptographic signature, with respect
to a key hierarchy. \TODO{Il faudrait développer un peu en expliquant que le BIOS contient les clés publiques des fournisseurs de code supposé de confiance. D'ailleurs, peut-on ajouter des clés? Cela permet de s'assurer que seules des applications UEFI provenant de ces fournisseurs seront chargé puis exécuté par le BIOS. Si je ne me trompe pas, la verification à lieu lors du chargement (donc c'est le binaire qui est vérifié). }
%
The \ac{tcg} has standardized a hardware component called the \ac{tpm}, which is
the foundation of the Trusted Boot. \TODO{Il faudrait mieux marquer la séparation avec le Secure Boot. On a l'impression que tu continues d'expliquer le Secure Boot.}
%
Each component of the boot sequence should measure any software component it
initiates prior to starting its execution, and to entrust these measurements to
the \ac{tpm}.
%
If one of the software components executed during the boot sequence has been
corrupted, the difference is captured by the \ac{tpm}, because its measurements
are different than expected. \TODO{Ca veut donc dire qu'il existe une référence. Comment cette référence est-elle injectée dans le TPM? Qui peut le faire? Il faudrait commencer par expliquer çà.}
%
The measurements entrusted to the \ac{tpm} can be leveraged at the end of the
boot sequence in at least two ways.
%
The \ac{tpm} can cryptographically sign the measurements during a protocol
called remote attestation\,\cite{coker2011remoteattestation} which allows a
third party to verify that a given computing platform executes the code it is
supposed to.
%
Another popular approach is to entrust to the \ac{tpm} the encryption key which
protects sensitive information that a corrupted \ac{bios} should not be allowed
to access.
%
In this scenario, the access to the encryption key is correlated to the
measurements received by the \ac{tpm}.

Secure Boot and Trusted Boot can uncover \ac{bios} corruptions prior to the
execution of the illegitimate code.
%
However, they both rely on a root of trust which is neither measured nor
verified against a cryptographic signature. \TODO{Il faut expliquer que cette root of trust c'est le code initial du BIOS}
%
Recent efforts have been expended to overcome this limitation.
%
For instance, in 2013 HP has introduced a security mechanism called
SureStart\,\cite{hp2016surestart} whose purpose is to move the root of trust
within another hardware component. \TODO{Difficile de comprendre pourquoi çà résoud le problème. Ce qu'il faut expliquer, c'est que la root of trust initial (le code du BIOS) est malheureusement (du point de vue de la sécurité) modifiable. Cela permet de mettre à jour le BIOS. Il est en effet stocké en mémorie flash, donc modifiable. La principale mesure pour garantir l'intégrité du code du BIOS consiste à vérifier l'intégrité du code lors de mise à jours. Comme le BIOS est le composant le plus privilégié, seul le BIOS peut effectuer la mise à jour à proprement parler. HP rajoute un  niveau de confiance supplémentaire en s'appuyant sur une version non modifiable du BIOS, stockée en ROM, qui peut-être restaurée par un composant hardardware isolé s'il détecte que le BIOS actuellement stocké en flash n'est pas intègre.}
%
More recently, the NIST has published the Special Communication 800-193
---\emph{Platform Firmware Resiliency
  Guidelines}\,\cite{regenscheid2018nist800193}--- on this subject. \TODO{Sur quel sujet précisemment?}

\subsection{At runtime}
\label{subsec:usecase:firm:runtime}

The boot sequence ends once a system software component has been selected and
loaded into memory by the \ac{bios}.

\paragraph{Software Interfaces.}
At runtime, the \ac{bios} provides various software interfaces to the system
software component.
%
For instance, the \ac{acpi} tables\,\cite{uefi2017acpi,duflot2010acpi} is a
standardized interface to configure various vendor-specific aspects of the
hardware platform, such as power management or thermal management.
%
Similarly, legacy \acp{bios} expose facilities to system software components, in
the form of so-called \ac{bios} Interrupt.
%
For instance, the interrupt \texttt{0x10} is dedicated to video services
(\emph{e.g.} setting the video mode, setting the cursor shape and position,
etc.).
%
Nowadays, \ac{uefi}-capable \acp{bios} expose so-called \emph{Runtime Services}
to system software component\,\cite[Chapter 5]{zimmer2017uefi} under the form of
a function pointers table.

In either case, these interfaces act as an intermediary layer between a system
software component and the hardware architecture.
%
In doing so, they reduce the coupling between the software and hardware
components.
%
Sometimes, their use is optional, and \acp{bios} only provide them as a
facility.
%
Other are mandatory gates towards certain computing platform features, because
they are related to critical features of the platform and the hardware vendors
do not want to rely on a (potentially vulnerable or malicious) system software
component.
%
For instance, the \ac{bios} takes care of its own software updates, in order to
verify submitted versions prior to applying them, \emph{e.g.} by verifying
cryptographic signature or preventing the installation of older, out-dated
versions.

\paragraph{Proactive Features.}
%
In addition to supporting the execution of the rest of the software stack
through its interfaces, the \ac{bios} carries out several hardware-specific
tasks which are not publicly documented.
%
This includes and is not limited to handling hardware errors, checking thermal
zones, adjusting \acp{cpu} speed, and configuring hardware workarounds.
%
Some \acp{bios} also emulate complete hardware devices to the system software
component.

The execution of the \ac{bios} in this context should be transparent to the rest
of the software stack.
%
As such, the \ac{bios} remains the most privilege software component of the
software stack, even after the end of the boot sequence.

\subsection{Security Model}
\label{subsec:usecase:firm:sec}

The \ac{bios} is provided by the manufacturer of the hardware architecture.
%
In most cases, it is a proprietary software, and the computer owner has little
control over it.
%
The rest of the software stack is considered mistrusted, and one goal of the
\ac{bios} is to keep the computer in a working state, even in presence of an
erroneous or malicious software stack.
%
To that end, the \ac{bios} relies on several \ac{hse} mechanisms to enforce its
isolation from the rest of the software stack.

% To the best of our knowledge, the security policy targeted by the \ac{bios} as
% runtime is always discussed through the prism of the \ac{hse} mechanism used
% to enforced this policy.
%%
% \PC{la phrase précédente est un peu bizarre: la politique de sécurité est
% discutée (?!) à travers le prisme \ldots}
%%
% That is, documentation such as the Intel manual, the processor datasheet or
% the \ac{pch} datasheet ---in practice involved
%%
% \PC{pas clair: c'est la documentation qui est impliquée dans le hse ?!}
%%
% in the \ac{hse} mechanisms implemented by the \ac{bios}--- focus on \emph{how}
% implementing the security policy rather than specifying \emph{what} this
% policy is\thomasrk{Is it really true?}.
%%
% \PC{le paragraphe précédent/en cours me semble à retravailler, je ne le trouve
% pas clair}
%%
% \PC{La phrase qui suit fait un peu ``citation en vrac''}
%%
% Another useful source of information on this matter is the various research
% projects which discuss these mechanisms, for instance to demonstrate a
% security
% vulnerability\,\cite{duflot2009smram,wojtczuk2009smram,bulygin2014summary}.
%
From the information we gathered in the Intel manuals\TODO{ref} and in the academic literature \TODO{ref}, 
the isolation required by the \ac{bios} can be divided into three complementary security policies.

\begin{description}
\item [Volatile Memory Access Control]
  %
  The \ac{bios} is assigned a region of the volatile memory  to support its execution at
  runtime. This region is protected against \IOs issued by the rest of the software
  stack.
  %
  Besides, the \ac{bios} can rely on a \emph{secure channel} \thomasrk{ref?} \TODO{oui, ref!} to
  manipulate this volatile memory, \emph{e.g.} an adversary cannot modify the
  memory map in order to intercept \IOs issued by the \ac{bios} and targeting
  this volatile memory.
  %
  \PC{Cette notion de \textit{secure channel} est-elle importante~?  Si oui,
    ajoute un emph et sors-là de ce paragraphe, IMHO}
  %
\item [Availability]
  %
  The rest of the software stack is not authorized to prevent the execution of
  the \ac{bios} at runtime, \emph{i.e.} the \ac{bios} can preempt the execution
  of the rest of the software stack.
  %
\item [Non-volatile Memory Access Control]
  %
  The \ac{bios} is assigned a non-volatile memory region (in practice, a portion
  of the flash memory) to store its code and data.
  %
  The rest of the software stack is not authorized to modify the content of this
  memory, in order to avoid a scenario where attackers modify the \ac{bios} code
  according to their needs and provoke a reboot of the platform.
\end{description}

\subsection{HSE Mechanisms Implemented by the BIOS}
\label{subsec:usecase:hse:smm}

The isolation of the \ac{bios} at runtime, as detailed in the previous
subsection, directly involves three different hardware components: the
processor, the \ac{dram} and the \ac{pch}. \TODO{la flash aussi (au même titre que la DRAM. On pourrait aussi parler du memory controleur}
\TODO{il manque ici une phrase de transition avec la suite /annonce de plan}

\paragraph{System Management Mode.}
%
To handle several software components with different levels of privilege, Intel
\acp{cpu} provide several execution modes, which can be assimilated to sets of
hardware capabilities.
%
For instance, in a given execution mode, a \ac{cpu} may refuse to execute
certain assembly instructions.
%
Contrary to common belief, x86 execution modes are not organized in a linear
hierarchy, but are rather a matrix of complementary hardware features:
protection rings, paging configuration, virtualization technologies, etc.
%
As for the \ac{bios}, Intel provides the so-called \ac{smm}\,\cite[Volume 3,
Chapter 34]{intel2014manual}, introduced in the Intel manual as follows:

% GUILLAUME: \TODO{ ref, ref and ref...}  NOTE: On a déjà évoqué plusieurs fois
% /avant/ ces technos, donc si ref il doit y avoir (et je crois qu'elles y
% sont), alors elles sont déjà présentes avant.

\begin{quote}
  \ac{smm} is a special purpose operating mode provided for handling systemwide
  functions like power management, system hardware control, or proprietary
  OEM-designed code.
  %
  It is intended for use only by system firmware, not by application software or
  general-purpose system software.
  %
  The main benefit of \ac{smm} is that it offers a distinct and easily isolated
  processor environment that operates transparently to the operating system or
  executive and software applications.

  \hfill \small \emph{Intel 64 and IA-32 Architectures Software Developer’s
    Manual}
\end{quote}

The \ac{smm} is the foundation of the \ac{bios} execution at runtime, but it is
not sufficient. \TODO{Sauf erreur de ma part, tout le code du BIOS exécuté à runtime ne s'exécute par en SMM. Je pense que les routines ACPI par exemple s'exécutent dans le contexte du code appelant. En revanche, SMM est le moyen matériel utilisé par le BIOS pour s'isoler à runtime. Le code critique du BIOS est exécuté à runtime en SMM} 

\paragraph{System Management RAM.}
%
The SMRAM is the name given by Intel to a memory region located inside the
\ac{dram}, and dedicated to the \ac{smm}.
%
The exact location and size of the SMRAM are architecture dependent.
%
To locate it, the \ac{cpu} uses a dedicated register named \texttt{SMBASE}.
%
The \ac{bios} should configure it during the boot sequence.
%
As its name suggests, the \texttt{SMBASE} value should point to the base of the
SMRAM.
%
As for the end of the SMRAM, the hardware architecture does not expose it
explicitly, and the \ac{bios} developers need to refer to the processor
datasheet in order to find it.

At the beginning of the boot sequence, the SMRAM is left unprotected, meaning
arbitrary memory accesses targeting the SMRAM are authorized.
%
This design allows the \ac{bios} to initialize the SMRAM content.
%
Once the \ac{smm} code ---the \ac{bios} code intended to be executed at runtime
in \ac{smm}--- has been correctly loaded into the SMRAM, and prior to starting
the execution of a system software component, the \ac{bios} has to lock the
SMRAM.
%
% \TODO{expliquer ce que veut dire invisible -> la mémoire n'est plus mappé dans
% la plage d'adresse et soit le processeur accède à une autre mémoire soit il y
% a une exception (je suppose)}
A locked SMRAM can only be accessed by a \ac{cpu} in \ac{smm}.
%
More precisely, the physical addresses dedicated to the SMRAM from the \ac{bios}
perspective are used by the rest of the software stack to access the VGA
controller memory. \TODO{en fait, c'est le mapping de la mémoire qui est différent. Il faudrait l'expliquer comme çà, c'est un peu implicite dans ton explication et j'ai peur que le lecteur non averti ne comprenne pas.}
%
The \texttt{SMRAMC} register exposed by the processor controls this access
control mechanism, \emph{via} its \texttt{D\_LCK} bit.
%
The \ac{bios} locks the SMRAM by setting the \texttt{D\_LCK} bit.
%
A processor with the \texttt{D\_LCK} bit set will prevent a \ac{cpu} \TODO{"core" plutôt que CPU, non? "A processor .. prevent a CPU" est étrange.} not in
\ac{smm} to access the SMRAM content.
%
In addition, the only way to clear the \texttt{D\_LCK} bit is by performing a
complete reboot of the platform.
%
This leaves no opportunity for the system software to tamper with the SMRAM
content, because the \ac{bios} will lock it again prior to executing another
software component.

\paragraph{System Management Interrupt.}

The \ac{smi} is a hardware interrupt which makes the \ac{cpu} \TODO{tu utilises souvent CPU mais on ne sais pas vraiement si c'est un synonyme de "processor". En outre, tu l'utilise parfois pour désigner un coeur. Il faudrait être précis et notamment bien distinguer ce qui relève de l'ensemble (le processeur) de ce qui est réalisé sur chaque unité d'exécution (les coeurs). En l'occurence, pour une SMI, est-ce seulement un coeurs ou l'ensemble des coeurs qui passent en SMM? } ``enters''
\ac{smm}.
%
More precisely, when a \ac{cpu} receives a \ac{smi}, it saves its current state
(\emph{e.g.} its registers, current execution mode, etc.) in the SMRAM.
%
Then, the \ac{cpu} reconfigures itself;
%
in particular, it sets its program counter register to the value
$\mathtt{SMBASE} + \mathrm{0x8000}$.
%
From this point, the \ac{cpu} is in \ac{smm} and starts to execute what should
be the \ac{smm} code.
%
Once the \ac{smm} code has performed the task it has been requested for, the
\texttt{rsm} instruction can be used.
%
This instruction, specific to the \ac{smm}, tells the \ac{cpu} to exit \ac{smm}
and to restore its previous state.
%
This way, the execution of the software component previously halted by the
\ac{smi} can resume.
%
From the system point of view, it is almost like if nothing has happened.

It is possible to detect \ac{smm} context switches, the most straightforward way
being to rely on the Model-Specific Register \texttt{0x34}
(\texttt{MSR\_SMI\_COUNT}).
%
Indeed, the \ac{cpu} increments it every time it handles a
\ac{smi}\,\cite[Volume 4, Chapter 2]{intel2014manual}.
%
An operating system can also spin in a loop to take regular timestamps.
%
Variations in the timestamps interval are likely to be explained by a \ac{smm}
context switch. \TODO{Utilité de ce paragraphe? C'est un peu une digression, qui, je suppose, viennent nuancer la dernière phrase du paragrpahe précédent. Mais a-t-on besoin de rentrer dans ce niveau de détail pour ton sujet...?}

Finally, the \ac{pch} exposes a register called \texttt{APM\_CNT} that a system
software component can write to in order to make the \ac{pch} triggers a
\ac{smi}\,\cite{intel2012pch}. \TODO{Il faudrait indiquer que c'est donc un moyen pour l'OS de faire appel à du code du BIOS isolé à runtime. Par exemple pour xxxx}

\paragraph{Flash Memory Lockdown.}
%
The content of the flash memory has to be protected from arbitrary tampering \TODO{tu aimes bien "tampering" mais tu l'utilises beaucoup et un peu à toutes les sauces. ici "write access" ne serait-il pas plus approprié?},
similarly to the SMRAM protection.
%
That is, only the \ac{smm} code should be able to overwrite the content of the
flash memory.
%
This access control mechanism is implemented by the \ac{pch}, and is
configurable \emph{via} the \texttt{BIOS\_CNTL} control register.
%
Two bits of this register are of interest: the \texttt{BIOSWE} (\ac{bios} Write
Enable) bit, and the \texttt{BLE} (\ac{bios} Lock Enable) bit.

The semantics of the \texttt{BIOSWE} and \texttt{BLE} bits is as follows.
%
When the \texttt{BIOSWE} bit is clear, the \ac{pch} only authorizes read
accesses to the flash memory.
%
If a core sets the \texttt{BIOSWE} bit, the behavior of the \ac{pch} depends on
the value of the \texttt{BLE} bit.
%
If the \texttt{BLE} bit has been set by the \ac{bios} during the boot sequence,
then the \ac{pch} triggers a \ac{smi}.
%
As a consequence, the \ac{cpu} \TODO{CPU? core? processor?} stops its current execution and enters in
\ac{smm}.
%
This prevents the system software from tampering \TODO{modifying plutôt que tampering? } with the content of the Flash Memory, even if the \ac{pch} now authorizes write accesses.
%
It is the \ac{smm} code responsibility to clear the \texttt{BIOSWE} bit before
using the \texttt{rsm} instruction.
%
On the contrary, if the \texttt{BLE} bit is not set, setting the \texttt{BIOSWE}
bit will not cause a \ac{smi}. \TODO{et donc? Il faudrait expliquer que le code exécuté (l'OS par exemple) peut alors librement modifier le contenu de la flash}
%
Similarly to the \texttt{D\_LCK} bit of the \texttt{SMRAMC} register, the
\texttt{BLE} bit cannot be cleared without a reboot.

% GUILLAUME: Parfois tu mets Flash Memory en majuscul, parfois non. Je pense
% qu'il ne faut pas de majuscule, harmonise à tout le document.

The system software component and the \ac{bios} often use the flash memory
lockdown mechanism as a communication channel.
%
The system software sets the \texttt{BIOSWE} bit in order to notify the \ac{smm}
code that a \ac{bios} update is available.

\paragraph{}
%
The combination of the SMRAM, the \ac{smi} and the Flash Memory Lockdown
explains why the \ac{smm} is often referred to as the x86 ``most privileged
execution mode.''
%
In a nutshell, the \ac{smm} code can leverage the same hardware capabilities
than the system software, including manipulating memories used by the
system software.
%
On the contrary, the system software cannot modify either the SMRAM content or
the \ac{smm} code stored in the flash memory, and cannot prevent the \ac{smm}
code execution, \emph{i.e} intercept or mask \acp{smi}.



\section{BIOS HSE Mechanism and Compositional Attacks}
\label{sec:usecase:hse}

To stay isolated from the rest of the software stack at runtime, the \ac{bios}
implements a \ac{hse} mechanism whose key hardware feature is the \ac{smm}, a
dedicated execution mode of x86 \acp{cpu} (\ref{subsec:usecase:hse:smm}).
%
The \ac{smm} provides the necessary features to enforce its isolation from the
rest of the software stack.
%
Despite the key importance of \ac{smm}, several compositional attacks have been
disclosed over the past decade.
%
In this section, we detail three attacks which have defeated the three security
policies targeted by the \ac{bios}.
%
The SMRAM Cache Poisoning Attack allowed for circumventing the SMRAM access
control mechanism (\ref{subsec:usecase:hse:smram}).
%
The so-called SENTER Sandman attack prevented the execution of the \ac{bios} and
led to modifying the content of the flash memory
(\ref{subsec:usecase:hse:sandman}).
%
The Speed Racer attack resulted into an authorized modification of the flash
memory as well (\ref{subsec:usecase:hse:speed}).

\subsection{SMRAM Cache Poisoning Attack} % -------------------------------
\label{subsec:usecase:hse:smram}

Between 1986, when the \ac{smm} has first been introduced, and 2009, it was
believed that the \texttt{SMRAMC} register alone was sufficient to enforce SMRAM
access control.
%
Loic Duflot \emph{et al.}\,\cite{duflot2009smram} and Rafal Wojtczuk \emph{et
  al.}\,\cite{wojtczuk2009smram} independently showed that this belief was
misplaced when they disclosed the SMRAM Cache Poisoning Attack.

\paragraph{Cache Memory.}
\TODO{Contrairement à Intel TXT, les caches sont une techno hyper courantes, non spécifiques à Intel et que tout le monde connait. Ce long paragraph de description des caches devrait donc plutôt être placé en section 2.1.1. Ici, tu te contenterais de manière très succinte de rappeler les concepts nécessaire pour comprendre l'attaque en faisant référence à la section décrivant les caches. Cela éviterait cette longue digression qui nous éloigne de la description de l'attaque. Le contenu est intéressant mais doit être mieux placé.}
%
Interacting with the \ac{dram} remains slow, in regard to the speed of a
\ac{cpu}.
%
To improve performance, Intel \acp{cpu} come with several levels of caches, from
the smaller and quicker, to the bigger and slower.
%
For instance, Intel Core i7, i5 and i3 processors have three levels of caches.
%
More precisely, each core is assigned two levels of cache called L1 and L2,
while they all share a so-called L3 cache, as pictured in
Figure~\ref{fig:usecase:l1-l3caches}. \TODO{La figure fait apparaître des L3 slice. Il faudrait expliquer à quoi cela correspondre ou simplifier la figure}
%
The L1 cache has the particularity of being divided into a cache of instructions
(used when the core read from memory instructions to execute) and a cache of
data.

Caches are mostly transparent to the software components.
%
For instance, the processor alone enforces the cache coherence, with the notable
exception of multiprocessor (not multicore) systems, for which ``maintenance of
cache consistency may, in rare circumstances, require intervention by system
software.''
%
Intel has developed a dedicated protocol called MESIF to that
end\,\cite{thomadakis2011nehalem}.

\begin{figure}
  \begin{center}
    \begin{tikzpicture}
      \node [draw, inner sep=10pt, rectangle, text width=100pt, text badly
      centered] (l3-1) {L3 slice};%
      \node [draw, inner sep=10pt, rectangle, text width=100pt, text badly
      centered, right=25pt of l3-1] (l3-2) {L3 slice};%
      \node [draw, inner sep=10pt, rectangle, text width=100pt, text badly
      centered, below=10pt of l3-2] (l3-3) {L3 slice};%
      \node [draw, inner sep=10pt, rectangle, text width=100pt, text badly
      centered, left=25pt of l3-3] (l3-4) {L3 slice};%
      \node [draw, dashed, inner sep=10pt, fit=(l3-1) (l3-2) (l3-3) (l3-4)] (l3)
      {};%

      \draw (l3-1) -- (l3-2);%
      \draw (l3-2) -- (l3-3);%
      \draw (l3-3) -- (l3-4);%
      \draw (l3-4) -- (l3-1);%

      % core 1
      \node [draw, text width=100pt, inner sep=10pt, text badly centered,
      above=of l3-1] (l2-1) {Cache L2};%
      \draw (l3-1) -- (l2-1);%

      \node [above=20pt of l2-1] (l1-1) {};%
      \node [draw, right=0pt of l1-1.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-1-i) {Cache L1 {\small (Instruction)}};%
      \node [draw, left=0pt of l1-1.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-1-d) {Cache L1 {\small (Data)}};%
      \node [draw, text width=100pt, text badly centered, inner sep=10pt,
      minimum height=40pt, above=20pt of l1-1] (unit-1) {Execution Unit};%

      \draw (unit-1.south) -| (l1-1-d.north);%
      \draw (unit-1.south) -| (l1-1-i.north);%
      \draw (l1-1-i.south) |- (l2-1.north);%
      \draw (l1-1-d.south) |- (l2-1.north);%

      \node [draw, dashed, inner sep=10pt, fit=(unit-1) (l2-1)] (c-1) {};%

      % core 2
      \node [draw, text width=100pt, inner sep=10pt, text badly centered,
      above=of l3-2] (l2-2) {Cache L2};%
      \draw (l3-2) -- (l2-2);%

      \node [above=20pt of l2-2] (l1-2) {};%
      \node [draw, right=0pt of l1-2.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-2-i) {Cache L1 {\small (Instruction)}};%
      \node [draw, left=0pt of l1-2.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-2-d) {Cache L1 {\small (Data)}};%
      \node [draw, text width=100pt, text badly centered, inner sep=10pt,
      minimum height=40pt, above=20pt of l1-2] (unit-2) {Execution Unit};%

      \draw (unit-2.south) -| (l1-2-d.north);%
      \draw (unit-2.south) -| (l1-2-i.north);%
      \draw (l1-2-i.south) |- (l2-2.north);%
      \draw (l1-2-d.south) |- (l2-2.north);%

      \node [draw, dashed, inner sep=10pt, fit=(unit-2) (l2-2)] (c-2) {};%

      % core 3
      \node [draw, text width=100pt, inner sep=10pt, text badly centered,
      below=of l3-3] (l2-3) {Cache L2};%
      \draw (l3-3) -- (l2-3);%

      \node [below=20pt of l2-3] (l1-3) {};%
      \node [draw, right=0pt of l1-3.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-3-i) {Cache L1 {\small (Instruction)}};%
      \node [draw, left=0pt of l1-3.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-3-d) {Cache L1 {\small (Data)}};%
      \node [draw, text width=100pt, text badly centered, inner sep=10pt,
      minimum height=40pt, below=20pt of l1-3] (unit-3) {Execution Unit};%

      \draw (unit-3.north) -| (l1-3-d.south);%
      \draw (unit-3.north) -| (l1-3-i.south);%
      \draw (l1-3-i.north) |- (l2-3.south);%
      \draw (l1-3-d.north) |- (l2-3.south);%

      \node [draw, dashed, inner sep=10pt, fit=(unit-3) (l2-3)] (c-3) {};%

      % core 3
      \node [draw, text width=100pt, inner sep=10pt, text badly centered,
      below=of l3-4] (l2-4) {Cache L2};%
      \draw (l3-4) -- (l2-4);%

      \node [below=20pt of l2-4] (l1-4) {};%
      \node [draw, right=0pt of l1-4.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-4-i) {Cache L1 {\small (Instruction)}};%
      \node [draw, left=0pt of l1-4.center, text badly centered, text
      width=50pt, inner sep=5pt] (l1-4-d) {Cache L1 {\small (Data)}};%
      \node [draw, text width=100pt, text badly centered, inner sep=10pt,
      minimum height=40pt, below=20pt of l1-4] (unit-4) {Execution Unit};%

      \draw (unit-4.north) -| (l1-4-d.south);%
      \draw (unit-4.north) -| (l1-4-i.south);%
      \draw (l1-4-i.north) |- (l2-4.south);%
      \draw (l1-4-d.north) |- (l2-4.south);%

      \node [draw, dashed, inner sep=10pt, fit=(unit-4) (l2-4)] (c-4) {};%
    \end{tikzpicture}
  \end{center}
  \caption{Typical caches organization of a x86 processor}
  \label{fig:usecase:l1-l3caches}
\end{figure}

When a \ac{cpu} successfully reads the memory at a given address, it keeps a
copy of the result in its cache.
%
Therefore, the next time it needs to read some data at this address, these data
are retrieved from the cache.
%
Regarding write accesses, Intel x86 \acp{cpu} provide five different caching
strategies (uncacheable, write combining, write-through, write-back and
write-protected)\,\cite[Volume 3, Chapter~11]{intel2014manual}.
%
Fine-grained cache strategy configuration is achieved through several hardware
mechanisms, including (but not limited to):
%
\begin{itemize}
\item The \texttt{CR0} register has a flag called \texttt{CD}, which enables
  caching once set.
%
\item The \ac{cpu} has several registers called Memory Type Range Registers
  (MTRR), to specify a cache strategy for pre-defined memory regions.
  %
  Each MTRR \TODO{la phrase n'est pas terminée}
\item The Page Table Attribute (PAT) allows for configuring a cache strategy at
  a memory page granularity.
\end{itemize}
%
The write-back strategy is the most commonly used and is summarized in
Figure~\ref{fig:usecase:writeback}.
%
The purpose of this strategy is to reduce the number of \IO forwarded
to the \ac{dram}.
%
To that end, each cache block \TODO{C'est quoi un cache bloc? Il faudrait l'expliquer rapidement avant (il faudrait brièvement décrire la structure d'un cache).} has a ``dirty bit'' which is set by the cache when its value is updated by a write access.
%
In case of cache eviction \TODO{c'est quoi cache eviction?}, the cache verifies the value of the ``dirty bit'', so it can update the underlying memory cell if necessary.
%
Therefore, as long as the cache block is not evicted, the \ac{cpu} does not
issue write access to the underlying memory.
%
The write-back strategy is not suitable for memories of other hardware components
mapped into the \ac{cpu} address space.
%
For instance, caching \IOs targeting a framebuffer does not make sense, because
the screen wouldn't be updated.
%
This is why Intel provides four complementary strategies.
%
The uncacheable strategy disables the cache for the given address, while write
combining, write-through, write-back and write-protected are similar strategies
such that write accesses are directly forwarded to the underlying memory. \TODO{euh, du coup c'est quoi la différence entre "uncacheable" et les autres stratégies "similaires". Naivement j'aurais tendance à penser que désactiver le cache revient à rediriger directement l'écriture vers la mémoire. A oui, ok, pour la lecture de contenu non modifié, les stratégies en question te permette une optimisation. Mais il faudrait le préciser car sinon on ne comprends pas trop pourquoi tu distingues ces différents cas.}

For cache-friendly programs, the gain in performance can be huge. \TODO{utilité de ce dernier paragraphe? en outre, il n'est pas vraiment raccord avec ce qui précède.}
%
For instance, for a Pentium M Intel  stated that access to L1 cache takes 3
\ac{cpu} cycles, access to the L2 cache takes 12 cycles and access to the DRAM
takes 240 cycles\,\cite{drepper2007memory}.

\begin{figure}
  \centering
  \begin{tikzpicture}
    \node [draw, circle] (EP) {};%

    \node [draw, below=of EP] (Sel) {Select a cache block};%
    \draw [-latex] (EP) -- (Sel);%

    \node [draw, signal, signal to=east and west, below=of Sel] (CH) {Cache
      hit?};%
    \draw [-latex] (Sel) -- (CH);

    \node [below=of CH] (CHbranch) {};%
    \draw (CH) to node [right] {[Yes]} (CHbranch.center);%
    \node [left=70pt of CH] (nCHbranch) {};%
    \draw [below] (CH) to node {[No]} (nCHbranch.center);

    \node [draw, signal, signal to=east and west, below=of nCHbranch.center]
    (Dirty) {Cache block dirty?};%
    \draw [-latex] (nCHbranch.center) -- (Dirty);%

    \node [draw, below=of Dirty, text width=70pt, text badly centered] (WB)
    {Write the content of the cache block back to the DRAM};%
    \draw [-latex] (Dirty) to node [right] {[Yes]} (WB);%

    \node [draw, below=of WB, text width=80pt, text badly centered] (Rf) {Read
      data from lower memory and fill the cache block};%
    \draw [-latex] (WB) -- (Rf);%

    \node [draw, below=of WB, text width=80pt, text badly centered] (Rf) {Read
      data from lower memory and fill the cache block};%
    \draw [-latex] (WB) -- (Rf);%

    \node [draw, below=of Rf, text width=80pt, text badly centered] (NotDirty)
    {Mark the cache block as ``not dirty''};%
    \draw [-latex] (Rf) -- (NotDirty);%

    \draw (Dirty) to node [below] {[No]} ([xshift=-90pt]Dirty.center);%
    \draw ([xshift=-90pt]Dirty.center) -- ([xshift=-90pt]Rf.center);%
    \draw [-latex] ([xshift=-90pt]Rf.center) -- (Rf);%
    \draw [-latex] (Rf) -- (NotDirty);%

    \node [below=260pt of CHbranch.center] (Join) {};%
    \node [draw, signal, signal to=east and west, below=5pt of Join] (RxW) {Read
      or Write?};%
    \draw [-latex] (CHbranch.center) -- (RxW);%
    \draw (NotDirty) -| (Join.center);%

    \node [draw, text badly centered, text width=70pt, right=50pt of RxW] (R)
    {Return data};%
    \draw [-latex] (RxW) to node [below] {[Read]} (R);%
    \node [draw, text badly centered, text width=70pt, left=50pt of RxW] (W)
    {Write new value in cache block};%
    \draw [-latex] (RxW) to node [below] {[Write]} (W);%

    \node [draw, text badly centered, text width=70pt, below=of W] (MakeDirty)
    {Mark cache block as dirty};%
    \draw [-latex] (W) -- (MakeDirty);

    \node [draw, fill=black, below=100pt of RxW, circle] (End) {}; \draw
    [-latex] (MakeDirty.south) |- (End.west); \draw [-latex] (R.south) |-
    (End.east);
  \end{tikzpicture}

  \caption{The Write-Back cache strategy}
  \label{fig:usecase:writeback}
\end{figure}

\paragraph{Attack Path.}
%
The SMRAM Cache Poisoning leverages the write-back strategy of the \ac{cpu}
cache to circumvent the \texttt{D\_LCK} bit protection.
%
The attack proceeds as follows:

\begin{enumerate}
\item Attackers set the cache strategy to be used for the SMRAM addresses to
  write-back.
  %
  This can be done by a malicious system software component, or even by a
  malicious application under certain circumstances (for instance, if an
  operating system exposes a software interface to manage the cache from the
  userland).

%
\item They write to the \texttt{APM\_CNT} register in order to provoke the
  triggering of a \ac{smi}.
%
\item The \ac{smm} \TODO{BIOS code plutôt que SMM? "SMM code exécuté en SMM" fait bizarre } code is executed in SMM, leading the cache to be filled with
  copies of that code
%
\item \TODO{Il faudrait mentionner qu'à la fin de l'étape 3, le processeur a quitté le SMM}Attackers write to an address which belongs to the SMRAM, and because of
  the write-back cache strategy, the \ac{cpu} updates the copies within the
  cache, and does not forward the \IO to the Memory Controller.
%
\item Attacker trigger another \ac{smi}, and the \ac{cpu} uses the tampered copy
  of the \ac{smm} code inside its cache.
\end{enumerate}
%
This attack is a perfect illustration of an compositional attack:
%
both the Memory Controller and the \ac{cpu} cache work as expected.
%
The former prevents authorized accesses to the SMRAM, that is a subset of the
\ac{dram}, by a \ac{cpu} not in \ac{smm};
%
the latter is keeping copies of successful accesses to decrease latency due to
memory accesses.
%
However, the composition of the cache and the memory controller breaks the BIOS
Integrity property.

\paragraph{Countermeasure.}
%
The solution implemented by Intel to prevent further exploitation of this
vulnerability was to modify the behavior of the cache, when some memory access
target the SMRAM.
%
Because the SMRAM size and location remain specific to each architecture, this
means it requires an additional step of configurations to tell the cache the
physical addresses that belong to the SMRAM.

\paragraph{}
%
The SMRAM Cache Poisoning attack is a textbook case of compositional attacks.
%
It is interesting to notice that six years later, Christopher Domas has
disclosed another x86 vulnerability called Sinkhole\,\cite{domas2015sinkhole},
which relies on a similar approach to trick a \ac{cpu} in \ac{smm} to execute
arbitrary instructions. \TODO{Les contre-mesures contre le cache poisoning ne fonctionnaient pas pour Sinkhole? Elles n'étaient pas encore déployées?}
%
Both attacks leave the content of the SMRAM in \ac{dram} intact, and leverage
only legitimate hardware features.

\subsection{SENTER Sandman}
\label{subsec:usecase:hse:sandman}

In 2015, Xeno Kovah \emph{et al.} showed it was possible to leverage the Intel
TXT technology to circumvent the flash memory lockdown
protection\,\cite{kovah2015senter}.

\paragraph{Intel TXT.}
%
The Intel Trusted eXecution Technology (TXT)\cite{intel2015txt} is a feature of
some x86 \acp{cpu}, whose purpose is twofold.
%
Firstly, it attests the integrity of the system software component program
without the need to trust the \ac{bios}.
%
Secondly, it provides a trusted execution environment to the system software
component.
%
As such, it addresses the main limitation of both the Secure Boot and Trusted
Boot approaches, previously detailed in
Subsection~\ref{subsec:usecase:firm:boot}.
%
Similarly to the Trusted Boot approach, TXT entrusts measurement of the system
software component program to the \ac{tpm}.
%
These measurements can be leveraged to conditionally seal an encryption key or
be part of an attestation protocol, as they would have been with in the context
of a Trusted Boot.
%
However, contrary to the Trusted Boot approach, the component responsible for
measuring the program is the processor itself.
%
This makes a big difference regarding the trust we can place in the
measurements.
%
On the one hand, if the root of trust ---which is part of the \ac{bios}--- has
been corrupted or if the \ac{bios} suffers from an exploitable vulnerability,
the authenticity of the measurements is no longer guaranteed.
%
In such a case, neither the system software component nor a third party involved
in an attestation protocol has a reliable solution to detect the attack.
%
On the other hand, only an error within the implementation of the TXT
instructions can lead to a similar scenario\,\cite{wojtczuk2011txtbug}. \TODO{Comment çà marche? Comment le processeur sait qu'il doit faire ces mesures sans que le BIOS ne puisse l'influencer sur sa décision? Comme tu as choisi de détailler le fonctionnement de cette techno (ce qui peut s'enterndre) il faudrait que tu nous donnes quelques billes supplémentaire pour qu'on comprenne le principe de fonctionnement.}

\paragraph{Attack Path.}
%
The flash memory lockdown mechanism was based under the assumption that
unlocking the flash memory would force the execution of the \ac{bios}, so that
the latter could lock it again.
%
To that end, the \ac{pch} triggers a \ac{smi} at the same time as it unlocks the
flash memory.
%
This mechanism was introduced at a time when software components could not
configure x86 \acp{cpu} to ignore \acp{smi}.
%
This assumption became incorrect when Intel introduced the first version of TXT,
whose ``trusted execution environment'' provided by TXT-capable \acp{cpu}
explicitly disabled \acp{smi} handling.
%
As a consequence, adversarial system software components whose execution were
initiated with TXT were able to unlock the flash memory, without being
interrupted by the \ac{smi} triggered by the \ac{pch} in response.
%
Then, they could freely modify the content of the flash memory, left unprotected
by the \ac{pch}.
% GUILLAUME: \TODO{La description de l'attaque est trop succinte. Il faut
% répeter que sans SMI, d'après le mécanisme de lock down, cela veut dire que la
% flash est inscriptible mais qu'on ne passe pas en SMM du coup n'importe quel
% logiciel peut modifier le contenu de la flash. C'est un manuscript de
% thèse. Il en faut pas faire (trop) de digression mais il faut être (très)
% pédagogique. Tu n'est pas à une page près!}
\PC{Ack avec Guillaume, la description est trop succinte, et le style
  télégraphique} \thomasrk[inline]{Est-ce que c’est mieux comme ça ? Au final,
  la version actuelle n'est pas forcément plus longue, mais elle se concentre
  plus sur l'essentiel et donne les éléments qui manquaient dans les précédentes
  itérations.}
\TODO{Je ne sais pas si c'est mieux qu'avant (je ne me souvient plus) mais je trouve très bien comme çà. Comme tu le dis, la description se concentre sur l'essentiel (en gros, un mécanisme de sécurité qui a été rajouté désactive les SMI). Par contre, on peut se poser la question de l'intérêt de la description de TXT qui précède. Peut-être qu'il est suffisant de dire que TXT est un mécanisme de sécurité additionnel qui a été rajouté par Intel et qui avait la mauvaise idée de désactiver les SMI. Sinon, si tu souhaite détailler TXT, tu détaille  (un peu) actuellement le fonctionnement du mécanisme de vérification d'intégrité mais pas le mécanisme de "trusted execution environment" or c'est celui-là qui est en cause dans l'attaque visiblement...}

\paragraph{Countermeasure.}
%
Recent x86 \acp{cpu} do not disable \ac{smi} when using the \texttt{SENTER}
instructions. \TODO{C'est quoi l'instruction SENTER? Il me semble que tu n'en parles nul part avant}
%
This means the system software component continues to rely on the \ac{bios} code
stored in the SMRAM.
%
In practice, even the first version of TXT was not changing that fact.
%
Indeed, the \ac{bios} plays a key role in making sure the computing platform
remains in a working state.
%
As a consequence, Intel is advising system software developers to enable back
\ac{smi} in the TXT Software Development Guide as ``most systems will not
function properly if \acp{smi} are disabled for any length of
time''\,\cite{intel2015txt}. \TODO{ce dernier paragraphe n'est pas claire. De manière générale, l'explication de la contre-mesure n'est pas claire. }

\subsection{Speed Racer}
\label{subsec:usecase:hse:speed}

Another attack has defeated the flash memory lockdown protection.
%
In 2015, Corey Kallenberg \emph{et al.} showed that the scenario detailed
previously, such that setting \texttt{BIOSWE} triggers a \ac{smi} to suspend the
execution of the system software, suffered from a race condition if two cores
cooperate\,\cite{kallenberg2015racecondition}.

\paragraph{Attack Path.}
%
On a typical x86 hardware architecture, all the x86 cores of the platform will
\emph{eventually} enter \ac{smm} when a \ac{smi} is triggered.
%
On the contrary, the \texttt{BIOSWE} flag is set as soon as the
\texttt{BIOS\_CNTL} register is modified.
%
If two cores cooperate, they can benefit from a sufficient window for action and
successfully tamper with the Flash Memory content.
%
The attack proceeds as follows:

\begin{enumerate}
\item One core tries \emph{ad infinitum} to overwrite the content of the Flash
  Memory.
  %
  Because the \texttt{BIOSWE} bit is initially clear, the \ac{pch} discards its
  attempts, and the Flash Memory content is correctly protected.
%
\item At the same time, another core set the \texttt{BIOSWE} bit.
%
\item A \ac{smi} is triggered, but by the time it propagates to the first core,
  it may have successfully modified the flash memory content.
%
\end{enumerate}

\paragraph{Countermeasure.}
%
To prevent this race condition, Intel has introduced a new configuration bit to
the \texttt{BIOS\_CNTL} register: the \texttt{SMM\_BWP} (\ac{smm} \ac{bios}
Write Protection).
%
If the \texttt{SMM\_BWP} is set, the \ac{pch} discards any write access which
targets the Flash Memory \emph{unless all processors are in \ac{smm}}.

\section{Conclusion}
\label{sec:usecase:conclusion}

In this Chapter, we have detailed the relevant x86 hardware mechanisms involved
in the \ac{hse} mechanism implemented by the \ac{bios} at runtime to stay
isolated from the system software.
%
In addition, we have presented three compositional attacks, to better illustrate
the threats they pose.
%
The rest of this manuscript will use the SMRAM Cache Poisoning Attack as a
recurring application use case for our contributions, because it has motivated
our will to formally specify and verify \ac{hse} mechanisms, and it is a good
illustration of compositional attacks.
