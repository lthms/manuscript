\chapter{Notations}
\label{frontmatter:notations}

\paragraph{Conventions}
%
We often define sets of values, and interfaces in particular, in terms of
functions to construct these values.
%
These functions are called ``constructors,'' and they have mutually exclusive
images, i.e. it is not possible to construct the same value with two different
constructors.
%
Constructor names begin with a capital letter.
%
We adopt a notation similar to Haskell sum types to define sets \emph{via}
constructors.
%
That is, we can define the disjoint union operator $\uplus$ as follows:
%
\[
  \begin{array}{rcl}
    A \uplus B & \triangleq & \func{Left} : A \rightarrow A \uplus B \\
               & |          & \func{Right} : B \rightarrow A \uplus B
  \end{array}
\]

Given $a \in A$, we write $\func{Right}(a) \in A \uplus B$ for the injection of
$a$ inside $A \uplus B$.

\paragraph{Named Tuples}
%
We adopt a notation similar to Haskell record types to manipulate ``named''
tuples, that is tuples where each component is a field identified by a name.

\[
  \begin{array}{rccll}
    A & \triangleq & \{ & \func{field_1}: & T_1 \\
      &            & ;  & \func{field_2}: & T_2 \\
      &            & \} &
  \end{array}
\]

For $a \in A$, we write $a.\func{field_1}$ for selecting the value of the
\func{field_1} field. We write $a \{ \func{field_1} \leftarrow t \}$ for
updating the value of the field \func{field_1}. As a consequence,
%
\[
  a \{ \func{field_1} \leftarrow t \}.\func{field_1} = t
\]