%!TEX root = ../main.tex
\chapter{Intel x86 Hardware and BIOS Background}
\label{chapter:usecase}

\endquote{``\emph{You’re building your own maze, in a way, and you might just
    get lost in it.}''

  \hfill\footnotesize --- Marijn Haverbeke}

\vspace{1cm}\noindent
%
Our motivation to formally specify and verify architectural attacks comes from
our experience with the x86 hardware architecture.
%
\TODO{"our experience" fait un peu pédant. Tu n'es pas le seul à t'intéresser au
  problème...}
%
Over the past decade, the security of the lowest levels of abstraction
(hardware, firmware, system software) has grown in importance, and several
critical vulnerabilities which fall in our definition of architectural attacks
have been disclosed.
%
\TODO{ref!, En outre, cette phrase est très générique alors qu'il me semble que
  ce que tu veux dire c'est que l'architecture x86 en particulier est devenu de
  plus en plus complexe (et de fait, c'est surement une des architecture les
  plus complexe). En outre, elle est très populaire sur les laptop, desktop et
  serveurs}
%
While our contributions are intended to be applicable to other hardware
architectures, for purposes of evaluating our work, we have adopted the systemic
approach to apply them to a x86 real example.
%
\TODO{pourquoi "systematic". je
  dirais plus sobrement, nous avons décidé d'évaluer notre approche sur
  l'architecture x86, qui représente une cible idéeal pour ce type
  d'approche. Toutefois, notre approche peut tout à fait s'appliquer à d'autres
  architecture, par exemple ARM très populaire dans les smartphones et systèmes
  embarqués.}
%
We have chosen to focus on the \ac{hse} mechanism implemented by the BIOS at
runtime to stay isolated from the rest of the software stack, including the
system software.
%
Because the BIOS is the most privileged piece of software executed by the
hardware architecture, this \ac{hse} mechanism is of key importance.
%
Despite this fact, it has been defeated several times \TODO{REF!}, and
therefore, it illustrates perfectly our motivations.
%
However, it is important to emphasize that other mainstream architecture
(\emph{e.g.}  ARM) work on a similar basis and suffer similar issues.

The rest of this Chapter proceeds as follows.
%
We describe how a typical x86 hardware architecture is organized, and the
consequences of this organization in terms of security
(Section~\ref{sec:usecase:architecture}).
%
We then focus on the key role played by the \ac{bios}, and the security model it
requires so it can play this role (Section~\ref{sec:usecase:firmware}).
%
Once the role of the \ac{bios} has been established, we detail \ac{hse}
mechanisms it implements, and several architectural attacks which have defeated
these \ac{hse} mechanisms in the past (Section~\ref{sec:usecase:hse}).

\section{Hardware Architecture Overview}
\label{sec:usecase:architecture}

Describing hardware architectures in depth is challenging, because they tend to
be made of many interconnected components of various natures.
%
From this perspective, the x86 hardware architecture is a textbook case, and
this is probably best illustrated by the scale of its documentation.
%
At the time of writing this thesis\,\footnote{Spring 2018.}, the \emph{Intel 64
  and IA-32 Architectures Software Developer’s Manual} is 4842 pages long.
%
Executed on the computer used to write the present thesis, the GNU/Linux
command-line application \texttt{lshw} lists about 30 hardware components, which
come with their own documentation, often in the form of large data sheet.
%
\TODO{Donne quelques exemples de composants, sans être exaustif}

A x86 computing platform is built upon two key components: \acp{cpu} and memory
(\ref{subsec:usecase:cpumem}).
%
The \ac{cpu} communicates with peripherals to interact with the outside world
(\emph{e.g.} another computing platform, a user) (\ref{subsec:usecase:perif}).
%
\TODO{Ajouter un schéma d'archi x86 big picture (attention à ne pas être trop
  générique).}

\subsection{Processors and Memory}
\label{subsec:usecase:cpumem}

A computer platform goal is to execute programs to perform arbitrary tasks.
%
To that end, it relies on one or more \acp{cpu}.
%
\TODO{II faudrait décrire un peu plus précisement l'architecture x86 : CPU,
  coeur physique, coeur logique. }
%
A \ac{cpu} takes so-called ``instructions'' as input, and manipulates its
internal states and data stored in a memory, as output.
%
A program is a sequence of instructions, often stored in the same memory as the
data it manipulates.
%
\TODO{Dire explicitement que des fois ce n'est pas le cas par exemple cache
  instruction vs cache donnée, exécution d'un programme en ROM}
%
Overall, a \ac{cpu} basically repeats the following task, over and over:

\begin{enumerate}
\item Read the content of its (internal) \emph{program counter} register, and
  interpret it as the address of the next instruction.
%
\item Fetch the content of this address from memory.
%
\item Decode the instruction, that is identified the desired operation to
  perform
%
\item Act accordingly, by modifying its internal state, and interacting with the
  memory.
  %
  \TODO{et/ou les périphérique, même s'ils sont de plus en plus abstrait sous
    forme de mémoire}
%
\item Update the content of its \emph{program counter} register according to the
  semantics of the instruction it has executed. Most of the time, it increases
  it to fetch the next instruction, but it can also set it to an arbitrary value
  (\emph{e.g.} with jump instructions).
\end{enumerate}

From the \ac{cpu} perspective, the memory is abstracted into a contiguous array
of storage cells, identified by an address.
%
A \ac{cpu} can interact with the memory by reading or writing to a given
address.
%
In reality, a hardware architecture contains several memories of various
natures.
%
The \ac{dram} remains the most important, and is often called the \emph{system
  memory}, but it is not the only memory present in a hardware architecture.
%
Peripherals expose memories too; the latter are used as communication channels
between them and the \acp{cpu}.
%
That is, to ``receives a message'' from a peripheral, a \ac{cpu} reads the
content of the memory it exposed, while it can ``send a message'' by writing to
the same memory.
%
\TODO{Tu pourrais aussi citer la ROM du BIOS, peut-être donner un petit exemple
  de code qui interagit avec un périphérique}.

\paragraph{}
%
Historically, x86 \acp{cpu} were using two distinct memory spaces to communicate
either with the \ac{dram} or with the peripherals, \emph{via} two families of
instructions. \TODO{Cites les explicitement "in/out vs. mov/push/pop..."}
%
Nowadays, the memories exposed by the peripherals are mapped within the same
address space, and accessed with the same instructions.
%
That is, when a \ac{cpu} read or write to an address, the access is
transparently dispatched either to the \ac{dram} or to a peripheral.
%
The first component to intervene in the decision process is the Memory
Controller (formally known as the \emph{northbridge}, and that is now integrated
to the \ac{cpu} Die).
%
The Memory Controller is connected to the \ac{dram} and to peripherals which
require small latency, such as a graphic card or a ethernet controller.
%
\TODO{Ethernet controler? A vérifier...}
%
If a given memory access does not target one of its peripherals or the
\ac{dram}, the Memory Controller forwards the memory access to the \ac{pch}
(formally known as the \emph{southbridge}).
%
The \ac{pch} acts as a proxy for the remaining peripherals.

\paragraph{} \TODO{Pas de paragraph sans titre. Soit tu revois ton découpage en
  sous-section, soit tu découpe dès le début ta sous-section en plusieurs
  paragraph avec des titres}
%
One important property of x86 hardware architecture is that the memory map,
which is the correspondence between the addresses used by the \ac{cpu} and the
storage cells scattered among the hardware architecture, is dynamically
configurable.
%
\TODO{Il serait bien d'evoquer ici rapidement la mémoire virtuelle. pagination
  plus segmentation.}

As such, determining which hardware component will receive a given memory access
is far from being trivial.
%
\TODO{j'aime pas trop "far from being trivial". En outre, il faudrait donner un
  peu plus d'info pour juger objectivement si c'est difficile ou non.}

\subsection{Peripherals}
\label{subsec:usecase:perif}

It is worth mentioning that, since 2008, Intel embeds the Management Engine, a
processor \emph{inside} the memory controller.

\TODO{Commencer à parler du ME avant de parler des périphériques simples me
  semble contre-intuitif. Je décrirai les interactions "standard" avec les
  périphériques. Puis je parlerai de DMA. Enfin j'aborderai ME (avec des
  références!). Par ordre croissant de complexité. En outre, ta description du
  CPU et de la mémoire est factuelle et descriptive (tu décris comment çà
  marche). Alors que pour les périphériques, tu te lances directe dans une
  analyse de sécurité avant d'avoir décrit leur fonctionnement et le lien avec
  le reste. En outre, tu n'as pas encore parlé des propriétés et mécanismes de
  sécurité.  }
%
The Management Engine executes a complete software stack, and is capable of
interacting with the \ac{dram} as well as other hardware components.
%
Intel leverages the Management Engine to provide out-of-band management
solution, which means it can interact with the rest of the world without the
cooperation of the main \ac{cpu}.
%
Although the Management Engine supposedly operates in a transparent manner from
the \ac{cpu} perspective, we emphasize that a Management Engine vulnerability, a
scenario which is not without precedent, potentially defeats any security
measures implemented at the \ac{cpu} level.
%
\TODO{Il y a maintenant une litterature abondante (y compris dans le domaine
  académique) sur le sujet. As te lire, on a l'impression que c'est toi qui a
  analysé le problème. Tu devrais présenter cela de manière plus impersonnelle
  et en citant des ref! En outre, pourquoi parle tu du ME? Quel est le lien avec
  le reste?}

The security threat posed by the Management Engine is not an isolated case.
%
On the contrary, x86 hardware architectures contain several \emph{active}
peripherals.
%
We say a peripheral is active if it can autonomously read and write to the
system memory, \emph{via} \ac{dma}.
%
This feature brings an important performance improvement, but it also opens an
important surface of attacks.

Historically, peripherals have been part of the \ac{tcb} of every x86 \ac{hse}
mechanisms, with important consequences on the computing platform security.
%
\TODO{Tu n'as pas défini avant la TCB, il me semble.}
%
For instance, Loic Duflot \emph{et al.} have been able to take control of a
network card. They exploit some vulnerability in the network card firmware,
which process network packets\,\cite{duflot2010network}.
%
Because the network card can perform \ac{dma}, they were able to tamper with the
system software code and data.
%
It has also been repeatedly shown that the various physical interface exposed by
the computer (\emph{e.g.} USB\,\cite{nohl2014badusb},
Thunderbolt\,\cite{hudson2015thunderstrike}, PCI\,\cite{chifflier2013uefi})
could be leveraged to achieve similar goals.

In that respect, the current situation has improved.
%
Modern x86 \acp{cpu} provide a feature called I/O MMU \TODO{ref!}, which allows
for configuring the memory ranges each peripheral can access to.
%
In addition, Intel tends to take rogue peripherals into account when it
conceives new security features.
%
\TODO{affirmation un peu gratuite sur Intel. Référence? }
%
A good example is the \ac{sgx} technology, whose \ac{tcb} is limited to the
\ac{cpu} and its Memory Controller\,\cite{costan2016sgxexplained}.

\subsection{Security Properties}

From a security perspective, the attack surface on x86 computing platform is
large.
%
\TODO{phrase un peu gratuite. Surtout on ne voit pas le lien avec ce qui
  suit. Ce qu'il faudrait dire, c'est que le CPU et la RAM sont des ressources
  partagées par les différents composants logiciels et matériels. Du coup, d'un
  point de vue de la sécurité, comme ces composants ne se font pas
  nécessairement confiance (parsqu'ils viennent de fournisseur différent,
  parqsu'il peuvent être malveillant ou vulnérables, etc.) il est nécessaire de
  les isoler les un les autres. La plupart des mécanismes de sécurité de la
  plateforme fournisse don c un mécanisme d'isolation}
%
The different software components which form the software stack are executed by
the same \acp{cpu}, the instructions which form their programs are stored within
the same memories, which they also manipulate concurrently \emph{via} a
configurable memory map.
%
In addition, active peripherals can also access the main memory concurrently
with the \ac{cpu}, and they tend to be part of the \ac{tcb}.
%
\TODO{Que veut dire "tend to be part of the TCB"? TCB de quoi?}
%
As a consequence, most of the \ac{hse} mechanisms implemented in x86 computing
platforms aim to enforce isolation properties, to prevent untrusted software
\TODO{ou hardware dans le cas de l'IOMMU} components to tamper with the
execution of trusted ones.
%
These isolation properties can take three forms.

\begin{definition}[Integrity]
  \label{def:usecase:int}
  The trusted software component is assigned a portion of the memory map.
  %
  Untrusted software components cannot tamper with the result of read accesses
  targeting this portion and performed by the trusted software component.
\end{definition}

\begin{definition}[Confidentiality]
  The trusted software component is assigned a portion of the memory map.
  %
  It can hide its secrets inside this portion, and untrusted software components
  cannot get these secrets from the result of a read access.
\end{definition}

Integrity and confidentiality properties have to be considered from an
information flow perspective.
%
The content of specific storage cells inside the hardware architecture is less
relevant than the logical view exposed to the \acp{cpu}.
%
\TODO{Telle quelle, cette phrase n'est pas compréhensible. Il faut que tu donnes
  plus de détails/explication pour qu'on comprenne ce que tu veux dire. Je pense
  que je comprends vaguement mais c'est suite à la discussion que nous avons eu}

\begin{definition}[Availability]
  Untrusted software components cannot prevent the execution of a trusted
  software component.
\end{definition}

On the contrary, there are complete classes of security properties which are not
covered by \ac{hse} mechanisms.
%
\TODO{La phrase est maladroite. Pourquoi "on the contrary"?}
%
The most famous is probably noninterference properties \TODO{ref!!!}, notably
defeated \emph{via} side-channel attacks (\emph{e.g.} cache-timing
attacks). Indeed, Intel documentation clearly state
%
\TODO{Beaucoup de confusion dans ce paragraphe. 1) si tu parles de information
  flow et que tu dis que tu ne peux pas traiter la noninterference, tu vas te
  faire allumer... 2) la non-interference ne traite généralement pas des canaux
  auxilliaires mais seulement des flux directe et indirecte qui résulte d'une
  écriture explicite dans un conteneur d'informatin ou canal public et 3) je ne
  comprends pas ce que tu veux dire avec la citation du manuel Intel}:

\begin{quote}
  The Intel architecture aims to provide protection against software
  side-channel attacks at the cache line granularity.

  \hfill\small \emph{Intel Software Guard Extensions, Developer Guide}
\end{quote}

Because computer programs rarely fit inside a cache line, preventing
side-channel attacks therefore additional software-based security enforcement
mechanisms.
%
\TODO{Je pense qu'il manque un verbe à cette phrase.}

\section{BIOS Overview}
\label{sec:usecase:firmware}

The \ac{bios} plays a significant role in Intel x86 computing platform.
%
It is the first piece of software executed by the \ac{cpu}, and initiates both
the hardware architecture and the system software execution during the boot
sequence (\ref{subsec:usecase:firm:boot}).
%
At runtime, it remains active to perform various tasks, including and not
limited to platform-specific events, device emulation, or \ac{bios} update
management (\ref{subsec:usecase:firm:runtime}).
%
As such, it is a natural part of the rest of the software stack \ac{tcb}
\TODO{je ne comprends pas ce que veut dire ce début de phrase}, and it can only
operate if certain security requirements are met
(\ref{subsec:usecase:firm:sec}).

\subsection{During the boot sequence}
\label{subsec:usecase:firm:boot}

The \ac{bios} program is stored inside a flash memory, a small memory connected
to the \ac{pch} through the Serial Peripheral Interface (SPI) bus on modern x86
computing platform.
%
When the \ac{cpu} is powered up, it is programmed to fetch the code stored at a
hard-coded address within the flash memory.
%
The first task of the \ac{bios} is to initiate the hardware architecture,
starting with the \ac{dram}. \TODO{ref}
%
Once the hardware components of the computing platform have been initialized,
the \ac{bios} searches for a system software component to load into memory.
%
Historically, ``legacy'' \acp{bios} were looking for a Master Boot Record (MBR)
at the beginning of mass storage devices (\emph{e.g.} hard drive, USB stick).
%
The MBR, whose size is limited to 512 bytes, contains a small program to
initiate a loader for the system software.
%
Modern \acp{bios} implement the \ac{uefi} \TODO{ref}, whose purpose is to
standardize the boot sequence process in order to favour interoperability of
\ac{bios} implementations.
%
In particular, UEFI-compliant \ac{bios} can load so-called UEFI applications of
arbitrary size, leading modern operating systems \TODO{tu mélange operating
  system et system software. Je propose de parler d'OS, qui est un acronyme
  communement admis} to be packaged as UEFI applications.

The \ac{uefi} standard includes several security mechanisms.
%
For instance, it defines a protocol called the Secure Boot \TODO{ref!}, which
can be leveraged to improve the security of the boot sequence.
%
If Secure Boot is enabled, the UEFI-compliant \ac{bios} will only execute
applications which provide an acceptable cryptographic signature, with respects
to a key hierarchy configurable by the computing platform owner.
%
Ironically, the \ac{uefi} standard makes it easier to write portable piece of
software which can be executed prior to any system software.
%
As a consequence, it increases the attack surface of the computing platform in
case of bad \ac{bios} configuration (\emph{e.g.} Secure Boot is disabled).
%
\TODO{Cette fin de section est un peu confuse. Je dirais plus simplement que
  comme le BIOS est un logiciel privilégié, il est important de s'assurer de
  l'intégrité du code correspondant. Aujour'hui, des mécanismes
  d'authentification cryptographiques sont utilisé pour s'assurer de l'intégrité
  du code avant qu'il soit exécuté ou lors des mises à jour. Par exemple,
  Trusted/secure Boot...}

\subsection{At runtime}
\label{subsec:usecase:firm:runtime}

Once a system software component has been selected and loaded into memory
(ideally, without any tampering with the \ac{bios}, \TODO{Que veux-tu dire par
  "idealy, without any ... with the BIOS", ce n'est pas claire. En outre, éviter
  les phrases avec des avec des assertion floue genre "idealement",
  "généralement, etc. Il faut ou il ne faut pas faire x ou y.}), the boot
sequence ends, and the runtime begins.
%
At runtime, the system software is in charge of the \ac{cpu} control flow,
meaning it decides which piece of software is executed at a given time.
%
However, the \ac{bios} remains active.

Firstly, it provides a software interface to the system software.
%
\TODO{a software interface pour faire quoi? La phrase telle quelle est
  bizzare. A software interface to access to some vendor specific hardware
  features ou autre truc dans le genre.}
%
Some of these \emph{runtime services}, as they are called by the \ac{uefi}
standard \TODO{est-ce que des services runtime existent dans le BIOS classique?
  runtime service est un truc spécifique à UEFI. Ok aujourd'hui la plupart des
  BIOS sont UEFI mais çà vaudrait le coup de parler du concept général puis de
  parler des instances spécifiques à un type d'implémentation}, can be leveraged
by the system software as an intermediary layer to interact with the hardware
architecture.
%
In doing so, it reduces the coupling between the system software and the
hardware components.
%
Other runtime services are mandatory gates towards certain computing platform
features.
%
\TODO{Pourquoi other? Some? Tu n'explique pas pourquoi ils sont des "mandatory
  gates" Parsqu'on ne fait pas confiance à l'OS pour accéder à certaines
  fonctionnalité qui pourraient notamment atteindre à l'intégrité de la
  plateforme (gestion de l'énergie) ou du firmware lui-même. }
%
For instance, software update for the \ac{bios} code is performed by the
\ac{bios} itself, so that the latter can validate the validity of the update.

Secondly, the \ac{bios} often needs to operate independently of the system
software.
%
\TODO{Je ne comprends pas cette phrase ni le lien avec la suivante}
%
For instance, it manages platform-specific events whose internals are not
publicly documented.
%
Some \acp{bios} also emulate complete hardware devices, in a transparent manner
from the system software perspective.
%
The \ac{bios} autonomy \TODO{que veux dire autonomy dans ce contexte. Et surtout
  quel est le lien logique avec la phrase suivante (software vuln affecting...)}
from the system software has important consequences in terms of security.
%
Software vulnerabilities affecting the \ac{bios} could by used by an attacker to
take complete control over the software stack executed by the \ac{cpu}.

\subsection{Security Model}
\label{subsec:usecase:firm:sec}

The \ac{bios} is provided by the hardware architecture’s manufacturer.
%
In most cases, it is a proprietary software, and the computer owner has little
control over it.
%
From the manufacturer software stack \TODO{la répétition de software stack est
  bizarre. From the manufacturer point of view?}, the rest of the software stack
is considered untrusted, and the main goal of the \ac{bios} is to keep the
computer in a working state.
%
Indeed, a malicious or erroneous system software could
theoretically. \TODO{could theoretically what?}
%
The question whether this model benefits the x86 computing platform is out of
the scope of this thesis. \TODO{Je ne vois pas trop de que benefits veut
  dire. Si ce n'est pas l'objet, autant ne pas en parler.}
%
We rather focus on its implementation, because of the important consequences in
terms of security if an attacker succeeds in defeating it.
%
\TODO{phrase ambigu. Tu vas plutôt t'intéresser à la spécification.}

The security model of a x86 \ac{bios} can be divided into two complementary
security properties.
%
\TODO{D'où viennent ces propriétés de sécurités? Elles sont clairement établies
  par Intel ou d'autres chercheurs. C'est toi qui les propose? A partir de quoi?
  Il faut clarifier cela.}

\begin{definition}[BIOS Integrity]
  \label{def:usecase:biosint}
  The \ac{bios} is assigned two memories: the flash memory and a subset of the
  \ac{dram}, and the rest of the software stack cannot tamper with the result of
  read accesses performed by the \ac{bios} which target one of these memories.
  %
  \TODO{J'écrirerais la propriété de manière plus succinte et directe du style
    (the rest of the software stack (i.e the OS, applications...) cannot tamper
    with the result of read accesses performed by the BIOS on its dedicated
    memory regions. Such regions typically consists of the flash memory and a
    subset of the DRAM. En outre "tamper with" est-elle une expression
    idiomatique qui correspond précisement à ce que tu veux dire?}
\end{definition}

The \ac{bios} should be the only software component with the capability to
modify the memory flash content.
%
This prevents the scenario where an arbitrary system software rewrite the
\ac{bios} code inside the flash memory, then provoke a reboot.
%
\TODO{Pourquoi "arbitrary system software" ? Dire tout simplement que, comme les
  vendeurs ne font pas confiance à l'OS, celui-ci ne peut modifier directement
  la flash. Cela permet de garantir qu'un OS compromis ou malveillant ne puisse
  modifier le code du firmware arbitrairement.}
%
Besides, the flash memory is not the only memory dedicated to the \ac{bios}.
%
Memory accesses which target the flash memory are slow, as the latter is
connected to the \ac{pch}, behind the Memory Controller.
%
\TODO{Ce n'est surement pas la seule raison : la technologie de la mémoire flash
  est intrinséquement plus lente que la RAM. En outre, je suppose que tu dois
  être limité en nombre de lecture/écriture en termes de durée de vie. Bref,
  c'est un choix technologique qui n'est pas spécifique au BIOS, on utilise de
  la mémoire rémanente qui est lente pour assurer la persistence et de la
  mémoire volatile qui est rapide pour l'exécution}
%
This is why Intel dedicates a portion of the system memory \TODO{DRAM? c'est
  quoi system memory?} to the \ac{bios} runtime code \TODO{c'est quoi runtime
  code? il y a du code non runtime?}, and for understandable reason \TODO{Eviter
  les expression du style "for understandable reason, obviously, etc." Reste
  factuel.} provides the means to prevent the system software to tamper with
this portion.

\begin{definition}[BIOS Availability]
  \label{def:usecase:biosav}
  If needed, the \ac{bios} can temporarily retrieve the \ac{cpu} control flow,
  without any cooperation \TODO{que veut dire "cooperation"? Peut-être que
    "preemptif" décrit ce que tu veux dire} required from the system software.
\end{definition}

The system software is untrusted, but it controls the \ac{cpu} control flow.
%
\TODO{Controle le control flow n'est pas très claire. L'OS peut préempter
  l'exécution des applicatons. Le firmware peut à son tour présempter
  l'exécution de l'OS et des applications.}
%
We want to avoid a scenario where an arbitrary system software prevent the
execution of the \ac{bios} at runtime.
%
\TODO{Eviter les formulation personnelle "we want" sur quelque chose qui ne
  relève pas de ton implémentation ou de ton approche. Se sont des choix fait
  par les designer de la plateforme x86, pas par toi.}

\TODO{Quid de la confidentialité? De manière générale, tu annonces avant trois
  propriétés générale puis maintenant tu en définis 2. Quel est le lien?
  Pourquoi redéfinir des propriétés?}

\section{BIOS HSE Mechanism and Architectural Attacks}
\label{sec:usecase:hse}

To stay isolated from the rest of the software stack at runtime, the \ac{bios}
implements a \ac{hse} mechanism whose key hardware feature is the \ac{smm}, a
dedicated execution mode of x86 \acp{cpu} (\ref{subsec:usecase:hse:smm}).
%
The \ac{smm} provides the necessary features to enforce both \ac{bios} Integrity
(Definition~\ref{def:usecase:biosint}) and \ac{bios} Availability
(Definition~\ref{def:usecase:biosav}).
%
Despite the key importance of \ac{smm}, several architectural attacks have been
disclosed over the past decade, including the SMRAM Cache Poisoning Attack
(\ref{subsec:usecase:hse:smram}), SENTER Sandman
(\ref{subsec:usecase:hse:sandman}) and Speed Racer
(\ref{subsec:usecase:hse:speed}).

\subsection{System Management Mode}
\label{subsec:usecase:hse:smm}

To handle several software components with different level of privileges, Intel
\acp{cpu} provide several execution modes.
%
An execution mode can be roughly \TODO{evite les formulation vague du style
  'roughly"} assimilated to a set of hardware capabilities.
%
For instance, in a given execution mode, a \ac{cpu} may refuse to execute
certain assembly instructions, and the software component executed at the time
will not be able to leverage the side effects involved by the execution of these
instructions.
%
Contrary to a common belief, x86 execution modes are not organized in a linear
hierarchy, but are rather a matrix of complementary hardware features: ring
levels, paging configuration, virtualization technologies, \TODO{ ref, ref and
  ref...} etc.
%
Intel describes the \ac{smm} as follows:

\begin{quote}
  \ac{smm} is a special purpose operating mode provided for handling systemwide
  functions like power management, system hardware control, or proprietary
  OEM-designed code.
  %
  It is intended for use only by system firmware, not by application software or
  general-purpose system software.
  %
  \emph{The main benefit of \ac{smm} is that it offers a distinct and easily
    isolated processor environment that operates transparently to the operating
    system or executive and software applications.}

  \hfill \small \emph{Intel 64 and IA-32 Architectures Software Developer’s
    Manual}
\end{quote}

The emphasis is ours, and does not exist in the original document.
%
\TODO{Je ne comprends pas. Tu as modifié la citation du manule Intel? Quel
  intérêt? Place tes remarques en dehors de la citation!}
%
This sentence roughly \TODO{banni roughly de ton vocabulaire!} corresponds to
our definitions of \ac{bios} Integrity and \ac{bios} Availability.
%
The \ac{smm} requires two additional hardware features: the SMRAM and the
\ac{smi}.

\paragraph{System Management RAM}
%
The SMRAM is the name given by Intel to the subset of the system memory
dedicated to the \ac{smm}.
%
The exact location and size of the SMRAM are architecture dependent.
%
To locate it, the \ac{cpu} uses a dedicated register named \texttt{SMBASE}, that
has to be configured by the \ac{bios} during the boot sequence.
%
As its name suggests, the \texttt{SMBASE} value should point to the base of the
SMRAM.
%
\TODO{Comment est identifié la fin de la plage de la SMRAM?}

At the beginning of the boot sequence, the SMRAM is left unprotected, meaning
arbitrary memory accesses targeting the SMRAM are authorized.
%
This design has been made to help \ac{bios} initialize the SMRAM content.
%
Once the \ac{smm} code ---the \ac{bios} code intended to be executed at runtime
in \ac{smm}--- has been correctly loaded into the SMRAM, and prior to giving the
\ac{cpu} control flow to the system software, the \ac{bios} has to lock the
SMRAM.
%

A locked SMRAM can only be accessed by a \ac{cpu} in \ac{smm}, and is invisible
to a \ac{cpu} not in \ac{smm}. \TODO{expliquer ce que veut dire invisible -> la
  mémoire n'est plus mappé dans la plage d'adresse et soit le processeur accède
  à une autre mémoire soit il y a une exception (je suppose)}
%
This access control mechanism is implemented by the Memory
Controller. \TODO{ref}
%
It can be configured by the \ac{bios} during the boot sequence, by setting the
\texttt{D\_LCK} bit of the \texttt{SMRAMC} configuration register.
%
A Memory Controller with the \texttt{D\_LCK} bit set will prevent a \ac{cpu} not
in \ac{smm} to tamper with \TODO{je n'aime pas trop tamper with. Access? Read?
  Write?} the SMRAM content.
%
In addition, the \texttt{D\_LCK} cannot be cleared once it has been set, except
by performing a complete reboot of the platform.
%
This leaves no opportunity to the system software to tamper with the SMRAM
content.

\paragraph{System Management Interrupt}

The \ac{smi} is a hardware interrupt which makes the \ac{cpu} ``enters''
\ac{smm}. \TODO{ref}
%
More precisely, when a \ac{cpu} receives a \ac{smi}, it saves its current state
(\emph{e.g.} its registers, current execution mode, etc.), either in the SMRAM
or, for most recent versions, in dedicated internal registers. \TODO{ref}
%
Once this preliminary step is done, the \ac{cpu} reconfigures itself;
%
in particular, it sets its program counter register to the value
$\mathtt{SMBASE} + \mathrm{0x8000}$.
%
From this point, the \ac{cpu} is in \ac{smm} and starts to execute what should
be the \ac{smm} code.
%
Once the \ac{smm} code has performed the task it has been requested for, the
\texttt{rsm} instruction can be used.
%
This instruction, which can be used only in \ac{smm}, tells the \ac{cpu} to
restore its previous state.
%
This way, the execution of the pieces of software previously halted by the
\ac{smi} can resume.
%
From the system point of view, it is like if nothing has happened. \TODO{excepté
  les effets de bord (le temps s'est écoulé, l'état du hardware a pu evoluer...}

\paragraph{Flash Memory Lock-down}
%
The content of the flash memory has to be protected from arbitrary tampering,
similarly to the SMRAM protection.
%
That is, only the \ac{smm} code should be able to overwrite the content of the
flash memory.
%
This second access control mechanism is implemented by the \ac{pch}.
%
It is configurable \emph{via} the \texttt{BIOS\_CNTL} control register.
%
Two bits of this register are of interest: the \texttt{BIOSWE} (\ac{bios} Write
Enable) bit, and the \texttt{BLE} (\ac{bios} Lock Enable) bit.

The semantics of the \texttt{BIOSWE} and \texttt{BLE} bits is as follows.
%
When the \texttt{BIOSWE} bit is clear, the \ac{pch} only authorizes read
accesses to the flash memory.
%
If the \texttt{BIOSWE} bit is set by a \ac{cpu}, the behaviour of the \ac{pch}
depends on the value of the \texttt{BLE} bit.
%
If the \texttt{BLE} bit has been set by the \ac{bios} during the boot sequence,
then the \ac{pch} triggers a \ac{smi}.
%
As a consequence, the \ac{cpu} stops its current execution and enters in
\ac{smm}.
%
This prevents the system software from tampering with the content of the Flash
Memory, even if the \ac{pch} now authorizes write accesses.
%
It is the \ac{smm} code responsibility to clear the \texttt{BIOSWE} bit before
using the \texttt{rsm} instruction.
%
On the contrary, if the \texttt{BLE} bit is not set, setting the \texttt{BIOSWE}
bit will not cause a \ac{smi}.
%
Similarly to the \texttt{D\_LCK} bit of the \texttt{SMRAMC} register, the
\texttt{BLE} bit cannot be cleared without a reboot.

The Flash Memory \TODO{parfois tu mets Flash Memory en majuscul, parfois non. Je
  pense qu'il ne faut pas de majuscule, harmonise à tout le document.} Lock-down
mechanism is often used as a communication channel between the system software
and the \ac{smm} code, in order to initiate a \ac{bios} update.
%
The system software sets the \texttt{BIOSWE} bit in order to notify the \ac{smm}
code that a \ac{bios} update is available.

\paragraph{}
%
The combination of the SMRAM, the \ac{smi} and the Flash Memory Lock-down
explains why the \ac{smm} is often introduced as the ``most privileged execution
mode'' of a x86 \ac{cpu}.
%
In a nutshell, the \ac{smm} code can do all the things the system software
does\TODO{can do?}, including tampering with memories assigned to the system
software.
%
On the contrary, the system software cannot modify neither the SMRAM content nor
the \ac{smm} code stored in the flash memory, and cannot prevent the \ac{smm}
code execution \TODO{"i.e, intercept or mask SMI " par exemple}.

\subsection{SMRAM Cache Poisoning Attack} % -------------------------------
\label{subsec:usecase:hse:smram}

Between 1986, when the \ac{smm} has first been introduced, and 2009, it was
believed that the \texttt{SMRAMC} register alone was sufficient to enforce the
Integrity (Definition~\ref{def:usecase:int}) of the SMRAM.
%
Loic Duflot \emph{et al.}\,\cite{duflot2009smram} and Rafal Wojtczuk \emph{et
  al.}\,\cite{wojtczuk2009smram} have independently shown that this belief was
misplaced when they disclosed the \emph{SMRAM Cache Poisoning Attack}.

\paragraph{Cache Memory}

Interacting with the \ac{dram} remains slow, in regard to the speed of a
\ac{cpu}.
%
To improve performance, Intel \acp{cpu} come with several (often three\TODO{J'ai
  l'impression que les proc ont maintenant tous 3 niveaux de cache et ce depuis
  pas mal de temps. Plutôt que often, tu pourrais dire depuis l'archi xxx})
levels of caches, from the smaller and quicker, to the bigger and
slower. \TODO{Tu pourrais donner un peu plus de détail en t'appuyant sur un
  schéma d'archi (L1 intégré au coeur, L2, L3, différence cache de données et
  cache d'instruction...}
%
When a \ac{cpu} successfully reads the memory at a given address, it keeps a
copy of the result in its cache.
%
Therefore, the next time it needs to read some data at this address, these data
are retrieved from the cache.
%
For cache-friendly programs, the gain in performance can be huge
\TODO{référence, données quantitative...}.
%
This gain is paid in important increase of complexity. \TODO{Il faudrait
  expliquer un peu plus en détail le fonctionnement du cache, il me semble}
%
Enforcing coherence between the different levels of cache and the \ac{dram} is
not trivial \TODO{ref}.

\begin{figure}
  \centering
  \begin{tikzpicture}
    \node [draw, circle] (EP) {};%

    \node [draw, below=of EP] (Sel) {Select a cache line};%
    \draw [-latex] (EP) -- (Sel);%

    \node [draw, diamond, below=of Sel] (CH) {};%
    \draw [-latex] (Sel) to node [right] {Cache hit?} (CH);%

    \node [right=70pt of CH] (CHbranch) {};%
    \draw (CH) to node [below] {[Yes]} (CHbranch.center);%
    \node [left=70pt of CH] (nCHbranch) {};%
    \draw [below] (CH) to node {[No]} (nCHbranch.center);

    \node [draw, diamond, below=of nCHbranch.center] (Dirty) {};%
    \draw [-latex] (nCHbranch.center) to node [left] {Is the cache line marked
      as dirty?}  (Dirty);

    \node [draw, below=of Dirty, text width=70pt, text badly centered] (WB)
    {Write the content of the cache line back to the DRAM};%
    \draw [-latex] (Dirty) to node [right] {[Yes]} (WB);%

    \node [draw, diamond, below=of CHbranch.center] (RxW) {};%
    \draw [-latex] (CHbranch.center) to node [right] {Read or write access?}
    (RxW);%

    \node [right=50pt of RxW] (R) {};%
    \draw (RxW) to node [below] {[Read]} (R.center);%
    \node [left=50pt of RxW] (W) {};%
    \draw (RxW) to node [below] {[Write]} (W.center);
  \end{tikzpicture}

  \caption{The Write-Back cache strategy}
  \label{fig:usecase:writeback}
\end{figure}

\paragraph{Attack Path}
%
Intel x86 \acp{cpu} provide five different caching strategies (uncacheable,
write combining, write-through, write-back and write-protected). \TODO{ref}
%
\TODO{Il faut expliquer ce que font ces différentes stratégies}
In particular, the write-back strategy aims to reduce the number of write
accesses to the system memory.
%
To that end, \ac{cpu} does not pass write accesses on the system memory if it
can avoid it. \TODO{C'est à dire? Soit explicite dans tes explications.}
%
The SMRAM Cache Poisoning leverages the write-back strategy of the \ac{cpu}
cache to circumvent the \texttt{D\_LCK} bit protection.
%
The attack proceeds as follows:

\begin{enumerate}
\item Attackers set the cache strategy to be used for the SMRAM addresses to
  write-back.
    \TODO{Il faut insister sur le fait qu'il est possible de modifier la stratégie de cache de la SMRAM en dehors du SMM. Il n'est pas nécessaire de disposer de privilèges particuliers. }

%
\item They trigger a \ac{smi}, using the x86 hardware architecture mechanisms at
  their disposal
  \TODO{Tu n'as jamais expliqué comment on pouvait déclencher une SMI}
%
\item The \ac{smm} code is executed in SMM, leading the cache to be filled with
  copies of that code
%
\item Attackers issue a memory write access targeting the SMRAM, and because of
  the write-back cache strategy, the \ac{cpu} updates the copies within the
  cache, but does not pass the access to the Memory Controller.
%
\item Attacker trigger another \ac{smi}, and the \ac{cpu} uses the tampered copy
  of the \ac{smm} code inside its cache.
\end{enumerate}
%
This attack is a perfect illustration of an architectural attack:
%
both the Memory Controller and the \ac{cpu} cache work as expected.
%
The former prevents authorized accesses to the SMRAM, that is a subset of the
\ac{dram}, by a \ac{cpu} not in \ac{smm};
%
the former is keeping copies of successful accesses to decrease latency due to
memory accesses.
%
However, the composition of the cache and the memory controller breaks the BIOS
Integrity property.

\paragraph{Countermeasure}
%
The solution implemented by Intel to prevent further exploitation of this
vulnerability was to modify the behaviour of the cache, when the memory accesses
target the SMRAM.
%
Because the SMRAM size and location remain specific to each architecture, this
means it requires an additional step of configurations to tell the cache where
the SMRAM is.
%
As a consequence, the complexity of the \ac{hse} mechanism implemented by the
\ac{bios} at runtime, which was already involving three different hardware
components, has increased.

\paragraph{}
%
The SMRAM Cache Poisoning attack is a textbook case of architectural attacks.
%
It is interesting to notice that six years later, Christopher Domas has
disclosed another x86 vulnerability called Sinkhole\,\cite{domas2015sinkhole},
which relies on a similar approach to trick a \ac{cpu} in \ac{smm} to execute
arbitrary instructions.
%
Both leave the content of the SMRAM in \ac{dram} intact.
%
Both leverage legitimate hardware features.

\subsection{SENTER Sandman}
\label{subsec:usecase:hse:sandman}

In 2015, Xeno Kovah \emph{et al.} have shown it was possible to leverage the
Intel TXT technology to circumvent the Flash Memory Lock-down
protection\,\cite{kovah2015senter}.

\paragraph{Intel TXT}
The Intel Trusted eXecution Technology (TXT) is a recent feature of some x86
\acp{cpu}, whose aim is to reduce the \ac{tcb} of the system software, by
removing most of the \ac{bios} from it.
%
Using a new family of instructions called \texttt{SENTER}, system software can
initiate an isolated execution environment.
%
The motivation behind TXT is to reduce the size of the architecture \ac{tcb}.
%
In a regular computing platform, the latter includes most of the hardware
components and the \ac{bios} code.
%
With TXT, the goal was to reduce it to the \ac{cpu} itself, which was acting as
a minimal loader for the system software.

\paragraph{Attack Path}
%
The \texttt{SENTER} instruction family had the undesirable side effect of
disabling \acp{smi}.
%
In the context of TXT, this might make sense, as the \ac{bios} is considerered
untrusted.
%
However, this totally contradicts the security model of the \ac{smm} code.
%
Without \ac{smi}, the \ac{bios} Availability property cannot be enforced.
%
In addition, the Flash Memory Lock-down mechanism is deprived of one of its key
hardware features.

\paragraph{Countermeasure}
%
Recent x86 \acp{cpu} do not disable \ac{smi} when using the \texttt{SENTER}
instructions.
%
This leaves the \ac{smm} code inside the TXT \ac{tcb}.
%
This is consistent with the security model of the \ac{smm} code, while the first
version of TXT was clearly misconceived with respect to the existing state of
the hardware architecture.

\subsection{Speed Racer}
\label{subsec:usecase:hse:speed}

There is at least another attack which has defeated the Flash Memory Lock-down
protection.
%
In 2015, Corey Kallenberg \emph{et al.} have shown that the scenario detailed
previously, such that setting \texttt{BIOSWE} was triggering a \ac{smi} to
suspend the execution of the system software, suffered from a race condition in
the presence of a second \ac{cpu}\,\cite{kallenberg2015racecondition}.

\paragraph{Attack Path}
%
On a typical x86 hardware architecture, all the x86 \ac{cpu} of the platform
will \emph{eventually} enter \ac{smm} when a \ac{smi} is triggered.
%
On the contrary, the \texttt{BIOSWE} is set as soon as the \texttt{BIOS\_CNTL}
register is modified.
%
If two \acp{cpu} cooperate, they can benefit from a sufficient window for action
and successfully tamper with the Flash Memory content.
%
The attack proceeds as follows:

\begin{enumerate}
\item One \ac{cpu} tries \emph{ad infinitum} to overwrite the content of the
  Flash Memory. Because the \texttt{BIOSWE} bit is initially clear, the \ac{pch}
  discards its attempts, and the Flash Memory content is correctly protected.
%
\item At the same time, another \ac{cpu} set the \texttt{BIOSWE} bit.
%
\item A \ac{smi} is triggered, but by the time it propagates to the first
  \ac{cpu}, the latter may have successfully tampered with the Flash Memory
  content.
%
\end{enumerate}

\paragraph{Countermeasure}
%
To prevent this race condition, Intel has introduced a new configuration bit to
the \texttt{BIOS\_CNTL} register: the \texttt{SMM\_BWP} (\ac{smm} \ac{bios}
Write Protection).
%
If the \texttt{SMM\_BWP} is set, the \ac{pch} discards any write access which
targets the Flash Memory \emph{unless all processors are in \ac{smm}}.

\section{Conclusion}
\label{sec:usecase:conclusion}

In this Chapter, we have detailed in depth the relevant x86 hardware mechanisms
involved in the \ac{hse} mechanism implemented by the \ac{bios} at runtime to
stay isolated from the system software.
%
In addition, we have presented three architectural attacks, to better illustrate
the threats they pose.
%
We have used the SMRAM Cache Poisoning Attack as a recurring application use
case for our contributions, because it has motivated our will to formally
specify and verify \ac{hse} mechanisms, and it is a good illustration of
architectural attacks.
