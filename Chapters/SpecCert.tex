\chapter{Formal Definition of HSE Mechanisms}
\label{chapter:speccert}

\endquote{``\emph{The purpose of abstraction is not to be vague, but to create a
    new semantic level in which one can be absolutely precise}''

  \hfill\footnotesize --- Edsger Dijkstra}

\vspace{1cm}\noindent
%
Our first contribution is a formal definition of \ac{hse} mechanisms, which
takes into account that
%
\begin{inparaenum}[(1)]
\item interfaces exposed by commodity hardware architectures to software
  components are not safe,
\item trusted and untrusted software components use the same interface and
  manipulate the same stateful environment, and
\item several \ac{hse} mechanisms are often implemented simultaneously, to
  enforce several security policies.
\end{inparaenum}
%
As a consequences of these characteristics, we have broken down our formal
definition into three components: hardware models, \ac{hse} mechanisms and
security policies.
%
First, we model the hardware architecture as a \ac{lts} whose sequences of
transitions, also called traces, characterize every possible software components
execution (Section~\ref{sec:speccert:hardware}).
%
This model acts as a foundation for the two other components: \ac{hse}
mechanisms (Section~\ref{sec:speccert:hse}) and security policies
(Section~\ref{sec:speccert:security}) are expressed against a hardware model.

For the reader familiar with Coq, we present an implementation of our formalism
in Appendix~\ref{appendix:speccert}.
%
This development comprises machine-checked proofs of the theoretical results
that we present throughout this Chapter, and we have used these proofs to phrase
the proof sketches which follow.

\section{Hardware Model}
\label{sec:speccert:hardware}

In line with the works we have described in Section~\ref{sec:related:review}, we
model a hardware architecture which executes several software components as a
\ac{lts} with controllable and observable transitions.
%
We also introduce the notion of traces of a hardware model.
%
This allows us to model the different classes of security policies discussed
previously (\ref{subsec:state:secu}).

\begin{definition}[Hardware Model]
  \label{def:speccert:model}
  A hardware model $\Sigma$ is a tuple
  $\langle H, L_S, L_H, \rightarrow \rangle$, where
  %
  \begin{itemize}
  \item $H$ is the set of configurations of the hardware architecture
  %
  \item $L_S$ is the set of labels to identify software transitions
  %
  \item $L_H$ is the set of labels to identify hardware transitions
  %
  \item $\rightarrow$ is the transition relation of the system
  \end{itemize}

  The transition relation $\rightarrow$ is a predicate on
  $H \times (L_S~\uplus~L_H) \times H$.
  %
  Afterwards, we simply write $L$ for $L_S \uplus L_H$.
  %
  A transition labelled with $l$ from $h$ to $h'$ is denoted by
  %
  \[
    \transition{h}{l}{h'}
  \]
  %
  and we write $\mathcal{T}(\Sigma)$ for the set of triples which satisfy the
  transition relation, that is
  \[
    \mathcal{T}(\Sigma) \triangleq \{\ (h, l, h')\ |\ \transition{h}{l}{h'}\ \}
  \]
\end{definition}

\paragraph{States}
%
The state of a hardware architecture models the configuration of its devices at
a given time.
%
This configuration may change over time with respect to the hardware
specifications and comprises any relevant data such as register values, inner
memory contents, etc.
%
These state transformations occur during the system's transitions.

\paragraph{Transitions}
%
We distinguish between two classes of transitions: the software transitions
which are direct and foreseeable side effects of the execution of a \ac{cpu}
instruction and the hardware transitions which are not.
%
Differentiating between transitions which are controllable and transitions which
are only observable is not a novel approach.
%
David Basin \emph{et al.} have notably emphasized the importance of transitions
which are only observable in terms of security\,\cite{basin2013enforceable}.

The execution of an instruction can be broken down into sequences of these
transitions.
%
For instance, to execute the x86 instruction\,\footnote{Written in AT\&T syntax
  here.} \texttt{mov (\%ecx),\%eax}, a x86 \ac{cpu}:
%
\begin{itemize}
\item reads the content of the register \texttt{ecx}
%
\item interprets this value as an address and reads the main memory at this
  address
%
\item writes this content into the register \text{eax}
%
\item updates the register \texttt{eip} with the address of the next instruction
  to execute
\end{itemize}

This translates into four software transitions if the content of \texttt{ecx} is
a valid address.
%
On the contrary, the \ac{cpu} typically raises an interrupt.
%
In this scenario, only one software transition occurs, when the \ac{cpu} reads
the content of \texttt{ecx}.
%
The following transition models the interrupt, and is labelled as ``hardware''.
%
Hardware transitions are not limited to interrupts raised by a \ac{cpu}.
%
They make be provoked by other hardware components as well.
%
For instance, \ac{dma} transactions by a network card qualify as hardware
transitions.
%
This allows for taking into account active peripherals whose trustworthiness is
not guaranteed.
%
Finally, and as suggested by David Bosin \emph{et al.}, hardware transitions can
be leveraged to model a clock, and therefore reasoning about time.

\paragraph{Trace}
%
Finally, we formally introduce the definition of traces of a hardware model.
%
A trace is a non-empty sequence of transitions of~$\Sigma$, such that for two
consecutive transitions, the resulting state of the first is the initial state
of the next.

\begin{definition}[Traces]
  \label{def:speccert:trace}
  We write $\pathesLTS{Ez}$ for the set of traces of a hardware model $\Sigma$,
  and we consider the following functions:
  %
  \begin{itemize}
  \item $\func{init} : \pathesLTS{Ez} \rightarrow S$ maps a trace with its
    initial state
  \item
    $\func{trans} : \pathesLTS{Ez} \rightarrow \powerset(\mathcal{T}(\Sigma))$
    maps a trace with the set of transitions
  \end{itemize}
\end{definition}

\section{HSE Mechanisms}
\label{sec:speccert:hse}

The previous definitions allow us to propose a formal definition for \ac{hse}
mechanisms, notably based on requirements on states and requirements on
transitions.
%
Then, we detail two so-called \ac{hse} Laws, whose main purpose is to enforce
requirements consistency: requirements on transitions should preserve
requirements on states.
%
From a \ac{hse} mechanism definition, we derive a set of compliant traces which
we use to determine if the \ac{hse} mechanism is correct with respect to a
targeted security policy.

\paragraph{Execution Context}
%
One of the specificities of \ac{hse} mechanisms is the sharing of the \ac{cpu}
interface between the trusted components and the rest of the software stack,
considered as the adversary.
%
To reason about HSE mechanisms, it is necessary to be able to determine which
software component is executed at a given time.
%
In practice, a subset of states of the hardware architecture is dedicated to
each software component.
%
For instance, the x86 \ac{cpu} has a feature called protection rings where each
ring can be seen as an execution mode dedicated to a software component.
%
Hence, the ring 0 is dedicated to the operating system whereas the userland
applications are executed when the \ac{cpu} is in ring 3, with a particular page
table setup.

\begin{definition}[Hardware-Software Mapping]
  \label{def:hardsoftmap}
  A hardware-software mapping $\func{con\-text} : H \rightarrow S$ is a function
  which takes a hardware state and returns the software component currently
  executed.
\end{definition}

Dealing with multi-core architectures would require additional efforts and
notations.
%
One possible solution could be to define an identifier per core and to use this
identifier in addition to the current hardware state to deduce the software
component currently executed by the corresponding core.
%
However, this is out of the scope of this Chapter.

\paragraph{Definition}
%
A \ac{hse} mechanism is a set of requirements on states to characterize safe
hardware configurations and a set of requirements on software transitions to
preserve the state requirements through software execution.
%
The software components which implement a \ac{hse} mechanism form its the
\ac{tcb}.

\begin{definition}[HSE Mechanism]
  \label{def:speccert:hse}
  A \ac{hse} mechanism $\Delta$ is a tuple
  $\langle S, T, \func{context}, \func{inv}, \func{behaviour} \rangle$, such
  that
  %
  \begin{itemize}
  \item $S$ is the set of software components executed by the hardware
    architecture
  %
  \item $T \subseteq S$ is the set of trusted software components which
    implement the \ac{hse} mechanism and form its \ac{tcb}
  %
  \item $\func{context}$ is a hardware-software mapping to determine when the
    \ac{tcb} is executed
  %
  \item $\func{inv}$ is a predicate on $H$ to distinguish between safe hardware
    configurations and potentially vulnerable ones
  %
  \item $\func{behaviour}$ is a predicate on $H \times L_S$ to distinguish
    between safe software transitions and potentially harmful ones
  \end{itemize}
\end{definition}

We illustrate this definition with the Flash Memory Lock-down mechanism
described in Section~\ref{subsec:usecase:hse:smm}.
%
As a reminder, the Flash Memory Lock-down mechanism enforces the integrity of
the \ac{bios} code within the Flash Memory, as follows:
%
\begin{enumerate}
\item By default, the Flash Memory is locked and its content cannot be modified
%
\item When a software component (\emph{e.g.} system software) tries to unlock
  the Flash Memory, the \ac{pch} triggers a \ac{smi}
%
\item This forces the \ac{cpu} to enter \ac{smm}
%
\item The \ac{smm} code is expected to lock the Flash Memory again, before
  resuming the execution of the system software
\end{enumerate}

\begin{example}[Flash Memory Lock-down Mechanism]
  \label{example:speccert:flashdef}
  In this example, the trusted software component ($T$) is the \ac{bios}.
  %
  The \ac{cpu} executes the \ac{bios} when it is in \ac{smm} (\func{context}).
  %
  A safe hardware state ($\func{inv}$) is either a state wherein the \ac{bios}
  is executed, or a state wherein the Flash Memory is locked.
  %
  It is expected that the \ac{bios} locks the Flash Memory before using the
  \texttt{rsm} instruction ($\func{behaviour}$).
\end{example}

\paragraph{HSE Laws}
%
For a \ac{hse} mechanism to be correctly defined, it must obey a few axioms,
together called the \ac{hse} Laws.
%
The first law says that the state requirements specified by $\func{inv}$ are
preserved through transitions as long as the \ac{tcb} avoids software
transformations which do not satisfy $\func{behaviour}$.
%
The second law says that the $\func{behaviour}$ predicate specifies restrictions
of software transitions for the \ac{tcb} only.
%
The software components which are not part of the \ac{tcb} are considered
untrusted and we make no assumption on their behaviour.

\begin{definition}[\ac{hse} Laws]
  \label{def:laws}
  A \ac{hse} mechanism $\Delta$ has to satisfy the following properties:
  %
  \begin{enumerate}
  \item \func{behaviour} preserves \func{inv}:
    $\forall (h, l, h') \in \mathcal{T}(\Sigma)$,
    \[
      \begin{array}{l} \func{inv}(h) \Rightarrow (l \in L_S \Rightarrow
        \func{behaviour}(h,l)) \Rightarrow \func{inv}(h')
      \end{array}
    \]
  %
  \item $\func{behaviour}$ only restricts the \ac{tcb}:
    $\forall (h, l, h') \in \mathcal{T}(\Sigma)$, $\forall x \not\in T$,
    %
    \[
      l \in L_S \Rightarrow \func{context}(h) = x \Rightarrow
      \func{behaviour}(h, l)
    \]
  \end{enumerate}
\end{definition}

\begin{example}[Flash Memory Lock-down Inconsistency]
  We can convince ourselves that the informal definition description we have
  discussed in the Example~\ref{example:speccert:flashdef} obeys the second HSE
  Law, but \emph{does not} obey the first one.
  %
  \paragraph{\func{behaviour} only restricts the \ac{tcb}}
  %
  The only software restriction we formulate concerns the use of the
  \texttt{rsm} instruction.
  %
  In particular, we do not forbid the attacker to unlock the Flash Memory.

  \paragraph{\func{behaviour} does not preserve \func{inv}}
  %
  A \ac{cpu} is either in \ac{smm} or not in \ac{smm}.
  %
  If it is in \ac{smm}, the only way to leave \ac{smm} is to execute the
  \texttt{rsm} instruction, which qualifies as a software transition.
  %
  If the \ac{cpu} is in \ac{smm}, the \func{behaviour} will hold true for this
  software transition only if the Flash Memory is already locked.
  %
  As a consequence, it is not possible to leave \ac{smm} with the Flash Memory
  unlocked.
  %
  However, if the \ac{cpu} is not in \ac{smm}, and tries to open the Flash
  Memory, two things happen sequentially.
  %
  First, the Flash Memory is effectively opened (software transition)
  %
  Then, the \ac{pch} triggers a \ac{smi}, which eventually forces the \ac{cpu}
  to enter \ac{smm} (hardware event).
  %
  That is, the protection consists in two transitions, and the \func{inv}
  predicate is not satisfied in between.

  \paragraph{}
  %
  It is because the Flash Memory Lock-down as described here does not satisfy
  the first law that the race condition uncovered by Corey Kallenberg \emph{et
    al.}\,\cite{kallenberg2015racecondition} is possible.
  %
  On the contrary, the \texttt{SMM\_BWP} register semantics allows for defining
  a HSE mechanisms which satisfies both laws, because the register ties together
  the state of the \acp{cpu} and the Flash Memory state.
\end{example}

\paragraph{Trace Compliance}
%
We say a trace complies with a \ac{hse} mechanism definition when its initial
state satisfies the state requirements (\func{inv}) and each software
transitions of the trace satisfies the software requirements (\func{behaviour}).
%
\begin{definition}[Compliant Traces]
  We write $\mathcal{C}(\Delta)$ for the set of the traces which comply with
  $\Delta$.
  %
  Given $\rho \in \pathesLTS{Ez}$, then $\rho \in \mathcal{C}(\Delta)$ iff
  \[
    \func{inv}(\func{init}(\rho)) \wedge \forall (h,l,h') \in
    \func{trans}(\rho)\text{, }l \in L_S \Rightarrow \func{behaviour}(h, l)
  \]
  % \[
  %   \begin{array}{lcl}
  %     \rho \in \mathcal{C}(\Delta)
  %     & \triangleq
  %     & \func{inv}(\func{init}(\rho))\ \wedge \\
  %     &
  %     & \forall (h,l,h') \in \func{trans}(\rho), l \in L_S \Rightarrow
  %      %     \func{behaviour}(h, l)
  %   \end{array}
  % \]
\end{definition}

\begin{example}[Memory Flash Lock-down Compliance]
  We consider the execution to start at the end of the boot sequence, when the
  \ac{bios} gives the control flow to the system software component it has
  selected.
  %
  At the time, it is expected that the \texttt{BIOS\_CNTL} register of the
  \ac{pch} has been correctly set; in particular, the \texttt{SMM\_BWP} bit
  should be set, to avoid the Speed Racer
  attack\,\cite{kallenberg2015racecondition}.
  %
  If the \ac{bios} fails to do so, then the related trace is not compliant.
\end{example}

\begin{lemma}[HSE Invariant Enforcement]
  \label{lemma:speccert:hseinv}
  We prove that \func{inv} is satisfied throughout compliant traces, that is
  %
  \[
    \forall \rho \in \mathcal{C}(\Delta), \forall (h, l, h') \in
    \func{trans}(\rho), \func{inv}(h) \wedge \func{inv}(h')
  \]

  \begin{proof}
    By definition of $\mathcal{C}(\Delta)$, we know the initial state of the
    trace satisfies \func{inv}, and thanks to the first HSE Law, we can conclude
    the state after the first transition also satisfies \func{inv}.
    %
    We generalize to the trace by induction.
  \end{proof}
\end{lemma}

\section{Security Enforcement}
\label{sec:speccert:security}

\paragraph{Security Policies}
%
We now explain how we model different security policies discussed in
Section~\ref{subsec:state:secu}.
%
We start from the most general definition possible, then discuss how more
specific security properties can be modelled as a specialization of that general
definition.

\begin{definition}[Security Policy]
  \label{def:speccert:secpol}
  %
  A security policy is a predicate on sets of traces
  $\powerset(\pathesLTS{Ez})$.
\end{definition}

Hyperproperties\,\cite{clarkson2010hyperproperties} such as noninterference
require a definition that general.
%
On the contrary, security properties\,\cite{schneider2000enforceable}, that is
liveness properties (something ``good'' happens eventually) and safety
properties (nothing ``bad'' happens) can be modelled more straightforwardly.

\begin{definition}[Security Property]
  A security property is a predicate on traces $\pathesLTS{Ez}$.

  % We write $\partial P$ for the security policy derived from the security
  % property $P$, such that
  % %
  % \[
  %   \partial P(R) \triangleq \forall \rho \in R, P(\rho)
  % \]
\end{definition}

Safety properties focus on avoiding ``bad'' transitions, and therefore their
definition can be even simpler, if the hardware model allows for distinguishing
between safe and unsafe transitions solely based on the current state, and not
the traces past.

\begin{definition}[Safety Property]
  \label{def:speccert:safetyprop}
  A safety property is a predicate on transitions $\mathcal{T}(\Sigma)$.

  % We write $\partial^2 P$ for the security policy derived from the safety
  % property $P$.
  %  %
  % A set of trace $R$ satisfies $\partial^2 P$ if and only if every transition
  % of every trace $\rho \in R$ satisfies $P$, that is
  %  %
  % \[
  %   \partial^2 P(R) \triangleq \forall \rho \in R, \forall (h, ev, h') \in
  %   \func{trans}(\rho), P(h, ev, h')
  % \]
\end{definition}

\paragraph{HSE Mechanism Correctness}
%
The main purpose of the \ac{hse} Laws is to verify it is consistent.
%
However, they say nothing about the security policy the \ac{hse} mechanism
supposedly enforce.
%
Eventually, we aim to prove that a HSE mechanism is sound ---it succeeds in
enforcing a security policy--- under the assumption that software components of
the \ac{tcb} always behave according to the specification given in the HSE
mechanism definition.

\begin{definition}[Correct HSE Mechanism]
  A \ac{hse} mechanism $\Delta$ is correct with respect to a security policy $P$
  (denoted by $\Delta \models P$) if and only if the set of compliant traces of
  $\Delta$ satisfies $P$, that is
  %
  \[
    \Delta \models P \triangleq
    \begin{cases}
      P(\mathcal{C}(\Delta)) & \text{if } P \text{ is a predicate on sets of
        traces} \\
      \forall \rho \in \mathcal{C}(\Delta), P(\rho) & \text{if } P \text{ is a
        predicate on traces} \\
      \forall \rho \in \mathcal{C}(\Delta), \forall \mathit{tr} \in
      \func{trans}(\rho), & \text{if }P \text{ is a predicate on
        transitions} \\
      \qquad P(\mathit{tr}) &
    \end{cases}
  \]
\end{definition}

It is possible to define a \ac{hse} mechanism which satisfies the \ac{hse} Laws,
yet is not correct with respect to its targeted security policy.
%
It was the case, for instance, for the protection of the SMRAM by the sole
\texttt{SMRAMC} register.
%
The state requirement focused on the SMRAM content, which is correctly protected
against unprivileged modifications by the memory controller.
%
However, this property alone is not strong enough to enforce the BIOS Integrity
security property (Definition~\ref{def:usecase:biosint}), as evidenced by the
SMRAM Cache Poisoning attack.

\paragraph{Reasoning about Correctness}
%
Bla

\begin{theorem}[Correct HSE Mechanism for Safety Properties]
  \label{theorem:speccert:correcthse}
  Given $P$ a safety property defined as a predicate on $\mathcal{T}(\Sigma)$,
  then
  %
  \[
    \begin{array}{l}
      \forall (h, l, h') \in \mathcal{T}(\Sigma), \\
      \qquad \func{inv}(h) \\
      \qquad \Rightarrow (l \in L_{S} \Rightarrow \func{behaviour}(h, l))\\
      \qquad \Rightarrow P(h, l, h')
    \end{array}
  \]
  %
  is a sufficient condition for
  %
  \[
    \Delta \models P
  \]

  \begin{proof}
    With Lemma~\ref{lemma:speccert:hseinv}, we know that every initial state of
    a transition of $\rho$ satisfies $\func{inv}$.
    %
    By definition of Compliant Runs, we know that every transition satisfies the
    safety property $P$.
    %
    We conclude with the Definition of $P$.
  \end{proof}
\end{theorem}

\section{Conclusion}

In this Chapter, we present our formal definition of \ac{hse} mechanisms, in the
form of requirements over a hardware model.
%
This approach allows for reuse the same model to define and verify several
\ac{hse} mechanisms.
%
This makes sense, especially because these multiple mechanisms will be
implemented concurrently, and may interfere with each other.
%
Throughout this Chapter, we have tried to illustrate our definitions with
real-world examples.
%
All being told, our approach can be summarized to a three-step methodology for
specifying and verifying \ac{hse} mechanisms against hardware architecture
models, that is
%
\begin{inparaenum}[(1)]
\item specifying the software requirements that must be satisfied by the trusted
  software components which implement the \ac{hse} mechanism,
%
\item specifying the targeted security policy the \ac{hse} mechanism supposedly
  enforces, and
%
\item verifying that the \ac{hse} mechanism is correct with respect to the
  targeted security policy.
\end{inparaenum}
