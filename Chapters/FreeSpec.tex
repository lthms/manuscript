\chapter{FreeSpec}
\label{chapter:freespec}

A typical computing platform is made of dozens of hardware components, and some
of them execute complex software stacks.
%
In this context, building a secure computing system with respect to a given
security policy remains challenging, because attackers will leverage any
vulnerability they can find.
%
Both local component flaws and components composition inconsistencies,
that is, a mismatch between requirements assumed by some client
components and the actual guarantees provided by others, can be
used by attackers.

The latter scenario may lead to a situation where every component
seems to be working as expected, but their composition creates an
attack path.
%
We name this class of security vulnerabilities ``architectural
attacks''\,\cite{letan2016speccert} afterwards.
%
Over the past decade, many critical vulnerabilities affecting computing systems,
in particular those relying on the x86 architecture, have raised awareness about
the threat posed by architectural attacks.
%
Figure \ref{fig:freespec:computing-platform} summarizes several significant
attacks\,\cite{wojtczuk2009smram,duflot2009smram,domas2015sinkhole,kallenberg2015racecondition,kovah2015senter,stewin2012dma}
inside an idealized view of an x86 computing platform.
%
In all cases, the vulnerability was rooted in an inconsistency in the components
composition.

\begin{figure}
  \centering \includestandalone[width=.8\textwidth]{Figures/computing-system}
  \caption{Idealized x86 Computing Platform}
  \label{fig:freespec:computing-platform}
\end{figure}

The isolation of the System Management Mode (SMM) code by the hardware
architecture is a good example to illustrate the threat posed by architectural
attacks.
%
The SMM is the most privileged execution mode of x86 CPU.
%
Its purpose is to provide an ``isolated processor environment that operates
transparently to the operating system''\,\cite{intel2014manual} to execute a
so-called SMM code provided by the computer manufacturer.
%
Since the SMM code is the most privileged software component executed by an x86
CPU, it is a desirable target for an attacker.
%
The SMM code is stored in a dedicated memory region within the system memory,
called the SMRAM; it is expected that only a CPU in SMM can access the SMRAM.
%
In particular, the Memory Controller Hub (MCH)\,\cite{intel2009mch} provides a
security mechanism to that end.
%
In 2009, Duflot \emph{et al.}\,\cite{duflot2009smram} and Wojtczuk \emph{et
al.}\,\cite{wojtczuk2009smram} have independently shown that the cache could be
used to circumvent this protection.
%
The countermeasure required to add a new security mechanism to the CPU, meaning
only computers produced after 2009 are protected against this particular
vulnerability.

For many years, industrial manufacturers\,\cite{reid2017arm,leslie2015sgx} and
researchers\,\cite{chong2016report,choi2017kami} have aimed to formally specify
and verify hardware architectures.
%
However, verifying properties of existing computing platforms poses significant
challenges, because they tend to be both complex and under-specified; we are not
aware of any model of existing and broadly used computing system that is
comprehensive in terms of its hardware and software components.
%
Unfortunately, such a model is a prerequisite to verify a computing platform in
terms of architectural attacks.
%
The Coq proof assistant\,\cite{coq} has proven to be effective to model specific
hardware
components\,\cite{braibant2011coquet,morrisett2012rocksalt,choi2017kami,jomaa2016mmu}.
%
It provides a rich specification language, tools to write machine-checked proofs
and a mechanism to derive executable programs to experimentally validate models.
%
The scale of the task dictates several requirements regarding the formalism to
adopt in this particular case.
%
It must allow for considering independently each component of our system, before
composing them to conclude about the properties of the system as a whole.

This objective is reminiscent of the programming language problematic to model
and verify large programs with side effects.
%
Reasoning about side effects in purely functional languages such as {\sc
  Gallina}, the Coq specification language, is difficult, firstly because they
  imply to somehow take into account an outer \emph{stateful} environment and
  secondly, because the composition of stateful computations is not well-handled
  by traditional (monadic) approaches.
%
Algebraic effects and handlers\,\cite{bauer2015effects} are a generic approach
to overcome this double challenge.
%
They allow to model large classes of effects (e.g., exception, state,
non-determinism) and to compose effects within purely functional programs, while
deferring the realizations of these effects to dedicated handlers.

In this paper, we aim to show how a variant of algebraic effects based on Free
monads can be used to reason about large systems, by modelling their components
as effect handlers.
%
Our contribution is threefold:
\begin{itemize}
\item We propose an approach which leverages the key concepts of
algebraic effects and handlers to model and to verify each component of a computing
system independently, while providing the necessary abstractions to compose
these components in order to verify the properties of the resulting system.
\item We have implemented FreeSpec\,\footnote{FreeSpec has been released as a
free software, under the terms of the GPLv3.
\url{https://github.com/ANSSI-FR/FreeSpec}}, a framework for the Coq proof
assistant to \emph{modularly} verify programs with effects and
effects handlers with our approach.
\item We have modelled and verified a simplified subset of an x86 computing
system with FreeSpec in order to illustrate how our formalism can be leveraged
to tackle our initial objective, that is modelling and verifying computing
platforms.
\end{itemize}

The rest of the paper proceeds as follows.
%
We describe how we model components in terms of programs with effects and effect
handlers (Section~\ref{sec:freespec:specifying}) and we introduce so-called abstract
specifications to verify their respective properties
(Section~\ref{sec:freespec:verifying}).
%
To illustrate our definitions, we use a running example in the form of the
specification and verification of a simplified MCH.
%
Then, we discuss how the different levels of composition of FreeSpec can be
leveraged to scale the modelling and verification work for larger systems
(Section~\ref{sec:freespec:scale}).

\section{Modelling Programs with Effects}
% ==============================================================================
\label{sec:freespec:specifying}

The first objective of FreeSpec is to incrementally model a complex system,
one component at a time.
%
To do so, we use the key concepts of algebraic effects and effect handlers,
implemented with a variant of the Free monad called the Program monad as defined
in the \texttt{operational} package of Haskell\,\cite{operational}.

This section and the one afterwards proceed through a running example: a
minimalist Memory Controller Hub (MCH) of the x86 hardware architecture.
%
The MCH acts as a dispatcher for the CPU memory accesses; in our case, to the
VGA controller or the DRAM controller.
%
The MCH takes part in the isolation of the SMRAM, that is the special-purpose
memory region inside the system memory which contains the SMM code.
%
If correctly configured, the MCH will reroute any memory access which targets
the SMRAM to the VGA controlled, if this access is done by a CPU in another
execution mode than SMM.

%pictured in the Figure~\ref{fig:mch-running-example}.
%\begin{figure}
%  \centering \includestandalone[width=.5\textwidth]{running-example}
%
%  \caption{Idealised Memory Controller Hub}
%  \label{fig:mch-running-example}
%\end{figure}

\subsection{Interface of Effects}
% ------------------------------------------------------------------------------

Within a computing system, interconnected components communicate through
interfaces.
%
A component which exhibits an interface receives computational requests from
other components; it handles these requests by computing their results and
sending the latter back to the client component.
%
In FreeSpec, a computational request is modelled with an effect, that is a
symbolic value which describes the request and its potential result.

Thereafter, we often define sets of values, and interfaces in particular, in
terms of functions to construct these values.
%
These functions are called ``constructors''\,\footnote{In this article,
functions are written in bold. In addition, constructors begin with a capital
letter.}, and they have mutually exclusive images, i.e. it is not possible to
construct the same value with two different constructors.
%
For $\I$ an interface, we denote by $\Interface{\I}{\mathcal{A}}
\subseteq \I$ the subset of effects whose results belong to a set~$\mathcal{A}$.

\begin{example}[MCH Interfaces]
  The VGA and the DRAM controllers exhibit a similar interface which allows for
  reading and writing into a memory region.
  %
  Their interfaces are denoted by $\I_{\mathrm{VGA}}$ and $\I_{\mathrm{DRAM}}$
  respectively.
  %
  Let $\mathpzc{Loc}$ be the set of memory locations and $\mathpzc{Val}$ the
  set of values stored inside the memory region.
  %
  We use the value~$()$ to model effects without results (similarly to
  the \texttt{void} keyword in an imperative language).
  %
  We define $\I_{\mathrm{DRAM}}$ (respectively $\I_{\mathrm{VGA}}$) with two constructors:
  \begin{itemize}
  \item
    $\func{Read}_{\mathrm{DRAM}} : \mathpzc{Loc} \rightarrow
    \Interface{\I_{\mathrm{DRAM}}}{\mathpzc{Val}}$
  \item
    $\func{Write}_{\mathrm{DRAM}} : \mathpzc{Loc} \rightarrow \mathpzc{Val}
    \rightarrow \Interface{\I_{\mathrm{DRAM}}}{\{()\}}$
  \end{itemize}

  Then, $\I_{\mathrm{DRAM}} =
  \Interface{\I_{\mathrm{DRAM}}}{\{()\}}\,\cup\,\Interface{\I_{\mathrm{DRAM}}}{\mathpzc{Val}}$,
  and
  $\func{Read}_{\mathrm{DRAM}}(l) \in
  \Interface{\I_{\mathrm{DRAM}}}{\mathpzc{Val}}$ is an effect that describes a
  memory access to read the value~$v \in \mathpzc{Val}$ stored at the
  location~$l \in \mathpzc{Loc}$.

  The MCH interface is similar, but it distinguishes between privileged and
  unprivileged accesses.
  %
  It also provides one effect to lock the SMRAM protection mechanism, i.e. it
  enables the SMRAM isolation until the next hardware reset.
  %
  We define the set $\mathpzc{Priv}~\triangleq~\{\,\val{smm},
  \val{unprivileged}\,\}$ to distinguish between privileged memory accesses
  made by a CPU in SMM and unprivileged accesses made the rest of the time.
  %
  The MCH interface, denoted by $\I_{\mathrm{MCH}}$, is defined with three constructors:
  \begin{itemize}
  \item
    $\func{Read}_{\mathrm{MCH}} : \mathpzc{Loc} \rightarrow \mathpzc{Priv} \rightarrow
    \Interface{\I_{\mathrm{MCH}}}{\mathpzc{Val}}$
  \item
    $\func{Write}_{\mathrm{MCH}} : \mathpzc{Loc} \rightarrow \mathpzc{Val} \rightarrow
    \mathpzc{Priv} \rightarrow \Interface{\I_{\mathrm{MCH}}}{\{()\}}$
  \item $\func{Lock} : \Interface{\I_{\mathrm{MCH}}}{\{()\}}$
  \end{itemize}
\end{example}

\subsection{Operational Semantics for Effects}
% -----------------------------------------------------------------------------

An effect corresponds to a computational request made to an implementation of a
given interface.
%
To compute the result of the computational request, we define its
\emph{operational semantics}.
%
Ultimately, we will model a component as an operational semantics for all the
effects of its interface.
%
Since operational semantics are defined using a purely functional language, they
always compute the same result for a given effect, which is inconsistent with
the stateful aspect of hardware components.
%
Thus, an operational semantics produces not only a result, but also a new
operational semantics, which encapsulates the new state of the component.

\begin{definition}[Operational Semantics]
  We write $\Sigma_{\I}$ for the set of operational semantics for a
  given interface $\I$, defined co-inductively as
  %
  \[
    \Sigma_{\I} \triangleq \{\,\sigma\,|\,\sigma : \forall \mathcal{A},
    \Interface{\I}{\mathcal{A}} \rightarrow \mathcal{A} \times \Sigma_{\I} \,\}.
  \]
  %
  An operational semantics~$\sigma \in \Sigma_{\I}$ is a function which, given
  any effect of $\I$, produces both a result which belongs to the expected
  set and a new operational semantics to use afterwards.
\end{definition}

A component may use more than one interface.
%
For instance, the MCH of our running example can access the system memory and
the memory shared by the VGA controller.
%
But an operational semantics is defined for only one interface.
%
In FreeSpec, we solve this issue by composing interfaces together to create new
ones.

\begin{definition}[Interfaces Composition]
  Let $\I$ and $\J$ be two interfaces. $\oplus$~is the interface
  composition operator, defined with two constructors:
  \begin{itemize}
  \item $\func{InL} : \forall \mathcal{A}, \Interface{\I}{\mathcal{A}}
  \rightarrow \Interface{(\I \oplus \J)}{\mathcal{A}}$
  \item $\func{InR} : \forall \mathcal{A}, \Interface{\J}{\mathcal{A}}
  \rightarrow \Interface{(\I \oplus \J)}{\mathcal{A}}$
  \end{itemize}
\end{definition}

The resulting interface $\I \oplus \J$ contains the effects of both $\I$ and
$\J$, wrapped into either $\func{InL}$ or $\func{InR}$ constructors, defined to
preserve the effects results sets.
%
%Notice that this usage of a tagged union allows for composing the
%same interface twice, so a component can use two components which exhibit the
%same interface.

\begin{example}[VGA and DRAM Composition]
We consider $\I_{\mathrm{DRAM}} \oplus \I_{\mathrm{VGA}}$. Then,
$\func{InL}(\func{Read}_{\mathrm{DRAM}}(l)) \in \Interface{(\I_{\mathrm{DRAM}}
\oplus \I_{\mathrm{VGA}})}{\mathpzc{Val}}$ is an effect that describes a
read access targeting the DRAM controller, whereas
$\func{InR}(\func{Write}_{\mathrm{VGA}}(l, c)) \in \Interface{(\I_{\mathrm{DRAM}}
\oplus \I_{\mathrm{VGA}})}{\{()\}}$ is an effect that describes a
write access targeting the VGA controller.
\end{example}

Using $\oplus$, we can compose several interfaces together.
%
We then need another composition operator, this time for operational semantics.
%
We compose operational semantics together to construct a new operational
semantics for the composed interface.

\begin{definition}[Operational Semantics Composition] \label{def:freespec:semantics-composition}
  Let $\I$ and $\J$ be two interfaces,
  $\sigma_i \in \Sigma_{\I}$ and $\sigma_j \in \Sigma_{\J}$ be two
  operational semantics dedicated to these interfaces.
  %
  In this article, we use the $\lambda$-calculus abstraction notation for
  functions.
  %
  $\otimes$~is the composition operator for operational semantics, defined as
  \[ \sigma_i \otimes \sigma_j \triangleq \lambda e. \left \{
      \begin{array}{lcl}
        (x, \sigma_i' \otimes \sigma_j) & \text{when} & e =
                                                         \func{InL}(e_i)
                                                         \text{ and }
                                                         \sigma_i(e_i)
                                                         = (x,
                                                         \sigma_i') \\
        (x, \sigma_i \otimes \sigma_j') & \text{when} & e =
                                                         \func{InR}(e_j)
                                                         \text{ and }
                                                         \sigma_j(e_j)
                                                         = (x, \sigma_j')
      \end{array}
    \right.
  \]
\end{definition}

The definition of $\otimes$ has an important impact over what we can specify in
FreeSpec.
%
%When $\sigma_i \otimes \sigma_j$ handles an effect of $\I$, only $\sigma_i$
%``changes.''
%
Handling an effect of $\I$ (respectively $\J$) does not interfere with
$\sigma_j$ (respectively $\sigma_i$).
%
As a consequence, \emph{we cannot specify as-is a graph of components which
contains a cycle or a diamond}.
%
This is the main limitation of FreeSpec, but its incidence is abated because
computing platforms are often designed as a hierarchical succession of layers.

\subsection{The Program Monad}
% -----------------------------------------------------------------------------

Modelling programs with side effects in purely functional languages such as {\sc
Gallina} (the Coq specification language) or Haskell is usually achieved thanks
to monads\,\cite{hoareetal2001monad}.
%
FreeSpec leverages a variant of the Free monad called the Program
monad\,\cite{operational} to model programs with effects. Operational semantics
play the role of \texttt{operational}\,\cite{operational} interpreters.
%
We write $P_{\I}(\mathcal{A})$ for the set of programs with effects which
belongs to $\I$, modelled thanks to the Program monad, and whose result belongs
to a set $\mathcal{A}$.

\begin{definition}[Program Monad]
  $P_{\I}(\mathcal{A})$ is defined with three constructors:
  \begin{itemize}
  \item $\func{Pure} : \mathcal{A} \rightarrow P_{\I}(\mathcal{A})$
  \item
    $\func{Bind} : \forall \mathcal{B}, P_{\I}(\mathcal{B}) \rightarrow
    (\mathcal{B} \rightarrow P_{\I}(\mathcal{A})) \rightarrow
    P_{\I}(\mathcal{A})$
  \item
    $\func{Request} : \Interface{\I}{\mathcal{A}} \rightarrow
    P_{\I}(\mathcal{A})$
  \end{itemize}
\end{definition}
%
These constructors allow for the construction of values which
act similarly to abstract syntax trees to model programs with effects.
%
On the one hand, $\func{Pure}$ and $\func{Request}$ are comparable to the
leaves of a syntax tree and model atomic computations; $\func{Pure}$ models
local computations, whereas $\func{Request}$ models deferring a computational
request to a handler and waiting for its result.
%
On the other hand, $\func{Bind}$ (usually written thanks to the infix operator
$\bind$) models the control flow of a program with effects, like the abstract
syntax tree nodes would.
%
It defines how the result of one computation determines the following ones.

\begin{example}[Copy]
  We define $\func{copy} : \mathpzc{Loc} \rightarrow \mathpzc{Loc} \rightarrow
  P_{\I_{\mathrm{DRAM}}}(\{()\})$ such that $\func{copy}(l, l')$ models a
  program with effects that returns no result, but copies the value $v$ stored
  at the memory location $l$ inside the memory location $l'$.
  %
  \[ \func{copy}(l, l') \triangleq \func{Request}(\func{Read}_{\mathrm{DRAM}}(l))
    \bind \lambda v. \func{Request}(\func{Write}_{\mathrm{DRAM}}(l', v))
  \]
\end{example}

Given $l \in \mathpzc{Loc}$ and $l' \in \mathpzc{Loc}$, $\func{copy}(l, l')$
symbolically models a program with effects.
%
To assign an interpretation of this program, it must be completed with an
operational semantics which realizes the interface $\mathcal{I}_{\mathrm{DRAM}}$.

\begin{definition}[Program With Effects Realization] \label{def:freespec:realisation}
  Let $\I$ be an interface, $\sigma \in \Sigma_{\I}$ an operational
  semantics for this interface and $\rho \in P_{\I}(\mathcal{A})$ a program with
  effects which belong to this interface.
  %
  $\sigma[\rho] \in \mathcal{A} \times \Sigma_{\I}$ denotes the realization of
  this program by $\sigma$, defined as:
  \[ \sigma[\rho] \triangleq \left\{
      \begin{array}{lcl} (x, \sigma) & \text{if} & \rho =
                                                   \func{Pure}(x) \\
        \sigma(e) & \text{if} & \rho =
                                \func{Request}(e) \\
        \sigma'[f(y)] & \text{if} & \rho =
                                    q \bind f\text{ and }(y, \sigma') = \sigma[q] \\
      \end{array}
    \right.
  \]
\end{definition}

\subsection{Components as Programs with Effects}
% -----------------------------------------------------------------------------

With the interfaces, their operational semantics, the $\oplus$ and $\otimes$
operators to compose them and the Program monad to model programs with effects
which belong to these interfaces, we now have all we need to model a given
component which exposes an interface $\I$ and uses another interface
$\J$.
%
We proceed with the following steps: modelling the component in terms of
programs with effects, then deriving one operational semantics for $\I$ from
these programs, assuming provided an operational semantics for $\J$.

The behaviour of a component is often determined by a local, mutable state.
%
When it computes the result of a computational request, not only a component may
read its current state; but it can also modify it, for instance to handle the
next computational request differently.
%
This means we have to model the state of a component with a set $\mathcal{S}$ of
symbolic state representations.
%
We map the current state of the component and effects of $\I$ to a program with
effects of $\J$.
%
These programs must compute the effect result and the new state of the
component.

\begin{definition}[Component] \label{def:freespec:component-model}
  Let $\I$ be the interface exhibited by a component and $\J$ the
  interface it uses.
  %
  Let $\mathcal{S}$ be the set of its states.
  %
  The component $C$, defined in terms of programs with effects of $\J$, is of
    the form \[ \forall \mathcal{A}, \Interface{\I}{\mathcal{A}} \rightarrow
    \mathcal{S} \rightarrow P_{\J}(\mathcal{A} \times \mathcal{S}) \]
\end{definition}

Hence, $C$ specifies how the component handles computational requests, both in
terms of computation results and state changes.

\begin{example}[Minimal MCH Model] \label{ex:mch-specs}
  Let $C_{\mathrm{MCH}}$ be the MCH defined in terms of programs with effects of
  $\I_{\mathrm{DRAM}} \oplus \I_{\mathrm{VGA}}$, then $C_{\mathrm{MCH}}$ is of
  the form
  \[
    \forall \mathcal{A}, \Interface{\I_{\mathrm{MCH}}}{\mathcal{A}} \rightarrow
    \mathcal{S}_{\mathrm{MCH}} \rightarrow P_{\I_{\mathrm{DRAM}} \oplus \I_{\mathrm{VGA}}}(\mathcal{A}
    \times \mathcal{S}_{\mathrm{MCH}})
  \] where $\mathcal{S}_{\mathrm{MCH}} \triangleq \{ \val{on}, \val{off} \}$ means
  the SMRAM protection is either activated ($\val{on}$) or deactivated
  ($\val{off}$).

  One the one hand, the \func{Lock} effect will activate the isolation
  mechanism of the MCH, setting its state to $\val{on}$.
  %
  On the other hand, the effects constructed with $\func{Read}_{\mathrm{MCH}}$ and $\func{Write}_{\mathrm{MCH}}$
  will use the current state of the MCH, the privileged parameter of the
  effect and the memory location to lookup to determine if it uses the DRAM
  or the VGA controller.
  %
  By default, it fetches the memory of the DRAM controller, except if the
  isolation mechanism is activated, the access is unprivileged and the targeted
  memory location belongs to the SMRAM.
  %
  In such a case, it reroutes access to the VGA controller.
\end{example}

A component $C$ defined in terms of programs with effects cannot be used as-is
to compute the result of a given effect.
%
To do that, we need to derive an operational semantics for~$\I$ from $C$.

\begin{definition}[Deriving Operational Semantics] \label{def:freespec:derivation}
  Let $C$ be a component which exhibits an interface $\I$, uses an
  interface~$\J$ and whose states belong to $\mathcal{S}$.
  %
  Let $s \in \mathcal{S}$ be the current state of the component and $\sigma_j
  \in \Sigma_{\J}$ be an operational semantics for~$\J$.
  %
  We can derive an operational semantics for $\mathcal{I}$, denoted by $\langle
  C, s, \sigma_j \rangle$, defined as
  \[ \langle C, s, \sigma_j \rangle \triangleq \lambda i. (x, \langle C, s',
    \sigma_j' \rangle) \text{ where } ((x, s'), \sigma_j') = \sigma_j[C (i, s)]
  \]
\end{definition}

%On the one hand, components are defined in terms of programs with
%effects, meaning each component can be modelled independently from the rest of
%the system.
%%
%On the other hand, FreeSpec introduces the mechanism of derivation to aggregate
%these models together.
%
The resulting operational semantics models a system made of
interconnected components, and can then be used to derive another
component model into an operational semantics which models a larger system.
%
For instance, we can proceed with the following steps to comprehensively model
our running example: (i) defining the operational semantics for the DRAM and VGA
controllers; (ii) using these operational semantics to derive an operational
semantics from $C_{\mathrm{MCH}}$.
%
The resulting operational semantics can take part in the derivation of a
cache defined in terms of programs with effects of $\I_{\mathrm{MCH}}$, to
model a larger part of the system pictured in the
Figure~\ref{fig:freespec:computing-platform}.

\section{Modular Verification of Programs with Effects}
% =============================================================================
\label{sec:freespec:verifying}

The first objective of FreeSpec is to provide the required tools to model each
component of a system independently, and to compose these components to model
the whole system.
%
Its second objective is to verify that the composition of several components
satisfies a set of properties.
%
To achieve that, we introduce the so-called abstract specifications, which
allows for specifying, for each interface, expected properties for the effect
results, independently of any underlying handler.
%
Abstract specifications can be used to emphasize the responsibility
of each component of a system regarding the enforcement of a given security
policy.
%
Verifying a component is done against abstract specifications of the interfaces
it directly uses, even if it relies on a security property enforced by a deeper
component in the components graph.
%
In this case, we have to verify that every single component which separate them
preserve this property.
%
This procedure can help to prevent or uncover architectural attacks.

In this section, we proceed with our running example by verifying that the MCH
correctly isolates the SMRAM.
%
In order to do that, we define an abstract specification which states that
privileged reads targeting the SMRAM returns the value which has previously been
stored by a privileged write. It models the SMRAM isolation: unprivileged writes cannot
tamper with the content of the SMRAM, as read by a privileged CPU.

\subsection{Definition}
% -----------------------------------------------------------------------------

In FreeSpec, an abstract specification dedicated to an interface $\I$ is
twofold.
%
It defines a precondition over the effects that a caller must satisfy;
and, in return, it specifies a postcondition over the effects results that an
operational semantics must enforce.
%
Since both the precondition and the postcondition may vary in
time, we parameterize an abstraction specification with an abstract state and a
step function to update this state after each effect realization.

\begin{definition}[Abstract Specification] \label{def:freespec:abstract-specs}
  We write $A$ for an abstract specification dedicated to an interface $\I$,
  defined as a tuple $\langle \Omega, \func{step}, \func{pre}, \func{post}
  \rangle$ where
  \begin{itemize}
  \item $\Omega$ is a set of abstract states
  \item $\func{step} : \forall \mathcal{A}, \Interface{\I}{\mathcal{A}}
    \rightarrow \mathcal{A} \rightarrow \Omega \rightarrow \Omega$
  is a transition function for the abstract state.
  \item $\func{pre} \subseteq \I \times \Omega$ is the precondition over
  effects, such that $(e, \omega) \in \func{pre}$ if and only if the effect $e$
  satisfies the precondition parameterized with the abstract state $\omega$
  (denoted by $\func{pre}(e, \omega)$).
  \item $\func{post} \subseteq \bigcup_{\mathcal{A}}
    (\Interface{\I}{\mathcal{A}} \times \mathcal{A} \times \Omega)$ is the
    postcondition over effects results, such that $(e, x, \omega) \in
    \func{post}$ if and only if the results $x$ computed for the effects $e$
    satisfies the postcondition parameterized with the abstract state $\omega$
    (denoted by $\func{post}(e, x, \omega)$).
  \end{itemize}
\end{definition}

By defining an abstract specification of an interface $\I$, it becomes possible
to abstract away the effect handler, i.e. the underlying component.
%
As a consequence, reasoning about a program with effects can be achieved without
the need to look at the effect handlers.
%
An abstract specification is dedicated to one verification problem (in our
context, one security property), and it is possible to define as many
abstraction specifications as required.

We write $\func{run}_{\func{step}} : \forall \mathcal{A}, \Sigma_{\I}
\rightarrow P_{\I}(\mathcal{A}) \rightarrow \Omega \rightarrow (\mathcal{A}
\times \Sigma_{\I} \times \Omega)$ for the function which, in addition to
realize a program with effects, updates an abstract state after each effect.
%
Using $\func{run}_{\func{step}}$, we can determine both the precondition over
effects and the postcondition over effects results while an operational
semantics realizes a program with effects.

\begin{example}[MCH Abstract Specification] \label{ex:mch-abs-specs} Let
  $A_{\mathrm{MCH}}$ be the abstract specification such that $A_{\mathrm{MCH}} = \langle
    \Omega_{\mathrm{MCH}}, \func{step}_{\mathrm{MCH}}, \func{pre}_{\mathrm{MCH}}, \func{post}_{\mathrm{MCH}}
    \rangle$.
  %
  $A_{\mathrm{MCH}}$ models the following property: ``\emph{privileged reads
  targeting the SMRAM return the value which has been previously stored
  by a privileged write}’’:
  \begin{itemize}
  \item Let $\mathpzc{Smram} \subseteq
    \mathpzc{Loc}$ be the set of memory locations which belong to the SMRAM.  We
    define $\Omega_{\mathrm{MCH}} \triangleq \mathpzc{Smram} \rightarrow
    \mathpzc{Val}$, such that $\omega \in \Omega_{\mathrm{MCH}}$ models a
    view of the SMRAM as exposed by the MCH for privileged reads.
  \item We define $\func{step}_{\mathrm{MCH}}$ which updates the view of the MCH
  (modelled as a function) after each privileged
  write access targeting any SMRAM location $l$, that is
    \[ \func{step}_{\mathrm{MCH}}(e, x, \omega) \triangleq \left\{
        \begin{array}{l}
          \lambda l'.  \text{ (if } l = l' \text{ then } v \text{ else } \omega(l')) \\
            \qquad\ \ \text{ if } e = \func{Write}_{\mathrm{MCH}}(l, v, \val{smm})
            \text{ and } l \in \mathpzc{Smram} \\
          \omega \qquad \text{ otherwise}
        \end{array}
      \right.
    \]
  \item There is no precondition to the use of the MCH effects, so \[ \forall e
  \in \I,\forall \omega \in \Omega_{\mathrm{MCH}}, \func{pre}_{\mathrm{MCH}}(e,
  \omega) \]
  \item The postcondition enforces that the result $x$ of a privileged read
  targeting the SMRAM ($\func{Read}(l, \val{smm})$) has to match the value
  stored in $A_{\mathrm{MCH}}$ abstract state, i.e. the expected content for
  this memory location $\omega(l)$.
    \[ \func{post}_{\mathrm{MCH}}(e, x, \omega) \triangleq \forall l \in \mathpzc{Loc}, e
      = \func{Read}_{\mathrm{MCH}}(l, \val{smm}) \wedge l \in \mathpzc{Smram}
      \Rightarrow x = \omega(l)
    \]
  \end{itemize}
\end{example}

%With an abstract specification $\langle \Omega, \func{step}, \func{pre},
%\func{post} \rangle$, we can transparently update a given abstract state while
%realizing programs.

\subsection{Compliance and Correctness}
% -----------------------------------------------------------------------------

The verification of a component~$C$, which exhibits $\I$ and uses $\J$, consists
in proving we can derive an operational semantics $\sigma_i$ for $\I$ from an
operational semantics $\sigma_j$ for $\J$.
%
This semantics $\sigma_i$ enforces the postcondition of an abstract
specification $A_{\I}$ dedicated to $\I$ (compliance).
%
As $C$ is defined in terms of programs with effects of $\J$, the latter
needs to make a licit usage of $\J$ with respect to an abstract
specification $A_{\J}$ dedicated to $\J$ (correctness).

First, $\sigma_i$ complies with $A_{\I}$ if, (1) given any effect which satisfies
$A_{\I}$ precondition, $\sigma_i$ produces a result which satisfies its
postcondition, and if (2) the new operational semantics $\sigma_i'$ also complies
with $A_{\I}$.
%
The precondition and the postcondition are parameterized by an abstract state,
so is the compliance property.

\begin{definition}[Operational Semantics Compliance] \label{def:freespec:compliance}
  Let $A$ be an abstract specification for an interface $\I$, defined as
  $\langle \Omega, \func{step}, \func{pre}, \func{post} \rangle$, $\omega \in
  \Omega$, then $\sigma \in \Sigma_{\I}$ complies with $A$ in accordance with
  $\omega$ (denoted by $\sigma \models A[\omega]$) iff. \[
    \forall e \in \I,
    \func{pre}(e, \omega) \Rightarrow \func{post}(e, x,
    \omega) \wedge \sigma' \models A[\func{step}(e, x, \omega)]
    \text{ where }(x, \sigma') = \sigma(e)
  \]
\end{definition}

Secondly, programs with effects of $C$ make a licit usage of an operational
semantics $\sigma_j \in \Sigma_{\J}$ which complies with $A_{\J}$ if they only
use effects which satisfy $A_{\J}$ precondition.
%
As for the compliance property, correctness is parameterized with an abstract
state.

\begin{definition}[Program With Effects Correctness] \label{def:freespec:correctness}
  Let $A$ be an abstract specification for an interface $\I$, defined as
  $\langle \Omega, \func{step}, \func{pre}, \func{post} \rangle$, $\omega \in
  \Omega$, and $\rho \in P_{\I}(\mathcal{A})$, then $\rho$ is correct
  with respect to $A$ in accordance with $\omega$ (denoted by $A[\omega]
  \modelssym \rho$), iff.
  \[
    A[\omega] \mathrel{\reflectbox{$\models$}} \rho \triangleq \left\{
      \begin{array}{lcl}
        \text{True} & \text{ if} & \rho = \func{Pure}(x) \\
        \func{pre}(e, \omega) & \text{ if} & \rho = \func{Request}(e) \\
        \forall \sigma \in \Sigma_{\I} \text{ such that } \sigma \models
        A[\omega], & & \\
        \qquad A[\omega] \modelssym q \wedge A[\omega'] \modelssym f(x) & \text{
                                                                          if} & \rho = q \bind f \\
        \text{where }(x, \_, \omega') =
        \func{run}_{\func{step}_{\J}}(\sigma, q, \omega) & \\
      \end{array}
    \right.
  \]
  %\guillaumerk{franchement, le symbole \protect\reflectbox{$\models$} est
  %vraiment trop proche de $\models$. Je comprends l'idée mais c'est source de
  %confusion. Je choisirai un symbol bien discinct.}
\end{definition}

Every local computation ($\func{Pure}$) is correct with respect to
$A$ in accordance with~$\omega$.
%
A computation which uses an effect $e \in \I$ ($\func{Request}$) is
correct with respect to $A$ in accordance with~$\omega$ if and
only if $e$ satisfies the precondition of $A$ for the abstract
state $\omega$.
%
Finally, the chaining of two programs with effects ($\func{Bind}$) is correct
with $A$ in accordance with~$\omega$ if the first program is
correct with $A$ in accordance with~$\omega$, and the second
program is correct in accordance with the abstract state reached after the
realization of the first program.

Properties, inferred from an abstract specification, of a correct program with
effects only hold if it is realized by a compliant operational semantics.
%
Besides, we prove that correct programs preserve operational semantics
compliance.

\begin{theorem}[Compliance Preservation]
  Let $A$ be an abstract specification dedicated to an interface $\I$, then
  $\sigma$ a compliant operational semantics for $\I$ produces a compliant
  operational semantics $\sigma'$ when it realizes a correct program $\rho$,
  that is
  \[
    \sigma \models A[\omega] \wedge A[\omega] \modelssym \rho \Rightarrow
    \sigma' \models A[\omega'] \text{ where
    }\func{run}_{\func{step}}(\sigma, \rho, \omega) = (x, \sigma', \omega')
  \]
\end{theorem}

As for interfaces (with $\oplus$) and operational semantics (with $\otimes$), we
have also defined an abstract specification composition operator $\odot$.
%
We do not detail its definition in this article, but it has the significant
property to allow for reasoning about the composition of interfaces and
composition of operational semantics.

\begin{theorem}[Congruent Composition]
  Let $\I$ (respectively $\J$) be an interface.
  %
  Let $A_{\I}$
  (respectively $A_{\J}$) be an abstract specification and $\sigma_i
  \in \Sigma_{\I}$ (respectively $\sigma_j \in \Sigma_{\J}$) be an
  operational semantics for this interface.
  \[ \sigma_i \models A_{\I}[\omega_i] \wedge \sigma_j \models A_{\J}[\omega_j]
    \Rightarrow \sigma_i \otimes \sigma_j \models
    (A_{\I} \odot A_{\J})[\omega_i, \omega_j]
  \]
\end{theorem}

%\begin{theorem}[Congruent Lifting]
%  Let $\I$ (respectively $\J$) be an interface. Let $A_I$
%  (respectively $A_J$) be an abstract specification and
%  $\rho_i \in P_{\I}(\mathcal{A})$ (respectively
%  $\rho_j \in P_{\J}(\mathcal{A})$) be an effectful computation which
%  uses this interface.
%  \[ A_I[\omega_i] \modelssym \rho_i \Rightarrow A_I \odot A_J [\omega_i,
%    \omega_j] \modelssym \func{liftl}(\rho_i)
%  \]
%  \[ A_J[\omega_j] \modelssym \rho_j \Rightarrow A_I \odot A_J [\omega_i,
%    \omega_j] \modelssym \func{liftr}(\rho_j)
%  \]
%\end{theorem}

With the Compliance Preservation, we know that as long as we follow the abstract
specification precondition related to the effects we use, compliant operational
semantics keep enforcing the postcondition.
%
With the Compliance Preservation and Congruent Composition, we know we can
reason locally, that is component by component.

\subsection{Proofs Techniques to Show Compliance For Components}
% -----------------------------------------------------------------------------

We have dived into the mechanisms which allow for composing together compliant
operational semantics, but little has been said about how to prove the
compliance property to begin with.
%
In a typical FreeSpec use case, operational semantics are not built as-is, but
rather derived from a component model (Definition~\ref{def:freespec:derivation}).
%
How to prove the resulting operational semantics complies with an abstract
specification depends on how the component is connected to the rest of the
system.
%
We have already discussed the consequences of the operational semantics
composition operator $\otimes$ (Definition~\ref{def:freespec:semantics-composition}).
%
Notably, a graph of components which contains a cycle, a diamond or a forward
edge cannot be easily modelled and verified in FreeSpec.
%
In its current state, FreeSpec provides some theorems to verify the properties
of a component model in terms of an abstract specification, depending on the
composition pattern.

The most favourable scenario consists of one component which uses many
components, and is only used by one other component.
%
Let $\I$ and $\J$ be two interfaces and let $C$, a component with a set of
possible states $\mathcal{S}$, which exhibits $\I$ and uses $\J$.
%
Let $A_{\I}$ be an abstract specification dedicated to $\I$.
%
Deriving an operational semantics from $C$ which complies with $A_{\I}$ in
accordance with $\omega_i \in \Omega_I$ requires to show the existence of $s \in
\mathcal{S} \text{ and }\sigma_j \in \Sigma_{\J}$ such that \[ \langle
C, s, \sigma_j \rangle \models A_{\I}[\omega_i]. \]
%
However, proving this statement would not be very satisfying, as it ties our
verification results to one specific operational semantics $\sigma_j$, and by
extension one specific component.
%
As a consequence, we define an abstract specification $A_{\J}$ to
generalize our statement and abstracting away $\sigma_j$.
%
We now need to prove it exists $\omega_j \in \Omega_{\J}$ such that
given an operational semantics $\sigma_j$ which complies with $A_{\J}$
in accordance with $\omega_j$, the operational semantics derived from $C$, $s$
and $\sigma_j$ complies with $A_{\I}$ in accordance with $\omega_i$, that is \[
  \forall \sigma_j \in \Sigma_{\J}\text{, }\sigma_j \models
  A_{\J}[\omega_j] \Rightarrow \langle C, s, \sigma_j \rangle \models
  A_{\I}[\omega_i]
\]

The combinatorial explosion of cases introduced by $\omega_i$, $s$ and
$\omega_j$, modified as the component handles effects, makes inductive
reasoning challenging.
%
The FreeSpec framework provides a useful theorem to address these challenges,
which leverages a so-called predicate of synchronization.
%
The latter is defined by the user on a case-by-case basis, to act as an
invariant for the induction, and a sufficient condition to enforce compliance.

\begin{theorem}[Derivation Compliance] \label{theorem:der-compliance}
  Let $\func{sync}$, a relation between abstract states of $\Omega_{\I}$ and
  $\Omega_\J$, states of $\mathcal{S}$, be a predicate of
  synchronization.
  %
  Then, it is expected that, $\forall \omega_i \in \Omega_{\I}$, $s \in
  \mathcal{S}$ and $\omega_j \in \Omega_{\J}$ such that
  $\func{sync}(\omega_i, s, \omega_j)$ holds, then $\forall \sigma_j \in
  \Sigma_{\J}$ such that $\sigma_j \models A_{\J}[\omega_j]$
  and $\forall e \in \I$ such that $\func{pre}_{\I}(e, \omega_i)$,
  \begin{enumerate}
  \item $C$ preserves the synchronization of states, that is
    $\func{sync}(\omega_i', s', \omega_j')$
  \item $C$ is defined in terms of programs with effects which are correct with
    respect to $A_{\J}$ in accordance with $\omega_j$, that is
    $A_{\J}[\omega_j] \modelssym C(e, s)$
  \item $C$ computes a result for $e$ which satisfies $A_{\I}$ postcondition,
     that is $\func{post}_{\I}(e, x, \omega_i)$
  \end{enumerate}
  where
  $((x, s'), \sigma_j', \omega_j') = \func{run}_{\func{step}_{\J}}(\sigma_j,
  C(e, s), \omega_j)$ and
  $\omega_i' = \func{step}_{\I}(e, x, \omega_i)$.
  %
  Should these three properties be verified, then we show that
  \[ \func{sync}(\omega_i, s, \omega_j) \wedge \sigma_j \models
    A_{\J}[\omega_j] \Rightarrow \langle C, s, \sigma_j \rangle \models
    A_{\I}[\omega_i].
  \]
\end{theorem}

\begin{example}[MCH Compliance]
  We want to prove we can derive an operational semantics from $C_{\mathrm{MCH}}$
  (Example~\ref{ex:mch-specs}) which complies with $A_{\mathrm{MCH}}$
  (Example~\ref{ex:mch-abs-specs}).

  We define
  $A_{\mathrm{DRAM}} \triangleq \langle \Omega_{\mathrm{DRAM}}, \func{step}_{\mathrm{DRAM}},
  \func{pre}_{\mathrm{DRAM}}, \func{post}_{\mathrm{DRAM}} \rangle$ an abstract specification
  dedicated to $\I_{\mathrm{DRAM}}$ to express the following property: ``\emph{a
  read access to a memory location which belongs to the SMRAM return the value
  which have been previously written at this memory location}.'' In particular,
  $\Omega_{\mathrm{DRAM}} = \Omega_{\mathrm{MCH}}$, i.e. they are two views of
  the SMRAM, as exposed by the DRAM controller or by the MCH.
  %
  In this context, the behaviour of VGA is not relevant. Let $\top$ be the
  abstract specification which has no state and such that its precondition and
  postcondition are always satisfied (meaning every operational semantics always
  complies with it).
  %
  Therefore, the abstract specifications dedicated to the interface used by
  $C_{\mathrm{MCH}}$, that is $\I_{\mathrm{DRAM}} \oplus \I_{\mathrm{VGA}}$, is $A_{\mathrm{DRAM}} \odot \top$ whose
  abstract state is $\Omega_{\mathrm{DRAM}}$.

  We define the predicate of synchronization $\func{sync}_{\mathrm{MCH}}$ such that
  \[ \func{sync}_{\mathrm{MCH}}(\omega_i, s, \omega_j) \triangleq s = \val{on}
    \wedge \forall l \in \mathpzc{Smram}, \omega_i(l) = \omega_j(l)
  \] Hence, we start our reasoning from a situation where the SMRAM
  isolation is already activated and the states of the two abstract
  specifications are the same, meaning the two views of the SMRAM (as stored in
  the DRAM, and as exposed by the MCH) coincide.
  %
  We prove $\func{sync}_{\mathrm{MCH}}$ satisfies the three premises of the
  Theorem~\ref{theorem:der-compliance}. We conclude we can derive
  an operational semantics from $C_{\mathrm{MCH}}$ which complies with $A_{\mathrm{MCH}}$.
\end{example}

Another common composition pattern consists of a component which is used by more
than one other component.
%
FreeSpec provides a theorem which allows for extending the result obtained with
the Theorem~\ref{theorem:der-compliance}, in the specific case where concurrent
accesses do not lead to any change of the abstract state.

\section{Conclusion}
% =============================================================================
\label{sec:freespec:scale}

For two sections, we have introduced the FreeSpec key definitions and theorems
so that we could model a minimal MCH component and verify its properties in the
presence of a well-behaving DRAM controller.
%
This example has been driven by a real mechanism commonly found inside x86-based
computing platforms.
%
We now discuss how FreeSpec can be leveraged to model and verify larger systems.
%and limitations we anticipate.

The typical workflow of FreeSpec can be summarized as follows: specifying the
interfaces of a system; modelling the components of the system in terms of
programs with effects of these interfaces; identifying the abstract
specifications which express the requirements over each interface; verifying
each component in terms of compliance with these abstract specifications.

Independent groups of people can use FreeSpec to modularly model and verify a
system, as long as they agree on the interfaces and abstract specifications.
%
If, during the verification process, one group finds out a given interface or
abstract specification needs to be updated, the required modifications may
impact its neighbours.
%
For instance, modelling a x86-based computing system, as pictured in
Figure~\ref{fig:freespec:computing-platform}, using FreeSpec requires to take
into account the CPU cache, and to verify it complies with an abstract
specification similar to the one defined in Example~\ref{ex:mch-abs-specs}.
%
Thus, FreeSpec could have helped uncover the SMRAM cache poisoning attack
previously mentioned\,\cite{wojtczuk2009smram,duflot2009smram}, and other
similar architectural attacks.

The abstract specifications are defined in terms of interfaces, i.e.
independently from components.
%
It has two advantages.
%
First, for a given verification problem modelled with a set of abstract
specifications, two components which exhibit the same interface can be proven to
comply with the same abstract specification.
%
In such a case, we can freely interchange these components, and the verification
results remain true.
%
This is useful to consider the challenge posed by components versioning, i.e. a
new version of a component brings new features which could be leveraged by an
attacker.
%
Then, it is possible to verify a given component in terms of several abstract
specifications.
%
This means we can independently conduct several verification works against the
same component.