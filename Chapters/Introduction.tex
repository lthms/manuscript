%!TEX root = ../main.tex
\chapter{Introduction}
\label{chapter:introduction}

\endquote{``\emph{All problems in computer science can be solved by another
    level of indirection.}''

  \hfill\footnotesize --- David Wheeler}

\vspace{1cm}\noindent
%
\TODO{Remarque générale : je trouve ton intro un peu trop longue. Surtout, les paragraphes avant le 1.1 sont long et parlent d'un point très spécifique (l'architecture en couche d'une plateforme x86). Je pense qu'il faudrait placer ces paragraphes dans une sous-section à part et réserver les paragraphes situés avant 1.1 à une description générale de la problématique abordées dans cette thèse.}

To manage complexity, computing platforms are commonly built as successions of
abstraction layers, from the hardware components to high-level software
applications.
%
Each layer leverages the interface of its predecessor to expose a higher-level,
more constrained set of functionalities for its successors.
%
This enables separation of concerns ---each layer encapsulates one dimension of
the overall complexity--- and modularity ---two layers which expose the same
interface can be seamlessly interchanged.
%
The typical computing platform can be broken down to the following layers:
%
\begin{description}
\item [Hardware Architecture]
  %
  A computer is made of several inter\-connected, physical hardware components.
  %
  Hardware components take many forms and serve as different purposes, from the
  \ac{cpu}, which executes the pieces of software that together form the upper
  layers of abstraction, to the various input/output devices, which allow users
  to interact with the computing platform.
  %
\item [Firmware/BIOS]
  %
  Hardware components often require some firm\-ware, \emph{i.e.} a dedicated
  piece of software, to operate.
  %
  Hardware manufacturers tend to embed some features in their firmware for
  several reasons.
  %
  To begin with, updating software is easier than updating hardware, as the
  latter often requires a recall.
  %
  Vendors can also implement additional high-level, business focus features in
  their firmware to differentiate from competitors.
  %
  For instance, Intel has started to provide out-of-band management features to
  its processors in 2008\,\cite{ruan2014me}.
  %
  In addition, a dedicated piece of firmware is responsible for the
  initialization and runtime management of the platform as a whole.
  %
  Afterwards, when we refer to this specific type of firmware, we use the term
  \ac{bios}.
  %
  Notably, the \ac{uefi}\,\cite{uefi2017uefi} is a standard whose purpose is to
  describe the role and software architecture for modern \ac{bios}.
  %
  \PC{(Pas seulement ici): Le style est assez haché, beaucoup de petites phrases
    qui rendent la lecture un peu difficile.  Il faudrait lisser un peu}
  %
\item [System Software]
  %
  The computing environment provided by the hardware architecture alone is very
  generic.
  %
  As a consequence, it requires a non-trivial amount of configuration.
  %
  System software components leverage this environment to provide high-level
  interfaces.
  %
  For instance, operating systems expose a set of system calls to applications.
  %
  Thus, applications often do not care about which particular hardware
  architecture they are executed on.
  %
  System software components also deal with the complexity implied by the
  concurrent execution of several applications.
  %
\item [Applications]
  %
  Applications leverage the high-level interface exposed by the system software
  component in order to provide services to users of the computing platform.
  %
  The previous layers only exist so that applications can be executed on a
  powerful computing platform, yet only focus on business logic.
\end{description}

\begin{figure}
  \centering
  \begin{tikzpicture}
    %% HARDWARE
    \node [draw, inner sep=8pt, text width=100pt, minimum height=40pt, text
    badly centered] (Core) {CPU};%
    \node [draw, inner sep=8pt, left=5pt of Core, text width=60pt, minimum
    height=40pt, text badly centered] (Card) {Graphic Card};%
    \node [draw, inner sep=8pt, right=5pt of Core, text width=60pt, minimum
    height=40pt, text badly centered] (MC) {Memory Controller};%

    \draw [dotted] ([yshift=5pt,xshift=-5pt]Card.north west) --
    ([yshift=5pt,xshift=125pt]MC.north east);%

    %% FIRMWARE
    \node [draw, inner sep=8pt, above=10pt of Card, text width=60pt, minimum
    height=135.5pt, text badly centered, dashed] (CardFW) {};%
    \node [draw, inner sep=8pt, above=10pt of MC, text width=60pt, minimum
    height=135.5pt, text badly centered, dashed] (MCFW) {};%
    \node [draw, inner sep=8pt, above=10pt of Core, text width=100pt, minimum
    height=25pt, text badly centered] (CoreFW) {CPU Microcode};%
    \node [draw, inner sep=8pt, above=5pt of CoreFW, text width=100pt, minimum
    height=25pt, text badly centered] (BIOS) {BIOS};%

    \draw [dotted] ([yshift=71pt,xshift=-5pt]Card.north west) --
    ([yshift=71pt,xshift=125pt]MC.north east);%

    %% OS
    \node [draw, inner sep=8pt, above=10pt of BIOS, text width=100pt, minimum
    height=30pt, text badly centered] (OS) {Operating System};%

    \draw [dotted] ([yshift=111pt,xshift=-5pt]Card.north west) --
    ([yshift=111pt, xshift=125pt]MC.north east);%

    %% Applications
    \node [draw, above=10pt of OS, text width=29, minimum height=30pt, text
    badly centered] (App1) {App};%
    \node [draw, right=5pt of App1, text width=28.5, minimum height=30pt, text
    badly centered] (App2) {App};%
    \node [draw, left=5pt of App1, text width=28, minimum height=30pt, text
    badly centered] (App3) {App};%

    %% LINKS

    \draw [dashed] (Card) -- (CardFW);%
    \draw (Card) -- (Core);%
    \draw (MC) -- (Core);%
    \draw [dashed] (MC) -- (MCFW);%
    \draw (Core) -- (CoreFW);%
    \draw (CoreFW) -- (BIOS);%
    \draw (BIOS) -- (OS);%
    \draw (App1) -- (OS);%
    \draw (App2.south) |- (OS.north);%
    \draw (App3.south) |- (OS.north);%

    %% LAYERS
    \node [right=of MC] (Hardware) {\scshape Hardware};%
    \node [right=of MC, yshift=60pt] (Hardware) {\scshape Firmware};%
    \node [right=of MC, yshift=110pt] (Hardware) {\scshape System Software};%
    \node [right=of MC, yshift=150pt] (Hardware) {\scshape Applications};%
  \end{tikzpicture}

  \caption{Layers of abstractions in a hypothetical computing platform}
  \label{fig:intro:layers}
\end{figure}

Variations of these abstraction layers exist.
%
For instance, for embedded devices, it is common that the system software and
the applications form one single software component, executed within the same
hardware context.
%
On the contrary, for mainstream computers, the system software can be formed by
an operating system only, or by the combination of one hypervisor and several
operating systems.
%
The latter case is common in the context of cloud computing, where mainstream
hypervisors (\emph{e.g.} Xen\,\cite{barham2003xen},
Hyper-V\,\cite{velte2009hyperv}) provide powerful features such as virtual
machines snapshots or migrations.
%
It is also frequent that application internals are themselves built as
abstraction layers (\emph{e.g.} applicative framework, core logic, plugins).

Figure~\ref{fig:intro:layers} pictures the abstraction layers of an hypothetical
---yet inspired by the Intel x86 hardware architecture--- computing platform.
%
The \ac{cpu} is connected to two other hardware components, a graphic card and a
memory controller.
%
These three hardware components execute a software stack each.
%
Some features of the \ac{cpu} are implemented in the form of ``microcode''
programs\,\cite{chen2014microcode}, which determine, in part, the semantics of
the instruction set.
%
The \ac{cpu} executes the \ac{bios}, an operating system (system software) and
several applications.
%
Both the graphic card and the memory controller execute their own software
stack, which may be broken down into several abstraction layers as well.

\section{Hardware-based Security Enforcement Mechanisms}

From a security perspective, layers are often used for privilege separation, and
each layer is often more privileged than its successors.
%
For instance, system software components manage the life cycle of the
applications, by actively tampering \TODO{c'est la première fois que tu utilises le termes tampering et tu ne l'as pas définis avant. Je pense que, dans le sens où tu veux l'utiliser, le termes n'est pas fréquent dans la littérature} with their execution.

As a consequence, each layer implicitly trusts its predecessors.
%
On the one hand, it is important to keep this fact in mind when we consider the
security of the computing platform.
%
Trust in lower levels of abstraction can be misplaced: hardware implants and
backdoors pose a significant threat to the platform security\,\cite{yang2016a2},
the \ac{bios} has been used as an attack vector to tamper with its execution \TODO{tu utilises à mon avis trop souvent "tamper with". Ce n'est pas courant, et c'est un tic de langage. En outre, je ne vois pas à quoi renvois "its execution"}
even after a machine restart\,\cite{embleton2013smm}, etc.
%
On the other hand, one layer may constrain the execution of its successors, with
respect to a targeted security policy.
%
For instance, an operating system shares hardware resources among several
applications, and therefore \TODO{le lien de cause à effet ne me parait pas évident. L'OS doit partager les ressources et il doit le faire correctement.} is able to enforce availability ---fair share of
\ac{cpu} time---, confidentiality and integrity ---exclusive partition of
physical memories--- properties.

Constraining an execution can be achieved in various ways.
%
Concerning the lowest layers of a software stack, the common approach is to rely
on features provided by the hardware architecture to reduce the hardware
capabilities that can be used by upper layers.
%
For instance, system software components often leverage among other mechanisms a
\ac{mmu} to partition the system memory.
%
Thus, when an application is executed, it can only access a subset of the system
memory.
%
Besides, the \ac{cpu} can leverage a hardware timer to stop applications
execution, without the need for these applications to cooperate.
%
This scenario characterizes a class of security mechanisms we call \ac{hse}
mechanisms.

\begin{definition}[Hardware-based Security Enforcement Mechanism]
  \label{def:intro:hse}
  %
  A \ac{hse} mechanism consists in the configuration by a trusted software
  component of the underlying hardware architecture in order to constrain the
  execution of untrusted software components with respect to a targeted security
  policy.
\end{definition}

A \ac{hse} mechanism enforces its targeted security property when
%
\begin{inparaenum}[(1)]
\item the trusted software components correctly configure the hardware features
  at their disposal, and
%
\item these features are sufficient to constrain the untrusted software
  execution as expected.
\end{inparaenum}
%
Both requirements remain challenging.

\paragraph{Software Errors.}
%
Part of vulnerabilities in \ac{hse} mechanism implementations by trusted
software components are due to some misuse of hardware
features\,\cite{bulygin2014summary}.
%
In the past, most lower-level pieces of software, such as firmware components,
have not been conceived and implemented with security as primary focus.
%
The increasing complexity of hardware architectures can also be held partly
responsible.
%
While computers are made of dozens of components, software developers have to
read and understand as many, independent and often large documents of various
forms (\emph{e.g.} data sheets, developer manuals), and they rarely focus on
security.
%
When software developers misunderstand the documentation, as it happened for
instance for the \texttt{mov ss} and \texttt{pop ss} x86
instructions\,\cite{movsspopss}, the impact in terms of security can be
significant.

\paragraph{Hardware Errors.}
%
Over the past decades, vendors have regularly added security features to their
products.
%
Intel, for instance, has notably introduced hardware-based virtualization (VT-x,
VT-d)\,\cite{intel2014manualvt}, dynamic root of trust
(TXT)\,\cite{intel2015txt}, or applicative enclaves
(SGX)\,\cite{intel2014manualsgx,costan2016sgxexplained}.
%
It is crucial to notice that most of them have been circumvented due to
implementation bugs\,\cite{wojtczuk2011txtbug,sang2010iommu}.
%
This is not surprising, as novel hardware features tend to be more and more
complex.
%
Hence, using advanced, novel hardware features in a security-sensitive context
may be counterproductive.
%
In addition to these implementation errors, the fact that hardware architectures
often comprise hundreds of features implemented by dozens of interconnected
devices complicates the conception of new hardware features.
%
Indeed, these new features should not interfere with the security properties
enforced by the existing components of the platform.
%
For instance, the flash memory (where lives the \ac{bios} code) is supposedly
protected against arbitrary write accesses from system software components,
thanks to a particular hardware interrupt.
%
When Intel introduced TXT\,\cite{intel2015txt}, they did not anticipate that
this novel security feature had the particular side effect of disabling the
hardware interrupt used to protect the flash memory\,\cite{kovah2015senter}.
%
This corresponds to a class of security vulnerability called compositional
attacks\,\cite{wing2003compositionalattack}. \TODO{Tu sembles maintenant utiliser le termes de compositional attack. Attention, dans l'abstract tu continues de parler de architectural attack}

\begin{definition}[Compositional Attack]
  Compositional attacks is the class of security vulnerabilities \TODO{meme remarque que dans l'abstract tu utilises "attack" pour désigner une vulnérabilité, ce qui n'est pas cohérent}, where each
  component is working as expected in isolation, yet their composition creates
  an attack path which prevents end-to-end security enforcement.
\end{definition}

In the context of \ac{hse} mechanisms, this means untrusted software components
can leverage one hardware component to defeat a \ac{hse} mechanism implemented
to constrain its execution.
%
% PC: “Compositional attacks are /often/ due...”  Réponse Thomas: Je ne vois pas
% d’autres raisons, en fait.  En tout cas, l’idée de base est qu’on ne
% s’intéresse qu’a celle là.
%
Compositional attacks are due to a flaw in the specifications of the computing
platform.
%
As such, they precede implementation errors, and their countermeasures often
require a change in the hardware interface.
%
To prevent them, it is mandatory to reason about the computing platform as a
whole.

\section{Formal Verification of HSE Mechanisms}
\label{sec:intro:verif}

The significant impact of previously disclosed compositional attacks \TODO{ajouter ici des ref concernant ces " previously disclosed compositional attacks"} have
motivated our will to formally specify HSE mechanisms.
%
We believe this would benefit both hardware designers and software developers.
%
Firstly, a formal specification of HSE mechanisms can be leveraged as a
foundation for a systemic approach to verify hardware specifications.
%
For each novel hardware feature introduced, it is necessary to check that the
previous proofs hold, meaning this feature does not introduce any compositional
attack.
%
Secondly, it provides unambiguous specifications to firmware and system software
developers, in the form of a list of requirements to comply with, and the
provided security properties.
%
We believe these specifications are a valuable addition to the existing
documentation, because they gather at one place information that is normally
scattered across many documents which sometimes suffer from lack of security
focus. \TODO{Cet argumentaire est repris à plusieurs endroits (dans l'abstract, ici dans l'intro et dans la section 5.5. Il faut à la fois s'assurer que ces différentes occurences sont cohérentes dans la manière de présenter les choses (il faudrait s'en assurer en les comparants car les différentes parties ont évoluées à des rythmes différent) et que ces différentes occurences ne sont pas redondantes. En gros, il faut que chaque nouvelle occurrence apporte quelque chose (un peu plus de détail, une mise en contexte, etc.}

To specify a HSE mechanism, we have to model the hardware architecture and the
scale of the task represents a significant challenge.
%
Compositional attacks can come from unsuspected places, with no apparent link
with the considered security mechanism.
%
For instance, the SENTER Sandman attack\,\cite{kovah2015senter} leveraged a
dedicated execution mode of x86 \acp{cpu} to disable the protection of the flash
memory wherein the \ac{bios} code is stored.
%
As a consequence, it is necessary to consider the whole computing platform.
%
At the same time, some components are individually complex:
%
for example, the Intel Architectures Software Developer Manual\,\cite{intel2014manual} is
4842 pages long,
%
the Memory Controller Hub datasheet\,\cite{intel2009mch} is 430 pages long, and
%
the Platform Controller Hub datasheet\,\cite{intel2012pch} is 988 pages long.

Besides, new hardware components and new versions of already existing components
are frequently released.
%
As a consequence, the more modular our models and proofs are, the more
practicable our approach becomes.
%
Otherwise, each modification of the hardware architecture will have an important
impact on the proofs already written.

\paragraph{}
%
While we intend to propose generic formalisms which can potentially be applied
to large ranges of problems, we have decided to systematically implement and
evaluate them on the x86 architecture.
%
Because of its predominant position on the personal computer market, the x86
hardware architecture has been extensively studied.
%
Our decision to explore this research field was based on our experience with
several compositional attacks which have affected the x86 hardware architecture.

\section{Contributions and Outline}

\TODO{Tu mélanges plan et contribution. J'aime pas trop. La contribution est du coup noyée dans le plan. Je préferais deux parties (paragraphes) distincts.}

In Part~\ref{part:context}, we elaborate on the context in which our works fall, \emph{i.e.} the security of lower levels of abstraction (hardware components and firmware).
%
In Chapter~\ref{chapter:usecase}, we give an introduction to the x86 hardware
architecture and the particular role played by the \ac{bios}.
%
We then detail some representative compositional attacks which have
been disclosed over the past decade.
%
% PC: attention, on comprend que tu vas décrire tout x86 en détails
%
In Chapter~\ref{chapter:relatedwork}, we revisit existing works \TODO{Je crois que yann t'a fait la remarque que related work est singulier. Je ne sais pas si c'est le cas mais il faut être cohérent dans tout le document} and approaches
in line with the two challenges we tackle in this thesis, that is:
%
\begin{inparaenum}[(1)]
\item formally specifying and verifying \ac{hse} mechanisms against a hardware
  model, and
%
\item modularly defining hardware models in terms of compositions of
  sub-components, with the objective of scaling to realistic ---that is, large
  and complex--- hardware architectures.
\end{inparaenum}

In Part~\ref{part:speccert}, we describe our first contribution.
%
In Chapter~\ref{chapter:speccert}, we present a generic formalism to specify and
verify HSE mechanisms against a hardware model.
%
In Chapter~\ref{chapter:speccert2}, we leverage our formal definition to reason
about HSE mechanisms which isolate software components from each other within a
software stack.
%
We have implemented SpecCert, a framework for the Coq proof assistant based on
this formalism.
%
Moreover, we have specified {\scshape Minx86}, a minimal x86 model, and we
have verified a HSE mechanism implemented by x86 BIOSes against {\scshape
  Minx86}.
%
This HSE mechanism relies on a high-privileged execution mode of x86 \acp{cpu}
called the System Management Mode\,\cite{intel2014manual}.
%
This work has been presented at the $21^{th}$ International Symposium on Formal
Methods (FM2016)\,\cite{letan2016speccert}.

Part~\ref{part:freespec} is dedicated to our second contribution.
%
In Chapter~\ref{chapter:freespec}, we present a compositional reasoning
framework to modularly specify and verify systems organized as trees of
components.
%
We apply ideas from verification of computer programs with side effects to the
domain of component-based modelling. The resulting approach can be used for
verifying the composition of hardware components and software components alike.
%
In addition, we have developed FreeSpec, a framework for the Coq proof
assistant.
%
FreeSpec provides the necessary definitions and theorems to specify components,
and automation features to guide their verification.
%
This work has been presented at the $22^{th}$ International Symposium on Formal
Methods (FM2018)\,\cite{letan2018freespec}.

Finally, we conclude this thesis in Chapter~\ref{chapter:conclusion}, where we
suggest some possible directions for future works.
